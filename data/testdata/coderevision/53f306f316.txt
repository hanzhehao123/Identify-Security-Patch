diff --git a/.github/lockdown.yml b/.github/lockdown.yml
index 07fc2f31ee..d3546bd2bc 100644
--- a/.github/lockdown.yml
+++ b/.github/lockdown.yml
@@ -14,11 +14,11 @@ issues:
     at https://gitlab.com/qemu-project/qemu.git.
     The project does not process issues filed on GitHub.
 
-    The project issues are tracked on Launchpad:
-    https://bugs.launchpad.net/qemu
+    The project issues are tracked on GitLab:
+    https://gitlab.com/qemu-project/qemu/-/issues
 
     QEMU welcomes bug report contributions. You can file new ones on:
-    https://bugs.launchpad.net/qemu/+filebug
+    https://gitlab.com/qemu-project/qemu/-/issues/new
 
 pulls:
   comment: |
diff --git a/MAINTAINERS b/MAINTAINERS
index 0ca6b7de94..1ced8cf07f 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -155,6 +155,7 @@ S: Maintained
 F: target/arm/
 F: tests/tcg/arm/
 F: tests/tcg/aarch64/
+F: tests/qtest/arm-cpu-features.c
 F: hw/arm/
 F: hw/cpu/a*mpcore.c
 F: include/hw/cpu/a*mpcore.h
@@ -328,7 +329,7 @@ F: tests/tcg/i386/
 F: tests/tcg/x86_64/
 F: hw/i386/
 F: disas/i386.c
-F: docs/system/cpu-models-x86*
+F: docs/system/cpu-models-x86.rst.inc
 T: git https://gitlab.com/ehabkost/qemu.git x86-next
 
 Xtensa TCG CPUs
diff --git a/README.rst b/README.rst
index a92c7394b7..79b19f1481 100644
--- a/README.rst
+++ b/README.rst
@@ -131,16 +131,16 @@ will be tagged as my-feature-v2.
 Bug reporting
 =============
 
-The QEMU project uses Launchpad as its primary upstream bug tracker. Bugs
+The QEMU project uses GitLab issues to track bugs. Bugs
 found when running code built from QEMU git or upstream released sources
 should be reported via:
 
-* `<https://bugs.launchpad.net/qemu/>`_
+* `<https://gitlab.com/qemu-project/qemu/-/issues>`_
 
 If using QEMU via an operating system vendor pre-built binary package, it
 is preferable to report bugs to the vendor's own bug tracker first. If
 the bug is also known to affect latest upstream code, it can also be
-reported via launchpad.
+reported via GitLab.
 
 For additional information on bug reporting consult:
 
diff --git a/block/coroutines.h b/block/coroutines.h
index 514d169d23..4cfb4946e6 100644
--- a/block/coroutines.h
+++ b/block/coroutines.h
@@ -66,10 +66,4 @@ int coroutine_fn bdrv_co_readv_vmstate(BlockDriverState *bs,
 int coroutine_fn bdrv_co_writev_vmstate(BlockDriverState *bs,
                                         QEMUIOVector *qiov, int64_t pos);
 
-int generated_co_wrapper
-nbd_do_establish_connection(BlockDriverState *bs, Error **errp);
-int coroutine_fn
-nbd_co_do_establish_connection(BlockDriverState *bs, Error **errp);
-
-
 #endif /* BLOCK_COROUTINES_INT_H */
diff --git a/block/nbd.c b/block/nbd.c
index 3cbee762de..616f9ae6c4 100644
--- a/block/nbd.c
+++ b/block/nbd.c
@@ -44,7 +44,6 @@
 #include "block/qdict.h"
 #include "block/nbd.h"
 #include "block/block_int.h"
-#include "block/coroutines.h"
 
 #include "qemu/yank.h"
 
@@ -67,8 +66,50 @@ typedef enum NBDClientState {
     NBD_CLIENT_QUIT
 } NBDClientState;
 
+typedef enum NBDConnectThreadState {
+    /* No thread, no pending results */
+    CONNECT_THREAD_NONE,
+
+    /* Thread is running, no results for now */
+    CONNECT_THREAD_RUNNING,
+
+    /*
+     * Thread is running, but requestor exited. Thread should close
+     * the new socket and free the connect state on exit.
+     */
+    CONNECT_THREAD_RUNNING_DETACHED,
+
+    /* Thread finished, results are stored in a state */
+    CONNECT_THREAD_FAIL,
+    CONNECT_THREAD_SUCCESS
+} NBDConnectThreadState;
+
+typedef struct NBDConnectThread {
+    /* Initialization constants */
+    SocketAddress *saddr; /* address to connect to */
+    /*
+     * Bottom half to schedule on completion. Scheduled only if bh_ctx is not
+     * NULL
+     */
+    QEMUBHFunc *bh_func;
+    void *bh_opaque;
+
+    /*
+     * Result of last attempt. Valid in FAIL and SUCCESS states.
+     * If you want to steal error, don't forget to set pointer to NULL.
+     */
+    QIOChannelSocket *sioc;
+    Error *err;
+
+    /* state and bh_ctx are protected by mutex */
+    QemuMutex mutex;
+    NBDConnectThreadState state; /* current state of the thread */
+    AioContext *bh_ctx; /* where to schedule bh (NULL means don't schedule) */
+} NBDConnectThread;
+
 typedef struct BDRVNBDState {
-    QIOChannel *ioc; /* The current I/O channel */
+    QIOChannelSocket *sioc; /* The master data channel */
+    QIOChannel *ioc; /* The current I/O channel which may differ (eg TLS) */
     NBDExportInfo info;
 
     CoMutex send_mutex;
@@ -80,6 +121,8 @@ typedef struct BDRVNBDState {
     bool wait_drained_end;
     int in_flight;
     NBDClientState state;
+    int connect_status;
+    Error *connect_err;
     bool wait_in_flight;
 
     QEMUTimer *reconnect_delay_timer;
@@ -97,20 +140,20 @@ typedef struct BDRVNBDState {
     char *x_dirty_bitmap;
     bool alloc_depth;
 
-    NBDClientConnection *conn;
+    bool wait_connect;
+    NBDConnectThread *connect_thread;
 } BDRVNBDState;
 
+static int nbd_establish_connection(BlockDriverState *bs, SocketAddress *saddr,
+                                    Error **errp);
+static int nbd_co_establish_connection(BlockDriverState *bs, Error **errp);
+static void nbd_co_establish_connection_cancel(BlockDriverState *bs,
+                                               bool detach);
+static int nbd_client_handshake(BlockDriverState *bs, Error **errp);
 static void nbd_yank(void *opaque);
 
-static void nbd_clear_bdrvstate(BlockDriverState *bs)
+static void nbd_clear_bdrvstate(BDRVNBDState *s)
 {
-    BDRVNBDState *s = (BDRVNBDState *)bs->opaque;
-
-    nbd_client_connection_release(s->conn);
-    s->conn = NULL;
-
-    yank_unregister_instance(BLOCKDEV_YANK_INSTANCE(bs->node_name));
-
     object_unref(OBJECT(s->tlscreds));
     qapi_free_SocketAddress(s->saddr);
     s->saddr = NULL;
@@ -122,20 +165,15 @@ static void nbd_clear_bdrvstate(BlockDriverState *bs)
     s->x_dirty_bitmap = NULL;
 }
 
-static bool nbd_client_connected(BDRVNBDState *s)
-{
-    return qatomic_load_acquire(&s->state) == NBD_CLIENT_CONNECTED;
-}
-
 static void nbd_channel_error(BDRVNBDState *s, int ret)
 {
     if (ret == -EIO) {
-        if (nbd_client_connected(s)) {
+        if (qatomic_load_acquire(&s->state) == NBD_CLIENT_CONNECTED) {
             s->state = s->reconnect_delay ? NBD_CLIENT_CONNECTING_WAIT :
                                             NBD_CLIENT_CONNECTING_NOWAIT;
         }
     } else {
-        if (nbd_client_connected(s)) {
+        if (qatomic_load_acquire(&s->state) == NBD_CLIENT_CONNECTED) {
             qio_channel_shutdown(s->ioc, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);
         }
         s->state = NBD_CLIENT_QUIT;
@@ -150,7 +188,6 @@ static void nbd_recv_coroutines_wake_all(BDRVNBDState *s)
         NBDClientRequest *req = &s->requests[i];
 
         if (req->coroutine && req->receiving) {
-            req->receiving = false;
             aio_co_wake(req->coroutine);
         }
     }
@@ -234,7 +271,7 @@ static void nbd_client_attach_aio_context(BlockDriverState *bs,
      * s->connection_co is either yielded from nbd_receive_reply or from
      * nbd_co_reconnect_loop()
      */
-    if (nbd_client_connected(s)) {
+    if (qatomic_load_acquire(&s->state) == NBD_CLIENT_CONNECTED) {
         qio_channel_attach_aio_context(QIO_CHANNEL(s->ioc), new_context);
     }
 
@@ -254,7 +291,7 @@ static void coroutine_fn nbd_client_co_drain_begin(BlockDriverState *bs)
     s->drained = true;
     qemu_co_sleep_wake(&s->reconnect_sleep);
 
-    nbd_co_establish_connection_cancel(s->conn);
+    nbd_co_establish_connection_cancel(bs, false);
 
     reconnect_delay_timer_del(s);
 
@@ -283,12 +320,16 @@ static void nbd_teardown_connection(BlockDriverState *bs)
     if (s->ioc) {
         /* finish any pending coroutines */
         qio_channel_shutdown(s->ioc, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);
+    } else if (s->sioc) {
+        /* abort negotiation */
+        qio_channel_shutdown(QIO_CHANNEL(s->sioc), QIO_CHANNEL_SHUTDOWN_BOTH,
+                             NULL);
     }
 
     s->state = NBD_CLIENT_QUIT;
     if (s->connection_co) {
         qemu_co_sleep_wake(&s->reconnect_sleep);
-        nbd_co_establish_connection_cancel(s->conn);
+        nbd_co_establish_connection_cancel(bs, true);
     }
     if (qemu_in_coroutine()) {
         s->teardown_co = qemu_coroutine_self();
@@ -313,95 +354,239 @@ static bool nbd_client_connecting_wait(BDRVNBDState *s)
     return qatomic_load_acquire(&s->state) == NBD_CLIENT_CONNECTING_WAIT;
 }
 
-/*
- * Update @bs with information learned during a completed negotiation process.
- * Return failure if the server's advertised options are incompatible with the
- * client's needs.
- */
-static int nbd_handle_updated_info(BlockDriverState *bs, Error **errp)
+static void connect_bh(void *opaque)
 {
-    BDRVNBDState *s = (BDRVNBDState *)bs->opaque;
-    int ret;
+    BDRVNBDState *state = opaque;
 
-    if (s->x_dirty_bitmap) {
-        if (!s->info.base_allocation) {
-            error_setg(errp, "requested x-dirty-bitmap %s not found",
-                       s->x_dirty_bitmap);
-            return -EINVAL;
-        }
-        if (strcmp(s->x_dirty_bitmap, "qemu:allocation-depth") == 0) {
-            s->alloc_depth = true;
-        }
-    }
+    assert(state->wait_connect);
+    state->wait_connect = false;
+    aio_co_wake(state->connection_co);
+}
 
-    if (s->info.flags & NBD_FLAG_READ_ONLY) {
-        ret = bdrv_apply_auto_read_only(bs, "NBD export is read-only", errp);
-        if (ret < 0) {
-            return ret;
-        }
+static void nbd_init_connect_thread(BDRVNBDState *s)
+{
+    s->connect_thread = g_new(NBDConnectThread, 1);
+
+    *s->connect_thread = (NBDConnectThread) {
+        .saddr = QAPI_CLONE(SocketAddress, s->saddr),
+        .state = CONNECT_THREAD_NONE,
+        .bh_func = connect_bh,
+        .bh_opaque = s,
+    };
+
+    qemu_mutex_init(&s->connect_thread->mutex);
+}
+
+static void nbd_free_connect_thread(NBDConnectThread *thr)
+{
+    if (thr->sioc) {
+        qio_channel_close(QIO_CHANNEL(thr->sioc), NULL);
     }
+    error_free(thr->err);
+    qapi_free_SocketAddress(thr->saddr);
+    g_free(thr);
+}
 
-    if (s->info.flags & NBD_FLAG_SEND_FUA) {
-        bs->supported_write_flags = BDRV_REQ_FUA;
-        bs->supported_zero_flags |= BDRV_REQ_FUA;
+static void *connect_thread_func(void *opaque)
+{
+    NBDConnectThread *thr = opaque;
+    int ret;
+    bool do_free = false;
+
+    thr->sioc = qio_channel_socket_new();
+
+    error_free(thr->err);
+    thr->err = NULL;
+    ret = qio_channel_socket_connect_sync(thr->sioc, thr->saddr, &thr->err);
+    if (ret < 0) {
+        object_unref(OBJECT(thr->sioc));
+        thr->sioc = NULL;
     }
 
-    if (s->info.flags & NBD_FLAG_SEND_WRITE_ZEROES) {
-        bs->supported_zero_flags |= BDRV_REQ_MAY_UNMAP;
-        if (s->info.flags & NBD_FLAG_SEND_FAST_ZERO) {
-            bs->supported_zero_flags |= BDRV_REQ_NO_FALLBACK;
+    qemu_mutex_lock(&thr->mutex);
+
+    switch (thr->state) {
+    case CONNECT_THREAD_RUNNING:
+        thr->state = ret < 0 ? CONNECT_THREAD_FAIL : CONNECT_THREAD_SUCCESS;
+        if (thr->bh_ctx) {
+            aio_bh_schedule_oneshot(thr->bh_ctx, thr->bh_func, thr->bh_opaque);
+
+            /* play safe, don't reuse bh_ctx on further connection attempts */
+            thr->bh_ctx = NULL;
         }
+        break;
+    case CONNECT_THREAD_RUNNING_DETACHED:
+        do_free = true;
+        break;
+    default:
+        abort();
     }
 
-    trace_nbd_client_handshake_success(s->export);
+    qemu_mutex_unlock(&thr->mutex);
 
-    return 0;
+    if (do_free) {
+        nbd_free_connect_thread(thr);
+    }
+
+    return NULL;
 }
 
-int coroutine_fn nbd_co_do_establish_connection(BlockDriverState *bs,
-                                                Error **errp)
+static int coroutine_fn
+nbd_co_establish_connection(BlockDriverState *bs, Error **errp)
 {
-    BDRVNBDState *s = (BDRVNBDState *)bs->opaque;
     int ret;
+    QemuThread thread;
+    BDRVNBDState *s = bs->opaque;
+    NBDConnectThread *thr = s->connect_thread;
+
+    if (!thr) {
+        /* detached */
+        return -1;
+    }
+
+    qemu_mutex_lock(&thr->mutex);
+
+    switch (thr->state) {
+    case CONNECT_THREAD_FAIL:
+    case CONNECT_THREAD_NONE:
+        error_free(thr->err);
+        thr->err = NULL;
+        thr->state = CONNECT_THREAD_RUNNING;
+        qemu_thread_create(&thread, "nbd-connect",
+                           connect_thread_func, thr, QEMU_THREAD_DETACHED);
+        break;
+    case CONNECT_THREAD_SUCCESS:
+        /* Previous attempt finally succeeded in background */
+        thr->state = CONNECT_THREAD_NONE;
+        s->sioc = thr->sioc;
+        thr->sioc = NULL;
+        yank_register_function(BLOCKDEV_YANK_INSTANCE(bs->node_name),
+                               nbd_yank, bs);
+        qemu_mutex_unlock(&thr->mutex);
+        return 0;
+    case CONNECT_THREAD_RUNNING:
+        /* Already running, will wait */
+        break;
+    default:
+        abort();
+    }
 
-    assert(!s->ioc);
+    thr->bh_ctx = qemu_get_current_aio_context();
 
-    s->ioc = nbd_co_establish_connection(s->conn, &s->info, true, errp);
-    if (!s->ioc) {
-        return -ECONNREFUSED;
-    }
+    qemu_mutex_unlock(&thr->mutex);
 
-    ret = nbd_handle_updated_info(s->bs, NULL);
-    if (ret < 0) {
+
+    /*
+     * We are going to wait for connect-thread finish, but
+     * nbd_client_co_drain_begin() can interrupt.
+     *
+     * Note that wait_connect variable is not visible for connect-thread. It
+     * doesn't need mutex protection, it used only inside home aio context of
+     * bs.
+     */
+    s->wait_connect = true;
+    qemu_coroutine_yield();
+
+    if (!s->connect_thread) {
+        /* detached */
+        return -1;
+    }
+    assert(thr == s->connect_thread);
+
+    qemu_mutex_lock(&thr->mutex);
+
+    switch (thr->state) {
+    case CONNECT_THREAD_SUCCESS:
+    case CONNECT_THREAD_FAIL:
+        thr->state = CONNECT_THREAD_NONE;
+        error_propagate(errp, thr->err);
+        thr->err = NULL;
+        s->sioc = thr->sioc;
+        thr->sioc = NULL;
+        if (s->sioc) {
+            yank_register_function(BLOCKDEV_YANK_INSTANCE(bs->node_name),
+                                   nbd_yank, bs);
+        }
+        ret = (s->sioc ? 0 : -1);
+        break;
+    case CONNECT_THREAD_RUNNING:
+    case CONNECT_THREAD_RUNNING_DETACHED:
         /*
-         * We have connected, but must fail for other reasons.
-         * Send NBD_CMD_DISC as a courtesy to the server.
+         * Obviously, drained section wants to start. Report the attempt as
+         * failed. Still connect thread is executing in background, and its
+         * result may be used for next connection attempt.
          */
-        NBDRequest request = { .type = NBD_CMD_DISC };
+        ret = -1;
+        error_setg(errp, "Connection attempt cancelled by other operation");
+        break;
 
-        nbd_send_request(s->ioc, &request);
-
-        object_unref(OBJECT(s->ioc));
-        s->ioc = NULL;
+    case CONNECT_THREAD_NONE:
+        /*
+         * Impossible. We've seen this thread running. So it should be
+         * running or at least give some results.
+         */
+        abort();
 
-        return ret;
+    default:
+        abort();
     }
 
-    qio_channel_set_blocking(s->ioc, false, NULL);
-    qio_channel_attach_aio_context(s->ioc, bdrv_get_aio_context(bs));
+    qemu_mutex_unlock(&thr->mutex);
 
-    yank_register_function(BLOCKDEV_YANK_INSTANCE(s->bs->node_name), nbd_yank,
-                           bs);
+    return ret;
+}
 
-    /* successfully connected */
-    s->state = NBD_CLIENT_CONNECTED;
-    qemu_co_queue_restart_all(&s->free_sema);
+/*
+ * nbd_co_establish_connection_cancel
+ * Cancel nbd_co_establish_connection asynchronously: it will finish soon, to
+ * allow drained section to begin.
+ *
+ * If detach is true, also cleanup the state (or if thread is running, move it
+ * to CONNECT_THREAD_RUNNING_DETACHED state). s->connect_thread becomes NULL if
+ * detach is true.
+ */
+static void nbd_co_establish_connection_cancel(BlockDriverState *bs,
+                                               bool detach)
+{
+    BDRVNBDState *s = bs->opaque;
+    NBDConnectThread *thr = s->connect_thread;
+    bool wake = false;
+    bool do_free = false;
+
+    qemu_mutex_lock(&thr->mutex);
+
+    if (thr->state == CONNECT_THREAD_RUNNING) {
+        /* We can cancel only in running state, when bh is not yet scheduled */
+        thr->bh_ctx = NULL;
+        if (s->wait_connect) {
+            s->wait_connect = false;
+            wake = true;
+        }
+        if (detach) {
+            thr->state = CONNECT_THREAD_RUNNING_DETACHED;
+            s->connect_thread = NULL;
+        }
+    } else if (detach) {
+        do_free = true;
+    }
 
-    return 0;
+    qemu_mutex_unlock(&thr->mutex);
+
+    if (do_free) {
+        nbd_free_connect_thread(thr);
+        s->connect_thread = NULL;
+    }
+
+    if (wake) {
+        aio_co_wake(s->connection_co);
+    }
 }
 
 static coroutine_fn void nbd_reconnect_attempt(BDRVNBDState *s)
 {
+    int ret;
+    Error *local_err = NULL;
+
     if (!nbd_client_connecting(s)) {
         return;
     }
@@ -435,11 +620,44 @@ static coroutine_fn void nbd_reconnect_attempt(BDRVNBDState *s)
         qio_channel_detach_aio_context(QIO_CHANNEL(s->ioc));
         yank_unregister_function(BLOCKDEV_YANK_INSTANCE(s->bs->node_name),
                                  nbd_yank, s->bs);
+        object_unref(OBJECT(s->sioc));
+        s->sioc = NULL;
         object_unref(OBJECT(s->ioc));
         s->ioc = NULL;
     }
 
-    nbd_co_do_establish_connection(s->bs, NULL);
+    if (nbd_co_establish_connection(s->bs, &local_err) < 0) {
+        ret = -ECONNREFUSED;
+        goto out;
+    }
+
+    bdrv_dec_in_flight(s->bs);
+
+    ret = nbd_client_handshake(s->bs, &local_err);
+
+    if (s->drained) {
+        s->wait_drained_end = true;
+        while (s->drained) {
+            /*
+             * We may be entered once from nbd_client_attach_aio_context_bh
+             * and then from nbd_client_co_drain_end. So here is a loop.
+             */
+            qemu_coroutine_yield();
+        }
+    }
+    bdrv_inc_in_flight(s->bs);
+
+out:
+    s->connect_status = ret;
+    error_free(s->connect_err);
+    s->connect_err = NULL;
+    error_propagate(&s->connect_err, local_err);
+
+    if (ret >= 0) {
+        /* successfully connected */
+        s->state = NBD_CLIENT_CONNECTED;
+        qemu_co_queue_restart_all(&s->free_sema);
+    }
 }
 
 static coroutine_fn void nbd_co_reconnect_loop(BDRVNBDState *s)
@@ -505,7 +723,7 @@ static coroutine_fn void nbd_connection_entry(void *opaque)
             nbd_co_reconnect_loop(s);
         }
 
-        if (!nbd_client_connected(s)) {
+        if (qatomic_load_acquire(&s->state) != NBD_CLIENT_CONNECTED) {
             continue;
         }
 
@@ -549,7 +767,6 @@ static coroutine_fn void nbd_connection_entry(void *opaque)
          *   connection_co happens through a bottom half, which can only
          *   run after we yield.
          */
-        s->requests[i].receiving = false;
         aio_co_wake(s->requests[i].coroutine);
         qemu_coroutine_yield();
     }
@@ -563,6 +780,8 @@ static coroutine_fn void nbd_connection_entry(void *opaque)
         qio_channel_detach_aio_context(QIO_CHANNEL(s->ioc));
         yank_unregister_function(BLOCKDEV_YANK_INSTANCE(s->bs->node_name),
                                  nbd_yank, s->bs);
+        object_unref(OBJECT(s->sioc));
+        s->sioc = NULL;
         object_unref(OBJECT(s->ioc));
         s->ioc = NULL;
     }
@@ -585,7 +804,7 @@ static int nbd_co_send_request(BlockDriverState *bs,
         qemu_co_queue_wait(&s->free_sema, &s->send_mutex);
     }
 
-    if (!nbd_client_connected(s)) {
+    if (qatomic_load_acquire(&s->state) != NBD_CLIENT_CONNECTED) {
         rc = -EIO;
         goto err;
     }
@@ -612,7 +831,8 @@ static int nbd_co_send_request(BlockDriverState *bs,
     if (qiov) {
         qio_channel_set_cork(s->ioc, true);
         rc = nbd_send_request(s->ioc, request);
-        if (nbd_client_connected(s) && rc >= 0) {
+        if (qatomic_load_acquire(&s->state) == NBD_CLIENT_CONNECTED &&
+            rc >= 0) {
             if (qio_channel_writev_all(s->ioc, qiov->iov, qiov->niov,
                                        NULL) < 0) {
                 rc = -EIO;
@@ -936,8 +1156,8 @@ static coroutine_fn int nbd_co_do_receive_one_chunk(
     /* Wait until we're woken up by nbd_connection_entry.  */
     s->requests[i].receiving = true;
     qemu_coroutine_yield();
-    assert(!s->requests[i].receiving);
-    if (!nbd_client_connected(s)) {
+    s->requests[i].receiving = false;
+    if (qatomic_load_acquire(&s->state) != NBD_CLIENT_CONNECTED) {
         error_setg(errp, "Connection closed");
         return -EIO;
     }
@@ -1096,7 +1316,7 @@ static bool nbd_reply_chunk_iter_receive(BDRVNBDState *s,
     NBDReply local_reply;
     NBDStructuredReplyChunk *chunk;
     Error *local_err = NULL;
-    if (!nbd_client_connected(s)) {
+    if (qatomic_load_acquire(&s->state) != NBD_CLIENT_CONNECTED) {
         error_setg(&local_err, "Connection closed");
         nbd_iter_channel_error(iter, -EIO, &local_err);
         goto break_loop;
@@ -1121,7 +1341,8 @@ static bool nbd_reply_chunk_iter_receive(BDRVNBDState *s,
     }
 
     /* Do not execute the body of NBD_FOREACH_REPLY_CHUNK for simple reply. */
-    if (nbd_reply_is_simple(reply) || !nbd_client_connected(s)) {
+    if (nbd_reply_is_simple(reply) ||
+        qatomic_load_acquire(&s->state) != NBD_CLIENT_CONNECTED) {
         goto break_loop;
     }
 
@@ -1559,7 +1780,7 @@ static void nbd_yank(void *opaque)
     BDRVNBDState *s = (BDRVNBDState *)bs->opaque;
 
     qatomic_store_release(&s->state, NBD_CLIENT_QUIT);
-    qio_channel_shutdown(QIO_CHANNEL(s->ioc), QIO_CHANNEL_SHUTDOWN_BOTH, NULL);
+    qio_channel_shutdown(QIO_CHANNEL(s->sioc), QIO_CHANNEL_SHUTDOWN_BOTH, NULL);
 }
 
 static void nbd_client_close(BlockDriverState *bs)
@@ -1574,6 +1795,111 @@ static void nbd_client_close(BlockDriverState *bs)
     nbd_teardown_connection(bs);
 }
 
+static int nbd_establish_connection(BlockDriverState *bs,
+                                    SocketAddress *saddr,
+                                    Error **errp)
+{
+    ERRP_GUARD();
+    BDRVNBDState *s = (BDRVNBDState *)bs->opaque;
+
+    s->sioc = qio_channel_socket_new();
+    qio_channel_set_name(QIO_CHANNEL(s->sioc), "nbd-client");
+
+    qio_channel_socket_connect_sync(s->sioc, saddr, errp);
+    if (*errp) {
+        object_unref(OBJECT(s->sioc));
+        s->sioc = NULL;
+        return -1;
+    }
+
+    yank_register_function(BLOCKDEV_YANK_INSTANCE(bs->node_name), nbd_yank, bs);
+    qio_channel_set_delay(QIO_CHANNEL(s->sioc), false);
+
+    return 0;
+}
+
+/* nbd_client_handshake takes ownership on s->sioc. On failure it's unref'ed. */
+static int nbd_client_handshake(BlockDriverState *bs, Error **errp)
+{
+    BDRVNBDState *s = (BDRVNBDState *)bs->opaque;
+    AioContext *aio_context = bdrv_get_aio_context(bs);
+    int ret;
+
+    trace_nbd_client_handshake(s->export);
+    qio_channel_set_blocking(QIO_CHANNEL(s->sioc), false, NULL);
+    qio_channel_attach_aio_context(QIO_CHANNEL(s->sioc), aio_context);
+
+    s->info.request_sizes = true;
+    s->info.structured_reply = true;
+    s->info.base_allocation = true;
+    s->info.x_dirty_bitmap = g_strdup(s->x_dirty_bitmap);
+    s->info.name = g_strdup(s->export ?: "");
+    ret = nbd_receive_negotiate(aio_context, QIO_CHANNEL(s->sioc), s->tlscreds,
+                                s->hostname, &s->ioc, &s->info, errp);
+    g_free(s->info.x_dirty_bitmap);
+    g_free(s->info.name);
+    if (ret < 0) {
+        yank_unregister_function(BLOCKDEV_YANK_INSTANCE(bs->node_name),
+                                 nbd_yank, bs);
+        object_unref(OBJECT(s->sioc));
+        s->sioc = NULL;
+        return ret;
+    }
+    if (s->x_dirty_bitmap) {
+        if (!s->info.base_allocation) {
+            error_setg(errp, "requested x-dirty-bitmap %s not found",
+                       s->x_dirty_bitmap);
+            ret = -EINVAL;
+            goto fail;
+        }
+        if (strcmp(s->x_dirty_bitmap, "qemu:allocation-depth") == 0) {
+            s->alloc_depth = true;
+        }
+    }
+    if (s->info.flags & NBD_FLAG_READ_ONLY) {
+        ret = bdrv_apply_auto_read_only(bs, "NBD export is read-only", errp);
+        if (ret < 0) {
+            goto fail;
+        }
+    }
+    if (s->info.flags & NBD_FLAG_SEND_FUA) {
+        bs->supported_write_flags = BDRV_REQ_FUA;
+        bs->supported_zero_flags |= BDRV_REQ_FUA;
+    }
+    if (s->info.flags & NBD_FLAG_SEND_WRITE_ZEROES) {
+        bs->supported_zero_flags |= BDRV_REQ_MAY_UNMAP;
+        if (s->info.flags & NBD_FLAG_SEND_FAST_ZERO) {
+            bs->supported_zero_flags |= BDRV_REQ_NO_FALLBACK;
+        }
+    }
+
+    if (!s->ioc) {
+        s->ioc = QIO_CHANNEL(s->sioc);
+        object_ref(OBJECT(s->ioc));
+    }
+
+    trace_nbd_client_handshake_success(s->export);
+
+    return 0;
+
+ fail:
+    /*
+     * We have connected, but must fail for other reasons.
+     * Send NBD_CMD_DISC as a courtesy to the server.
+     */
+    {
+        NBDRequest request = { .type = NBD_CMD_DISC };
+
+        nbd_send_request(s->ioc ?: QIO_CHANNEL(s->sioc), &request);
+
+        yank_unregister_function(BLOCKDEV_YANK_INSTANCE(bs->node_name),
+                                 nbd_yank, bs);
+        object_unref(OBJECT(s->sioc));
+        s->sioc = NULL;
+
+        return ret;
+    }
+}
 
 /*
  * Parse nbd_open options
@@ -1807,12 +2133,6 @@ static SocketAddress *nbd_config(BDRVNBDState *s, QDict *options,
         goto done;
     }
 
-    if (socket_address_parse_named_fd(saddr, errp) < 0) {
-        qapi_free_SocketAddress(saddr);
-        saddr = NULL;
-        goto done;
-    }
-
 done:
     qobject_unref(addr);
     visit_free(iv);
@@ -1954,6 +2274,9 @@ static int nbd_process_options(BlockDriverState *bs, QDict *options,
     ret = 0;
 
  error:
+    if (ret < 0) {
+        nbd_clear_bdrvstate(s);
+    }
     qemu_opts_del(opts);
     return ret;
 }
@@ -1964,6 +2287,11 @@ static int nbd_open(BlockDriverState *bs, QDict *options, int flags,
     int ret;
     BDRVNBDState *s = (BDRVNBDState *)bs->opaque;
 
+    ret = nbd_process_options(bs, options, errp);
+    if (ret < 0) {
+        return ret;
+    }
+
     s->bs = bs;
     qemu_co_mutex_init(&s->send_mutex);
     qemu_co_queue_init(&s->free_sema);
@@ -1972,29 +2300,31 @@ static int nbd_open(BlockDriverState *bs, QDict *options, int flags,
         return -EEXIST;
     }
 
-    ret = nbd_process_options(bs, options, errp);
-    if (ret < 0) {
-        goto fail;
+    /*
+     * establish TCP connection, return error if it fails
+     * TODO: Configurable retry-until-timeout behaviour.
+     */
+    if (nbd_establish_connection(bs, s->saddr, errp) < 0) {
+        yank_unregister_instance(BLOCKDEV_YANK_INSTANCE(bs->node_name));
+        return -ECONNREFUSED;
     }
 
-    s->conn = nbd_client_connection_new(s->saddr, true, s->export,
-                                        s->x_dirty_bitmap, s->tlscreds);
-
-    /* TODO: Configurable retry-until-timeout behaviour. */
-    ret = nbd_do_establish_connection(bs, errp);
+    ret = nbd_client_handshake(bs, errp);
     if (ret < 0) {
-        goto fail;
+        yank_unregister_instance(BLOCKDEV_YANK_INSTANCE(bs->node_name));
+        nbd_clear_bdrvstate(s);
+        return ret;
     }
+    /* successfully connected */
+    s->state = NBD_CLIENT_CONNECTED;
+
+    nbd_init_connect_thread(s);
 
     s->connection_co = qemu_coroutine_create(nbd_connection_entry, s);
     bdrv_inc_in_flight(bs);
     aio_co_schedule(bdrv_get_aio_context(bs), s->connection_co);
 
     return 0;
-
-fail:
-    nbd_clear_bdrvstate(bs);
-    return ret;
 }
 
 static int nbd_co_flush(BlockDriverState *bs)
@@ -2038,8 +2368,11 @@ static void nbd_refresh_limits(BlockDriverState *bs, Error **errp)
 
 static void nbd_close(BlockDriverState *bs)
 {
+    BDRVNBDState *s = bs->opaque;
+
     nbd_client_close(bs);
-    nbd_clear_bdrvstate(bs);
+    yank_unregister_instance(BLOCKDEV_YANK_INSTANCE(bs->node_name));
+    nbd_clear_bdrvstate(s);
 }
 
 /*
diff --git a/docs/amd-memory-encryption.txt b/docs/amd-memory-encryption.txt
index ffca382b5f..145896aec7 100644
--- a/docs/amd-memory-encryption.txt
+++ b/docs/amd-memory-encryption.txt
@@ -1,48 +1,38 @@
 Secure Encrypted Virtualization (SEV) is a feature found on AMD processors.
 
 SEV is an extension to the AMD-V architecture which supports running encrypted
-virtual machines (VMs) under the control of KVM. Encrypted VMs have their pages
+virtual machine (VMs) under the control of KVM. Encrypted VMs have their pages
 (code and data) secured such that only the guest itself has access to the
 unencrypted version. Each encrypted VM is associated with a unique encryption
-key; if its data is accessed by a different entity using a different key the
+key; if its data is accessed to a different entity using a different key the
 encrypted guests data will be incorrectly decrypted, leading to unintelligible
 data.
 
-Key management for this feature is handled by a separate processor known as the
-AMD secure processor (AMD-SP), which is present in AMD SOCs. Firmware running
-inside the AMD-SP provides commands to support a common VM lifecycle. This
+The key management of this feature is handled by separate processor known as
+AMD secure processor (AMD-SP) which is present in AMD SOCs. Firmware running
+inside the AMD-SP provide commands to support common VM lifecycle. This
 includes commands for launching, snapshotting, migrating and debugging the
-encrypted guest. These SEV commands can be issued via KVM_MEMORY_ENCRYPT_OP
+encrypted guest. Those SEV command can be issued via KVM_MEMORY_ENCRYPT_OP
 ioctls.
 
-Secure Encrypted Virtualization - Encrypted State (SEV-ES) builds on the SEV
-support to additionally protect the guest register state. In order to allow a
-hypervisor to perform functions on behalf of a guest, there is architectural
-support for notifying a guest's operating system when certain types of VMEXITs
-are about to occur. This allows the guest to selectively share information with
-the hypervisor to satisfy the requested function.
-
 Launching
 ---------
-Boot images (such as bios) must be encrypted before a guest can be booted. The
-MEMORY_ENCRYPT_OP ioctl provides commands to encrypt the images: LAUNCH_START,
+Boot images (such as bios) must be encrypted before guest can be booted.
+MEMORY_ENCRYPT_OP ioctl provides commands to encrypt the images :LAUNCH_START,
 LAUNCH_UPDATE_DATA, LAUNCH_MEASURE and LAUNCH_FINISH. These four commands
 together generate a fresh memory encryption key for the VM, encrypt the boot
-images and provide a measurement than can be used as an attestation of a
+images and provide a measurement than can be used as an attestation of the
 successful launch.
 
-For a SEV-ES guest, the LAUNCH_UPDATE_VMSA command is also used to encrypt the
-guest register state, or VM save area (VMSA), for all of the guest vCPUs.
-
 LAUNCH_START is called first to create a cryptographic launch context within
-the firmware. To create this context, guest owner must provide a guest policy,
+the firmware. To create this context, guest owner must provides guest policy,
 its public Diffie-Hellman key (PDH) and session parameters. These inputs
-should be treated as a binary blob and must be passed as-is to the SEV firmware.
+should be treated as binary blob and must be passed as-is to the SEV firmware.
 
-The guest policy is passed as plaintext. A hypervisor may choose to read it,
+The guest policy is passed as plaintext and hypervisor may able to read it
 but should not modify it (any modification of the policy bits will result
 in bad measurement). The guest policy is a 4-byte data structure containing
-several flags that restricts what can be done on a running SEV guest.
+several flags that restricts what can be done on running SEV guest.
 See KM Spec section 3 and 6.2 for more details.
 
 The guest policy can be provided via the 'policy' property (see below)
@@ -50,42 +40,31 @@ The guest policy can be provided via the 'policy' property (see below)
 # ${QEMU} \
    sev-guest,id=sev0,policy=0x1...\
 
-Setting the "SEV-ES required" policy bit (bit 2) will launch the guest as a
-SEV-ES guest (see below)
-
-# ${QEMU} \
-   sev-guest,id=sev0,policy=0x5...\
-
-The guest owner provided DH certificate and session parameters will be used to
+Guest owners provided DH certificate and session parameters will be used to
 establish a cryptographic session with the guest owner to negotiate keys used
 for the attestation.
 
-The DH certificate and session blob can be provided via the 'dh-cert-file' and
-'session-file' properties (see below)
+The DH certificate and session blob can be provided via 'dh-cert-file' and
+'session-file' property (see below
 
 # ${QEMU} \
      sev-guest,id=sev0,dh-cert-file=<file1>,session-file=<file2>
 
 LAUNCH_UPDATE_DATA encrypts the memory region using the cryptographic context
-created via the LAUNCH_START command. If required, this command can be called
+created via LAUNCH_START command. If required, this command can be called
 multiple times to encrypt different memory regions. The command also calculates
 the measurement of the memory contents as it encrypts.
 
-LAUNCH_UPDATE_VMSA encrypts all the vCPU VMSAs for a SEV-ES guest using the
-cryptographic context created via the LAUNCH_START command. The command also
-calculates the measurement of the VMSAs as it encrypts them.
-
-LAUNCH_MEASURE can be used to retrieve the measurement of encrypted memory and,
-for a SEV-ES guest, encrypted VMSAs. This measurement is a signature of the
-memory contents and, for a SEV-ES guest, the VMSA contents, that can be sent
-to the guest owner as an attestation that the memory and VMSAs were encrypted
+LAUNCH_MEASURE command can be used to retrieve the measurement of encrypted
+memory. This measurement is a signature of the memory contents that can be
+sent to the guest owner as an attestation that the memory was encrypted
 correctly by the firmware. The guest owner may wait to provide the guest
 confidential information until it can verify the attestation measurement.
 Since the guest owner knows the initial contents of the guest at boot, the
 attestation measurement can be verified by comparing it to what the guest owner
 expects.
 
-LAUNCH_FINISH finalizes the guest launch and destroys the cryptographic
+LAUNCH_FINISH command finalizes the guest launch and destroy's the cryptographic
 context.
 
 See SEV KM API Spec [1] 'Launching a guest' usage flow (Appendix A) for the
@@ -97,28 +76,12 @@ To launch a SEV guest
     -machine ...,confidential-guest-support=sev0 \
     -object sev-guest,id=sev0,cbitpos=47,reduced-phys-bits=1
 
-To launch a SEV-ES guest
-
-# ${QEMU} \
-    -machine ...,confidential-guest-support=sev0 \
-    -object sev-guest,id=sev0,cbitpos=47,reduced-phys-bits=1,policy=0x5
-
-An SEV-ES guest has some restrictions as compared to a SEV guest. Because the
-guest register state is encrypted and cannot be updated by the VMM/hypervisor,
-a SEV-ES guest:
- - Does not support SMM - SMM support requires updating the guest register
-   state.
- - Does not support reboot - a system reset requires updating the guest register
-   state.
- - Requires in-kernel irqchip - the burden is placed on the hypervisor to
-   manage booting APs.
-
 Debugging
 -----------
-Since the memory contents of a SEV guest are encrypted, hypervisor access to
-the guest memory will return cipher text. If the guest policy allows debugging,
-then a hypervisor can use the DEBUG_DECRYPT and DEBUG_ENCRYPT commands to access
-the guest memory region for debug purposes.  This is not supported in QEMU yet.
+Since memory contents of SEV guest is encrypted hence hypervisor access to the
+guest memory will get a cipher text. If guest policy allows debugging, then
+hypervisor can use DEBUG_DECRYPT and DEBUG_ENCRYPT commands access the guest
+memory region for debug purposes.  This is not supported in QEMU yet.
 
 Snapshot/Restore
 -----------------
@@ -139,10 +102,8 @@ Secure Encrypted Virtualization Key Management:
 
 KVM Forum slides:
 http://www.linux-kvm.org/images/7/74/02x08A-Thomas_Lendacky-AMDs_Virtualizatoin_Memory_Encryption_Technology.pdf
-https://www.linux-kvm.org/images/9/94/Extending-Secure-Encrypted-Virtualization-with-SEV-ES-Thomas-Lendacky-AMD.pdf
 
 AMD64 Architecture Programmer's Manual:
    http://support.amd.com/TechDocs/24593.pdf
    SME is section 7.10
    SEV is section 15.34
-   SEV-ES is section 15.35
diff --git a/docs/interop/firmware.json b/docs/interop/firmware.json
index 8d8b0be030..9d94ccafa9 100644
--- a/docs/interop/firmware.json
+++ b/docs/interop/firmware.json
@@ -115,12 +115,6 @@
 #           this feature are documented in
 #           "docs/amd-memory-encryption.txt".
 #
-# @amd-sev-es: The firmware supports running under AMD Secure Encrypted
-#              Virtualization - Encrypted State, as specified in the AMD64
-#              Architecture Programmer's Manual. QEMU command line options
-#              related to this feature are documented in
-#              "docs/amd-memory-encryption.txt".
-#
 # @enrolled-keys: The variable store (NVRAM) template associated with
 #                 the firmware binary has the UEFI Secure Boot
 #                 operational mode turned on, with certificates
@@ -185,7 +179,7 @@
 # Since: 3.0
 ##
 { 'enum' : 'FirmwareFeature',
-  'data' : [ 'acpi-s3', 'acpi-s4', 'amd-sev', 'amd-sev-es', 'enrolled-keys',
+  'data' : [ 'acpi-s3', 'acpi-s4', 'amd-sev', 'enrolled-keys',
              'requires-smm', 'secure-boot', 'verbose-dynamic',
              'verbose-static' ] }
 
@@ -510,45 +504,6 @@
 # }
 #
 # {
-#     "description": "OVMF with SEV-ES support",
-#     "interface-types": [
-#         "uefi"
-#     ],
-#     "mapping": {
-#         "device": "flash",
-#         "executable": {
-#             "filename": "/usr/share/OVMF/OVMF_CODE.fd",
-#             "format": "raw"
-#         },
-#         "nvram-template": {
-#             "filename": "/usr/share/OVMF/OVMF_VARS.fd",
-#             "format": "raw"
-#         }
-#     },
-#     "targets": [
-#         {
-#             "architecture": "x86_64",
-#             "machines": [
-#                 "pc-q35-*"
-#             ]
-#         }
-#     ],
-#     "features": [
-#         "acpi-s3",
-#         "amd-sev",
-#         "amd-sev-es",
-#         "verbose-dynamic"
-#     ],
-#     "tags": [
-#         "-a X64",
-#         "-p OvmfPkg/OvmfPkgX64.dsc",
-#         "-t GCC48",
-#         "-b DEBUG",
-#         "-D FD_SIZE_4MB"
-#     ]
-# }
-#
-# {
 #     "description": "UEFI firmware for ARM64 virtual machines",
 #     "interface-types": [
 #         "uefi"
diff --git a/docs/interop/live-block-operations.rst b/docs/interop/live-block-operations.rst
index 1073b930dc..477d085f54 100644
--- a/docs/interop/live-block-operations.rst
+++ b/docs/interop/live-block-operations.rst
@@ -127,13 +127,15 @@ Interacting with a QEMU instance
 
 To show some example invocations of command-line, we will use the
 following invocation of QEMU, with a QMP server running over UNIX
-socket::
+socket:
 
-    $ ./qemu-system-x86_64 -display none -no-user-config \
-        -M q35 -nodefaults -m 512 \
-        -blockdev node-name=node-A,driver=qcow2,file.driver=file,file.node-name=file,file.filename=./a.qcow2 \
-        -device virtio-blk,drive=node-A,id=virtio0 \
-        -monitor stdio -qmp unix:/tmp/qmp-sock,server=on,wait=off
+.. parsed-literal::
+
+  $ |qemu_system| -display none -no-user-config -nodefaults \\
+    -m 512 -blockdev \\
+    node-name=node-A,driver=qcow2,file.driver=file,file.node-name=file,file.filename=./a.qcow2 \\
+    -device virtio-blk,drive=node-A,id=virtio0 \\
+    -monitor stdio -qmp unix:/tmp/qmp-sock,server=on,wait=off
 
 The ``-blockdev`` command-line option, used above, is available from
 QEMU 2.9 onwards.  In the above invocation, notice the ``node-name``
@@ -692,14 +694,16 @@ And start the destination QEMU (we already have the source QEMU running
 -- discussed in the section: `Interacting with a QEMU instance`_)
 instance, with the following invocation.  (As noted earlier, for
 simplicity's sake, the destination QEMU is started on the same host, but
-it could be located elsewhere)::
-
-    $ ./qemu-system-x86_64 -display none -no-user-config \
-        -M q35 -nodefaults -m 512 \
-        -blockdev node-name=node-TargetDisk,driver=qcow2,file.driver=file,file.node-name=file,file.filename=./target-disk.qcow2 \
-        -device virtio-blk,drive=node-TargetDisk,id=virtio0 \
-        -S -monitor stdio -qmp unix:./qmp-sock2,server=on,wait=off \
-        -incoming tcp:localhost:6666
+it could be located elsewhere):
+
+.. parsed-literal::
+
+  $ |qemu_system| -display none -no-user-config -nodefaults \\
+    -m 512 -blockdev \\
+    node-name=node-TargetDisk,driver=qcow2,file.driver=file,file.node-name=file,file.filename=./target-disk.qcow2 \\
+    -device virtio-blk,drive=node-TargetDisk,id=virtio0 \\
+    -S -monitor stdio -qmp unix:./qmp-sock2,server=on,wait=off \\
+    -incoming tcp:localhost:6666
 
 Given the disk image chain on source QEMU::
 
diff --git a/docs/system/cpu-models-x86-abi.csv b/docs/system/cpu-models-x86-abi.csv
deleted file mode 100644
index f3f3b60be1..0000000000
--- a/docs/system/cpu-models-x86-abi.csv
+++ /dev/null
@@ -1,67 +0,0 @@
-Model,baseline,v2,v3,v4
-486-v1,,,,
-Broadwell-v1,✅,✅,✅,
-Broadwell-v2,✅,✅,✅,
-Broadwell-v3,✅,✅,✅,
-Broadwell-v4,✅,✅,✅,
-Cascadelake-Server-v1,✅,✅,✅,✅
-Cascadelake-Server-v2,✅,✅,✅,✅
-Cascadelake-Server-v3,✅,✅,✅,✅
-Cascadelake-Server-v4,✅,✅,✅,✅
-Conroe-v1,✅,,,
-Cooperlake-v1,✅,✅,✅,✅
-Denverton-v1,✅,✅,,
-Denverton-v2,✅,✅,,
-Dhyana-v1,✅,✅,✅,
-EPYC-Milan-v1,✅,✅,✅,
-EPYC-Rome-v1,✅,✅,✅,
-EPYC-Rome-v2,✅,✅,✅,
-EPYC-v1,✅,✅,✅,
-EPYC-v2,✅,✅,✅,
-EPYC-v3,✅,✅,✅,
-Haswell-v1,✅,✅,✅,
-Haswell-v2,✅,✅,✅,
-Haswell-v3,✅,✅,✅,
-Haswell-v4,✅,✅,✅,
-Icelake-Client-v1,✅,✅,✅,
-Icelake-Client-v2,✅,✅,✅,
-Icelake-Server-v1,✅,✅,✅,✅
-Icelake-Server-v2,✅,✅,✅,✅
-Icelake-Server-v3,✅,✅,✅,✅
-Icelake-Server-v4,✅,✅,✅,✅
-IvyBridge-v1,✅,✅,,
-IvyBridge-v2,✅,✅,,
-KnightsMill-v1,✅,✅,✅,
-Nehalem-v1,✅,✅,,
-Nehalem-v2,✅,✅,,
-Opteron_G1-v1,✅,,,
-Opteron_G2-v1,✅,,,
-Opteron_G3-v1,✅,,,
-Opteron_G4-v1,✅,✅,,
-Opteron_G5-v1,✅,✅,,
-Penryn-v1,✅,,,
-SandyBridge-v1,✅,✅,,
-SandyBridge-v2,✅,✅,,
-Skylake-Client-v1,✅,✅,✅,
-Skylake-Client-v2,✅,✅,✅,
-Skylake-Client-v3,✅,✅,✅,
-Skylake-Server-v1,✅,✅,✅,✅
-Skylake-Server-v2,✅,✅,✅,✅
-Skylake-Server-v3,✅,✅,✅,✅
-Skylake-Server-v4,✅,✅,✅,✅
-Snowridge-v1,✅,✅,,
-Snowridge-v2,✅,✅,,
-Westmere-v1,✅,✅,,
-Westmere-v2,✅,✅,,
-athlon-v1,,,,
-core2duo-v1,✅,,,
-coreduo-v1,,,,
-kvm32-v1,,,,
-kvm64-v1,✅,,,
-n270-v1,,,,
-pentium-v1,,,,
-pentium2-v1,,,,
-pentium3-v1,,,,
-phenom-v1,✅,,,
-qemu32-v1,,,,
-qemu64-v1,✅,,,
diff --git a/docs/system/cpu-models-x86.rst.inc b/docs/system/cpu-models-x86.rst.inc
index f40ee03ecc..867c8216b5 100644
--- a/docs/system/cpu-models-x86.rst.inc
+++ b/docs/system/cpu-models-x86.rst.inc
@@ -39,28 +39,6 @@ CPU, as they would with "Host passthrough", but gives much of the
 benefit of passthrough, while making live migration safe.
 
 
-ABI compatibility levels for CPU models
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-The x86_64 architecture has a number of `ABI compatibility levels`_
-defined. Traditionally most operating systems and toolchains would
-only target the original baseline ABI. It is expected that in
-future OS and toolchains are likely to target newer ABIs. The
-table that follows illustrates which ABI compatibility levels
-can be satisfied by the QEMU CPU models. Note that the table only
-lists the long term stable CPU model versions (eg Haswell-v4).
-In addition to whats listed, there are also many CPU model
-aliases which resolve to a different CPU model version,
-depending on the machine type is in use.
-
-.. _ABI compatibility levels: https://gitlab.com/x86-psABIs/x86-64-ABI/
-
-.. csv-table:: x86-64 ABI compatibility levels
-   :file: cpu-models-x86-abi.csv
-   :widths: 40,15,15,15,15
-   :header-rows: 2
-
-
 Preferred CPU models for Intel x86 hosts
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
diff --git a/docs/tools/virtiofsd.rst b/docs/tools/virtiofsd.rst
index 00554c75bd..4911e797cb 100644
--- a/docs/tools/virtiofsd.rst
+++ b/docs/tools/virtiofsd.rst
@@ -239,7 +239,7 @@ xattr-mapping Examples
 
 ::
 
--o xattrmap=":prefix:all::user.virtiofs.::bad:all:::"
+ -o xattrmap=":prefix:all::user.virtiofs.::bad:all:::"
 
 
 This uses two rules, using : as the field separator;
@@ -250,7 +250,8 @@ the host set.
 This is equivalent to the 'map' rule:
 
 ::
--o xattrmap=":map::user.virtiofs.:"
+
+ -o xattrmap=":map::user.virtiofs.:"
 
 2) Prefix 'trusted.' attributes, allow others through
 
@@ -277,7 +278,8 @@ through.
 This is equivalent to the 'map' rule:
 
 ::
--o xattrmap="/map/trusted./user.virtiofs./"
+
+ -o xattrmap="/map/trusted./user.virtiofs./"
 
 3) Hide 'security.' attributes, and allow everything else
 
@@ -298,13 +300,13 @@ Examples
 Export ``/var/lib/fs/vm001/`` on vhost-user UNIX domain socket
 ``/var/run/vm001-vhost-fs.sock``:
 
-::
+.. parsed-literal::
 
   host# virtiofsd --socket-path=/var/run/vm001-vhost-fs.sock -o source=/var/lib/fs/vm001
-  host# qemu-system-x86_64 \
-      -chardev socket,id=char0,path=/var/run/vm001-vhost-fs.sock \
-      -device vhost-user-fs-pci,chardev=char0,tag=myfs \
-      -object memory-backend-memfd,id=mem,size=4G,share=on \
-      -numa node,memdev=mem \
-      ...
+  host# |qemu_system| \\
+        -chardev socket,id=char0,path=/var/run/vm001-vhost-fs.sock \\
+        -device vhost-user-fs-pci,chardev=char0,tag=myfs \\
+        -object memory-backend-memfd,id=mem,size=4G,share=on \\
+        -numa node,memdev=mem \\
+        ...
   guest# mount -t virtiofs myfs /mnt
diff --git a/hw/i386/x86.c b/hw/i386/x86.c
index d30cf27e29..ed796fe6ba 100644
--- a/hw/i386/x86.c
+++ b/hw/i386/x86.c
@@ -1246,23 +1246,6 @@ static void x86_machine_set_oem_table_id(Object *obj, const char *value,
     strncpy(x86ms->oem_table_id, value, 8);
 }
 
-static void x86_machine_get_bus_lock_ratelimit(Object *obj, Visitor *v,
-                                const char *name, void *opaque, Error **errp)
-{
-    X86MachineState *x86ms = X86_MACHINE(obj);
-    uint64_t bus_lock_ratelimit = x86ms->bus_lock_ratelimit;
-
-    visit_type_uint64(v, name, &bus_lock_ratelimit, errp);
-}
-
-static void x86_machine_set_bus_lock_ratelimit(Object *obj, Visitor *v,
-                               const char *name, void *opaque, Error **errp)
-{
-    X86MachineState *x86ms = X86_MACHINE(obj);
-
-    visit_type_uint64(v, name, &x86ms->bus_lock_ratelimit, errp);
-}
-
 static void x86_machine_initfn(Object *obj)
 {
     X86MachineState *x86ms = X86_MACHINE(obj);
@@ -1273,7 +1256,6 @@ static void x86_machine_initfn(Object *obj)
     x86ms->pci_irq_mask = ACPI_BUILD_PCI_IRQS;
     x86ms->oem_id = g_strndup(ACPI_BUILD_APPNAME6, 6);
     x86ms->oem_table_id = g_strndup(ACPI_BUILD_APPNAME8, 8);
-    x86ms->bus_lock_ratelimit = 0;
 }
 
 static void x86_machine_class_init(ObjectClass *oc, void *data)
@@ -1317,12 +1299,6 @@ static void x86_machine_class_init(ObjectClass *oc, void *data)
                                           "Override the default value of field OEM Table ID "
                                           "in ACPI table header."
                                           "The string may be up to 8 bytes in size");
-
-    object_class_property_add(oc, X86_MACHINE_BUS_LOCK_RATELIMIT, "uint64_t",
-                                x86_machine_get_bus_lock_ratelimit,
-                                x86_machine_set_bus_lock_ratelimit, NULL, NULL);
-    object_class_property_set_description(oc, X86_MACHINE_BUS_LOCK_RATELIMIT,
-            "Set the ratelimit for the bus locks acquired in VMs");
 }
 
 static const TypeInfo x86_machine_info = {
diff --git a/include/block/aio.h b/include/block/aio.h
index 10fcae1515..5f342267d5 100644
--- a/include/block/aio.h
+++ b/include/block/aio.h
@@ -691,13 +691,10 @@ void aio_co_enter(AioContext *ctx, struct Coroutine *co);
  * Return the AioContext whose event loop runs in the current thread.
  *
  * If called from an IOThread this will be the IOThread's AioContext.  If
- * called from the main thread or with the "big QEMU lock" taken it
- * will be the main loop AioContext.
+ * called from another thread it will be the main loop AioContext.
  */
 AioContext *qemu_get_current_aio_context(void);
 
-void qemu_set_current_aio_context(AioContext *ctx);
-
 /**
  * aio_context_setup:
  * @ctx: the aio context
diff --git a/include/block/nbd.h b/include/block/nbd.h
index 78d101b774..5f34d23bb0 100644
--- a/include/block/nbd.h
+++ b/include/block/nbd.h
@@ -406,22 +406,4 @@ const char *nbd_info_lookup(uint16_t info);
 const char *nbd_cmd_lookup(uint16_t info);
 const char *nbd_err_lookup(int err);
 
-/* nbd/client-connection.c */
-typedef struct NBDClientConnection NBDClientConnection;
-
-void nbd_client_connection_enable_retry(NBDClientConnection *conn);
-
-NBDClientConnection *nbd_client_connection_new(const SocketAddress *saddr,
-                                               bool do_negotiation,
-                                               const char *export_name,
-                                               const char *x_dirty_bitmap,
-                                               QCryptoTLSCreds *tlscreds);
-void nbd_client_connection_release(NBDClientConnection *conn);
-
-QIOChannel *coroutine_fn
-nbd_co_establish_connection(NBDClientConnection *conn, NBDExportInfo *info,
-                            bool blocking, Error **errp);
-
-void coroutine_fn nbd_co_establish_connection_cancel(NBDClientConnection *conn);
-
 #endif
diff --git a/include/fpu/softfloat-helpers.h b/include/fpu/softfloat-helpers.h
index 34f4cf92ae..a98d759cd3 100644
--- a/include/fpu/softfloat-helpers.h
+++ b/include/fpu/softfloat-helpers.h
@@ -48,8 +48,8 @@ this code that are retained.
 ===============================================================================
 */
 
-#ifndef _SOFTFLOAT_HELPERS_H_
-#define _SOFTFLOAT_HELPERS_H_
+#ifndef SOFTFLOAT_HELPERS_H
+#define SOFTFLOAT_HELPERS_H
 
 #include "fpu/softfloat-types.h"
 
diff --git a/include/hw/i386/x86.h b/include/hw/i386/x86.h
index 25a1f16f01..c09b648dff 100644
--- a/include/hw/i386/x86.h
+++ b/include/hw/i386/x86.h
@@ -74,20 +74,12 @@ struct X86MachineState {
      * will be translated to MSI messages in the address space.
      */
     AddressSpace *ioapic_as;
-
-    /*
-     * Ratelimit enforced on detected bus locks in guest.
-     * The default value of the bus_lock_ratelimit is 0 per second,
-     * which means no limitation on the guest's bus locks.
-     */
-    uint64_t bus_lock_ratelimit;
 };
 
 #define X86_MACHINE_SMM              "smm"
 #define X86_MACHINE_ACPI             "acpi"
 #define X86_MACHINE_OEM_ID           "x-oem-id"
 #define X86_MACHINE_OEM_TABLE_ID     "x-oem-table-id"
-#define X86_MACHINE_BUS_LOCK_RATELIMIT  "bus-lock-ratelimit"
 
 #define TYPE_X86_MACHINE   MACHINE_TYPE_NAME("x86")
 OBJECT_DECLARE_TYPE(X86MachineState, X86MachineClass, X86_MACHINE)
diff --git a/include/hw/usb/dwc2-regs.h b/include/hw/usb/dwc2-regs.h
index 40af23a0ba..a7eb531485 100644
--- a/include/hw/usb/dwc2-regs.h
+++ b/include/hw/usb/dwc2-regs.h
@@ -39,8 +39,8 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifndef __DWC2_HW_H__
-#define __DWC2_HW_H__
+#ifndef DWC2_HW_H
+#define DWC2_HW_H
 
 #define HSOTG_REG(x)	(x)
 
diff --git a/include/hw/usb/xlnx-usb-subsystem.h b/include/hw/usb/xlnx-usb-subsystem.h
index 739bef7f45..999e423951 100644
--- a/include/hw/usb/xlnx-usb-subsystem.h
+++ b/include/hw/usb/xlnx-usb-subsystem.h
@@ -22,8 +22,8 @@
  * THE SOFTWARE.
  */
 
-#ifndef _XLNX_VERSAL_USB_SUBSYSTEM_H_
-#define _XLNX_VERSAL_USB_SUBSYSTEM_H_
+#ifndef XLNX_VERSAL_USB_SUBSYSTEM_H
+#define XLNX_VERSAL_USB_SUBSYSTEM_H
 
 #include "hw/usb/xlnx-versal-usb2-ctrl-regs.h"
 #include "hw/usb/hcd-dwc3.h"
diff --git a/include/hw/usb/xlnx-versal-usb2-ctrl-regs.h b/include/hw/usb/xlnx-versal-usb2-ctrl-regs.h
index 975a717627..b76dce0419 100644
--- a/include/hw/usb/xlnx-versal-usb2-ctrl-regs.h
+++ b/include/hw/usb/xlnx-versal-usb2-ctrl-regs.h
@@ -23,8 +23,8 @@
  * THE SOFTWARE.
  */
 
-#ifndef _XLNX_USB2_REGS_H_
-#define _XLNX_USB2_REGS_H_
+#ifndef XLNX_USB2_REGS_H
+#define XLNX_USB2_REGS_H
 
 #define TYPE_XILINX_VERSAL_USB2_CTRL_REGS "xlnx.versal-usb2-ctrl-regs"
 
diff --git a/include/qemu/coroutine.h b/include/qemu/coroutine.h
index 4829ff373d..292e61aef0 100644
--- a/include/qemu/coroutine.h
+++ b/include/qemu/coroutine.h
@@ -210,15 +210,13 @@ void coroutine_fn qemu_co_queue_wait_impl(CoQueue *queue, QemuLockable *lock);
 /**
  * Removes the next coroutine from the CoQueue, and wake it up.
  * Returns true if a coroutine was removed, false if the queue is empty.
- * OK to run from coroutine and non-coroutine context.
  */
-bool qemu_co_queue_next(CoQueue *queue);
+bool coroutine_fn qemu_co_queue_next(CoQueue *queue);
 
 /**
  * Empties the CoQueue; all coroutines are woken up.
- * OK to run from coroutine and non-coroutine context.
  */
-void qemu_co_queue_restart_all(CoQueue *queue);
+void coroutine_fn qemu_co_queue_restart_all(CoQueue *queue);
 
 /**
  * Removes the next coroutine from the CoQueue, and wake it up.  Unlike
diff --git a/include/qemu/plugin-memory.h b/include/qemu/plugin-memory.h
index fbbe99474b..b36def27d7 100644
--- a/include/qemu/plugin-memory.h
+++ b/include/qemu/plugin-memory.h
@@ -6,8 +6,8 @@
  * SPDX-License-Identifier: GPL-2.0-or-later
  */
 
-#ifndef _PLUGIN_MEMORY_H_
-#define _PLUGIN_MEMORY_H_
+#ifndef PLUGIN_MEMORY_H
+#define PLUGIN_MEMORY_H
 
 struct qemu_plugin_hwaddr {
     bool is_io;
diff --git a/include/qemu/selfmap.h b/include/qemu/selfmap.h
index 8382c4c779..80cf920fba 100644
--- a/include/qemu/selfmap.h
+++ b/include/qemu/selfmap.h
@@ -6,8 +6,8 @@
  * SPDX-License-Identifier: GPL-2.0-or-later
  */
 
-#ifndef _SELFMAP_H_
-#define _SELFMAP_H_
+#ifndef SELFMAP_H
+#define SELFMAP_H
 
 typedef struct {
     unsigned long start;
diff --git a/include/qemu/sockets.h b/include/qemu/sockets.h
index 0c34bf2398..7d1f813576 100644
--- a/include/qemu/sockets.h
+++ b/include/qemu/sockets.h
@@ -111,15 +111,4 @@ SocketAddress *socket_remote_address(int fd, Error **errp);
  */
 SocketAddress *socket_address_flatten(SocketAddressLegacy *addr);
 
-/**
- * socket_address_parse_named_fd:
- *
- * Modify @addr, replacing a named fd by its corresponding number.
- * Needed for callers that plan to pass @addr to a context where the
- * current monitor is not available.
- *
- * Return 0 on success.
- */
-int socket_address_parse_named_fd(SocketAddress *addr, Error **errp);
-
 #endif /* QEMU_SOCKETS_H */
diff --git a/include/standard-headers/drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.h b/include/standard-headers/drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.h
index 94d41b202c..1677208a41 100644
--- a/include/standard-headers/drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.h
+++ b/include/standard-headers/drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.h
@@ -70,6 +70,30 @@ enum pvrdma_mtu {
 	PVRDMA_MTU_4096 = 5,
 };
 
+static inline int pvrdma_mtu_enum_to_int(enum pvrdma_mtu mtu)
+{
+	switch (mtu) {
+	case PVRDMA_MTU_256:	return  256;
+	case PVRDMA_MTU_512:	return  512;
+	case PVRDMA_MTU_1024:	return 1024;
+	case PVRDMA_MTU_2048:	return 2048;
+	case PVRDMA_MTU_4096:	return 4096;
+	default:		return   -1;
+	}
+}
+
+static inline enum pvrdma_mtu pvrdma_mtu_int_to_enum(int mtu)
+{
+	switch (mtu) {
+	case 256:	return PVRDMA_MTU_256;
+	case 512:	return PVRDMA_MTU_512;
+	case 1024:	return PVRDMA_MTU_1024;
+	case 2048:	return PVRDMA_MTU_2048;
+	case 4096:
+	default:	return PVRDMA_MTU_4096;
+	}
+}
+
 enum pvrdma_port_state {
 	PVRDMA_PORT_NOP			= 0,
 	PVRDMA_PORT_DOWN		= 1,
@@ -114,6 +138,17 @@ enum pvrdma_port_width {
 	PVRDMA_WIDTH_12X	= 8,
 };
 
+static inline int pvrdma_width_enum_to_int(enum pvrdma_port_width width)
+{
+	switch (width) {
+	case PVRDMA_WIDTH_1X:	return  1;
+	case PVRDMA_WIDTH_4X:	return  4;
+	case PVRDMA_WIDTH_8X:	return  8;
+	case PVRDMA_WIDTH_12X:	return 12;
+	default:		return -1;
+	}
+}
+
 enum pvrdma_port_speed {
 	PVRDMA_SPEED_SDR	= 1,
 	PVRDMA_SPEED_DDR	= 2,
diff --git a/include/standard-headers/drm/drm_fourcc.h b/include/standard-headers/drm/drm_fourcc.h
index a61ae520c2..c47e19810c 100644
--- a/include/standard-headers/drm/drm_fourcc.h
+++ b/include/standard-headers/drm/drm_fourcc.h
@@ -526,25 +526,6 @@ extern "C" {
  */
 #define I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS fourcc_mod_code(INTEL, 7)
 
-/*
- * Intel Color Control Surface with Clear Color (CCS) for Gen-12 render
- * compression.
- *
- * The main surface is Y-tiled and is at plane index 0 whereas CCS is linear
- * and at index 1. The clear color is stored at index 2, and the pitch should
- * be ignored. The clear color structure is 256 bits. The first 128 bits
- * represents Raw Clear Color Red, Green, Blue and Alpha color each represented
- * by 32 bits. The raw clear color is consumed by the 3d engine and generates
- * the converted clear color of size 64 bits. The first 32 bits store the Lower
- * Converted Clear Color value and the next 32 bits store the Higher Converted
- * Clear Color value when applicable. The Converted Clear Color values are
- * consumed by the DE. The last 64 bits are used to store Color Discard Enable
- * and Depth Clear Value Valid which are ignored by the DE. A CCS cache line
- * corresponds to an area of 4x1 tiles in the main surface. The main surface
- * pitch is required to be a multiple of 4 tile widths.
- */
-#define I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS_CC fourcc_mod_code(INTEL, 8)
-
 /*
  * Tiled, NV12MT, grouped in 64 (pixels) x 32 (lines) -sized macroblocks
  *
@@ -1054,9 +1035,9 @@ drm_fourcc_canonicalize_nvidia_format_mod(uint64_t modifier)
  * Not all combinations are valid, and different SoCs may support different
  * combinations of layout and options.
  */
-#define __fourcc_mod_amlogic_layout_mask 0xff
+#define __fourcc_mod_amlogic_layout_mask 0xf
 #define __fourcc_mod_amlogic_options_shift 8
-#define __fourcc_mod_amlogic_options_mask 0xff
+#define __fourcc_mod_amlogic_options_mask 0xf
 
 #define DRM_FORMAT_MOD_AMLOGIC_FBC(__layout, __options) \
 	fourcc_mod_code(AMLOGIC, \
diff --git a/include/standard-headers/linux/ethtool.h b/include/standard-headers/linux/ethtool.h
index 218d944a17..8bfd01d230 100644
--- a/include/standard-headers/linux/ethtool.h
+++ b/include/standard-headers/linux/ethtool.h
@@ -26,14 +26,6 @@
  * have the same layout for 32-bit and 64-bit userland.
  */
 
-/* Note on reserved space.
- * Reserved fields must not be accessed directly by user space because
- * they may be replaced by a different field in the future. They must
- * be initialized to zero before making the request, e.g. via memset
- * of the entire structure or implicitly by not being set in a structure
- * initializer.
- */
-
 /**
  * struct ethtool_cmd - DEPRECATED, link control and status
  * This structure is DEPRECATED, please use struct ethtool_link_settings.
@@ -75,7 +67,6 @@
  *	and other link features that the link partner advertised
  *	through autonegotiation; 0 if unknown or not applicable.
  *	Read-only.
- * @reserved: Reserved for future use; see the note on reserved space.
  *
  * The link speed in Mbps is split between @speed and @speed_hi.  Use
  * the ethtool_cmd_speed() and ethtool_cmd_speed_set() functions to
@@ -164,7 +155,6 @@ static inline uint32_t ethtool_cmd_speed(const struct ethtool_cmd *ep)
  * @bus_info: Device bus address.  This should match the dev_name()
  *	string for the underlying bus device, if there is one.  May be
  *	an empty string.
- * @reserved2: Reserved for future use; see the note on reserved space.
  * @n_priv_flags: Number of flags valid for %ETHTOOL_GPFLAGS and
  *	%ETHTOOL_SPFLAGS commands; also the number of strings in the
  *	%ETH_SS_PRIV_FLAGS set
@@ -366,7 +356,6 @@ struct ethtool_eeprom {
  * @tx_lpi_timer: Time in microseconds the interface delays prior to asserting
  *	its tx lpi (after reaching 'idle' state). Effective only when eee
  *	was negotiated and tx_lpi_enabled was set.
- * @reserved: Reserved for future use; see the note on reserved space.
  */
 struct ethtool_eee {
 	uint32_t	cmd;
@@ -385,7 +374,6 @@ struct ethtool_eee {
  * @cmd: %ETHTOOL_GMODULEINFO
  * @type: Standard the module information conforms to %ETH_MODULE_SFF_xxxx
  * @eeprom_len: Length of the eeprom
- * @reserved: Reserved for future use; see the note on reserved space.
  *
  * This structure is used to return the information to
  * properly size memory for a subsequent call to %ETHTOOL_GMODULEEEPROM.
@@ -591,7 +579,9 @@ struct ethtool_pauseparam {
 	uint32_t	tx_pause;
 };
 
-/* Link extended state */
+/**
+ * enum ethtool_link_ext_state - link extended state
+ */
 enum ethtool_link_ext_state {
 	ETHTOOL_LINK_EXT_STATE_AUTONEG,
 	ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE,
@@ -605,7 +595,10 @@ enum ethtool_link_ext_state {
 	ETHTOOL_LINK_EXT_STATE_OVERHEAT,
 };
 
-/* More information in addition to ETHTOOL_LINK_EXT_STATE_AUTONEG. */
+/**
+ * enum ethtool_link_ext_substate_autoneg - more information in addition to
+ * ETHTOOL_LINK_EXT_STATE_AUTONEG.
+ */
 enum ethtool_link_ext_substate_autoneg {
 	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED = 1,
 	ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED,
@@ -615,7 +608,9 @@ enum ethtool_link_ext_substate_autoneg {
 	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD,
 };
 
-/* More information in addition to ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE.
+/**
+ * enum ethtool_link_ext_substate_link_training - more information in addition to
+ * ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE.
  */
 enum ethtool_link_ext_substate_link_training {
 	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED = 1,
@@ -624,7 +619,9 @@ enum ethtool_link_ext_substate_link_training {
 	ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT,
 };
 
-/* More information in addition to ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH.
+/**
+ * enum ethtool_link_ext_substate_logical_mismatch - more information in addition
+ * to ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH.
  */
 enum ethtool_link_ext_substate_link_logical_mismatch {
 	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK = 1,
@@ -634,14 +631,19 @@ enum ethtool_link_ext_substate_link_logical_mismatch {
 	ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED,
 };
 
-/* More information in addition to ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY.
+/**
+ * enum ethtool_link_ext_substate_bad_signal_integrity - more information in
+ * addition to ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY.
  */
 enum ethtool_link_ext_substate_bad_signal_integrity {
 	ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS = 1,
 	ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE,
 };
 
-/* More information in addition to ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE. */
+/**
+ * enum ethtool_link_ext_substate_cable_issue - more information in
+ * addition to ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE.
+ */
 enum ethtool_link_ext_substate_cable_issue {
 	ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE = 1,
 	ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE,
@@ -659,7 +661,6 @@ enum ethtool_link_ext_substate_cable_issue {
  *	now deprecated
  * @ETH_SS_FEATURES: Device feature names
  * @ETH_SS_RSS_HASH_FUNCS: RSS hush function names
- * @ETH_SS_TUNABLES: tunable names
  * @ETH_SS_PHY_STATS: Statistic names, for use with %ETHTOOL_GPHYSTATS
  * @ETH_SS_PHY_TUNABLES: PHY tunable names
  * @ETH_SS_LINK_MODES: link mode names
@@ -669,13 +670,6 @@ enum ethtool_link_ext_substate_cable_issue {
  * @ETH_SS_TS_TX_TYPES: timestamping Tx types
  * @ETH_SS_TS_RX_FILTERS: timestamping Rx filters
  * @ETH_SS_UDP_TUNNEL_TYPES: UDP tunnel types
- * @ETH_SS_STATS_STD: standardized stats
- * @ETH_SS_STATS_ETH_PHY: names of IEEE 802.3 PHY statistics
- * @ETH_SS_STATS_ETH_MAC: names of IEEE 802.3 MAC statistics
- * @ETH_SS_STATS_ETH_CTRL: names of IEEE 802.3 MAC Control statistics
- * @ETH_SS_STATS_RMON: names of RMON statistics
- *
- * @ETH_SS_COUNT: number of defined string sets
  */
 enum ethtool_stringset {
 	ETH_SS_TEST		= 0,
@@ -694,11 +688,6 @@ enum ethtool_stringset {
 	ETH_SS_TS_TX_TYPES,
 	ETH_SS_TS_RX_FILTERS,
 	ETH_SS_UDP_TUNNEL_TYPES,
-	ETH_SS_STATS_STD,
-	ETH_SS_STATS_ETH_PHY,
-	ETH_SS_STATS_ETH_MAC,
-	ETH_SS_STATS_ETH_CTRL,
-	ETH_SS_STATS_RMON,
 
 	/* add new constants above here */
 	ETH_SS_COUNT
@@ -726,7 +715,6 @@ struct ethtool_gstrings {
 /**
  * struct ethtool_sset_info - string set information
  * @cmd: Command number = %ETHTOOL_GSSET_INFO
- * @reserved: Reserved for future use; see the note on reserved space.
  * @sset_mask: On entry, a bitmask of string sets to query, with bits
  *	numbered according to &enum ethtool_stringset.  On return, a
  *	bitmask of those string sets queried that are supported.
@@ -771,7 +759,6 @@ enum ethtool_test_flags {
  * @flags: A bitmask of flags from &enum ethtool_test_flags.  Some
  *	flags may be set by the user on entry; others may be set by
  *	the driver on return.
- * @reserved: Reserved for future use; see the note on reserved space.
  * @len: On return, the number of test results
  * @data: Array of test results
  *
@@ -972,7 +959,6 @@ union ethtool_flow_union {
  * @vlan_etype: VLAN EtherType
  * @vlan_tci: VLAN tag control information
  * @data: user defined data
- * @padding: Reserved for future use; see the note on reserved space.
  *
  * Note, @vlan_etype, @vlan_tci, and @data are only valid if %FLOW_EXT
  * is set in &struct ethtool_rx_flow_spec @flow_type.
@@ -1148,8 +1134,7 @@ struct ethtool_rxfh_indir {
  *	hardware hash key.
  * @hfunc: Defines the current RSS hash function used by HW (or to be set to).
  *	Valid values are one of the %ETH_RSS_HASH_*.
- * @rsvd8: Reserved for future use; see the note on reserved space.
- * @rsvd32: Reserved for future use; see the note on reserved space.
+ * @rsvd:	Reserved for future extensions.
  * @rss_config: RX ring/queue index for each hash value i.e., indirection table
  *	of @indir_size uint32_t elements, followed by hash key of @key_size
  *	bytes.
@@ -1317,9 +1302,7 @@ struct ethtool_sfeatures {
  * @so_timestamping: bit mask of the sum of the supported SO_TIMESTAMPING flags
  * @phc_index: device index of the associated PHC, or -1 if there is none
  * @tx_types: bit mask of the supported hwtstamp_tx_types enumeration values
- * @tx_reserved: Reserved for future use; see the note on reserved space.
  * @rx_filters: bit mask of the supported hwtstamp_rx_filters enumeration values
- * @rx_reserved: Reserved for future use; see the note on reserved space.
  *
  * The bits in the 'tx_types' and 'rx_filters' fields correspond to
  * the 'hwtstamp_tx_types' and 'hwtstamp_rx_filters' enumeration values,
@@ -1393,33 +1376,15 @@ struct ethtool_per_queue_op {
 };
 
 /**
- * struct ethtool_fecparam - Ethernet Forward Error Correction parameters
+ * struct ethtool_fecparam - Ethernet forward error correction(fec) parameters
  * @cmd: Command number = %ETHTOOL_GFECPARAM or %ETHTOOL_SFECPARAM
- * @active_fec: FEC mode which is active on the port, single bit set, GET only.
- * @fec: Bitmask of configured FEC modes.
- * @reserved: Reserved for future extensions, ignore on GET, write 0 for SET.
- *
- * Note that @reserved was never validated on input and ethtool user space
- * left it uninitialized when calling SET. Hence going forward it can only be
- * used to return a value to userspace with GET.
+ * @active_fec: FEC mode which is active on porte
+ * @fec: Bitmask of supported/configured FEC modes
+ * @rsvd: Reserved for future extensions. i.e FEC bypass feature.
  *
- * FEC modes supported by the device can be read via %ETHTOOL_GLINKSETTINGS.
- * FEC settings are configured by link autonegotiation whenever it's enabled.
- * With autoneg on %ETHTOOL_GFECPARAM can be used to read the current mode.
- *
- * When autoneg is disabled %ETHTOOL_SFECPARAM controls the FEC settings.
- * It is recommended that drivers only accept a single bit set in @fec.
- * When multiple bits are set in @fec drivers may pick mode in an implementation
- * dependent way. Drivers should reject mixing %ETHTOOL_FEC_AUTO_BIT with other
- * FEC modes, because it's unclear whether in this case other modes constrain
- * AUTO or are independent choices.
- * Drivers must reject SET requests if they support none of the requested modes.
- *
- * If device does not support FEC drivers may use %ETHTOOL_FEC_NONE instead
- * of returning %EOPNOTSUPP from %ETHTOOL_GFECPARAM.
+ * Drivers should reject a non-zero setting of @autoneg when
+ * autoneogotiation is disabled (or not supported) for the link.
  *
- * See enum ethtool_fec_config_bits for definition of valid bits for both
- * @fec and @active_fec.
  */
 struct ethtool_fecparam {
 	uint32_t   cmd;
@@ -1431,16 +1396,11 @@ struct ethtool_fecparam {
 
 /**
  * enum ethtool_fec_config_bits - flags definition of ethtool_fec_configuration
- * @ETHTOOL_FEC_NONE_BIT: FEC mode configuration is not supported. Should not
- *			be used together with other bits. GET only.
- * @ETHTOOL_FEC_AUTO_BIT: Select default/best FEC mode automatically, usually
- *			based link mode and SFP parameters read from module's
- *			EEPROM. This bit does _not_ mean autonegotiation.
- * @ETHTOOL_FEC_OFF_BIT: No FEC Mode
- * @ETHTOOL_FEC_RS_BIT: Reed-Solomon FEC Mode
- * @ETHTOOL_FEC_BASER_BIT: Base-R/Reed-Solomon FEC Mode
- * @ETHTOOL_FEC_LLRS_BIT: Low Latency Reed Solomon FEC Mode (25G/50G Ethernet
- *			Consortium)
+ * @ETHTOOL_FEC_NONE: FEC mode configuration is not supported
+ * @ETHTOOL_FEC_AUTO: Default/Best FEC mode provided by driver
+ * @ETHTOOL_FEC_OFF: No FEC Mode
+ * @ETHTOOL_FEC_RS: Reed-Solomon Forward Error Detection mode
+ * @ETHTOOL_FEC_BASER: Base-R/Reed-Solomon Forward Error Detection mode
  */
 enum ethtool_fec_config_bits {
 	ETHTOOL_FEC_NONE_BIT,
@@ -1998,11 +1958,6 @@ enum ethtool_reset_flags {
  *	autonegotiation; 0 if unknown or not applicable.  Read-only.
  * @transceiver: Used to distinguish different possible PHY types,
  *	reported consistently by PHYLIB.  Read-only.
- * @master_slave_cfg: Master/slave port mode.
- * @master_slave_state: Master/slave port state.
- * @reserved: Reserved for future use; see the note on reserved space.
- * @reserved1: Reserved for future use; see the note on reserved space.
- * @link_mode_masks: Variable length bitmaps.
  *
  * If autonegotiation is disabled, the speed and @duplex represent the
  * fixed link mode and are writable if the driver supports multiple
diff --git a/include/standard-headers/linux/fuse.h b/include/standard-headers/linux/fuse.h
index cce105bfba..950d7edb7e 100644
--- a/include/standard-headers/linux/fuse.h
+++ b/include/standard-headers/linux/fuse.h
@@ -179,8 +179,6 @@
  *  7.33
  *  - add FUSE_HANDLE_KILLPRIV_V2, FUSE_WRITE_KILL_SUIDGID, FATTR_KILL_SUIDGID
  *  - add FUSE_OPEN_KILL_SUIDGID
- *  - extend fuse_setxattr_in, add FUSE_SETXATTR_EXT
- *  - add FUSE_SETXATTR_ACL_KILL_SGID
  */
 
 #ifndef _LINUX_FUSE_H
@@ -328,7 +326,6 @@ struct fuse_file_lock {
  *			does not have CAP_FSETID. Additionally upon
  *			write/truncate sgid is killed only if file has group
  *			execute permission. (Same as Linux VFS behavior).
- * FUSE_SETXATTR_EXT:	Server supports extended struct fuse_setxattr_in
  */
 #define FUSE_ASYNC_READ		(1 << 0)
 #define FUSE_POSIX_LOCKS	(1 << 1)
@@ -359,7 +356,6 @@ struct fuse_file_lock {
 #define FUSE_MAP_ALIGNMENT	(1 << 26)
 #define FUSE_SUBMOUNTS		(1 << 27)
 #define FUSE_HANDLE_KILLPRIV_V2	(1 << 28)
-#define FUSE_SETXATTR_EXT	(1 << 29)
 
 /**
  * CUSE INIT request/reply flags
@@ -451,12 +447,6 @@ struct fuse_file_lock {
  */
 #define FUSE_OPEN_KILL_SUIDGID	(1 << 0)
 
-/**
- * setxattr flags
- * FUSE_SETXATTR_ACL_KILL_SGID: Clear SGID when system.posix_acl_access is set
- */
-#define FUSE_SETXATTR_ACL_KILL_SGID	(1 << 0)
-
 enum fuse_opcode {
 	FUSE_LOOKUP		= 1,
 	FUSE_FORGET		= 2,  /* no reply */
@@ -687,13 +677,9 @@ struct fuse_fsync_in {
 	uint32_t	padding;
 };
 
-#define FUSE_COMPAT_SETXATTR_IN_SIZE 8
-
 struct fuse_setxattr_in {
 	uint32_t	size;
 	uint32_t	flags;
-	uint32_t	setxattr_flags;
-	uint32_t	padding;
 };
 
 struct fuse_getxattr_in {
@@ -913,8 +899,7 @@ struct fuse_notify_retrieve_in {
 };
 
 /* Device ioctls: */
-#define FUSE_DEV_IOC_MAGIC		229
-#define FUSE_DEV_IOC_CLONE		_IOR(FUSE_DEV_IOC_MAGIC, 0, uint32_t)
+#define FUSE_DEV_IOC_CLONE	_IOR(229, 0, uint32_t)
 
 struct fuse_lseek_in {
 	uint64_t	fh;
diff --git a/include/standard-headers/linux/input.h b/include/standard-headers/linux/input.h
index 7822c24178..f89c986190 100644
--- a/include/standard-headers/linux/input.h
+++ b/include/standard-headers/linux/input.h
@@ -81,7 +81,7 @@ struct input_id {
  * in units per radian.
  * When INPUT_PROP_ACCELEROMETER is set the resolution changes.
  * The main axes (ABS_X, ABS_Y, ABS_Z) are then reported in
- * units per g (units/g) and in units per degree per second
+ * in units per g (units/g) and in units per degree per second
  * (units/deg/s) for rotational axes (ABS_RX, ABS_RY, ABS_RZ).
  */
 struct input_absinfo {
diff --git a/include/standard-headers/linux/virtio_bt.h b/include/standard-headers/linux/virtio_bt.h
deleted file mode 100644
index 245e1eff4b..0000000000
--- a/include/standard-headers/linux/virtio_bt.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/* SPDX-License-Identifier: BSD-3-Clause */
-
-#ifndef _LINUX_VIRTIO_BT_H
-#define _LINUX_VIRTIO_BT_H
-
-#include "standard-headers/linux/virtio_types.h"
-
-/* Feature bits */
-#define VIRTIO_BT_F_VND_HCI	0	/* Indicates vendor command support */
-#define VIRTIO_BT_F_MSFT_EXT	1	/* Indicates MSFT vendor support */
-#define VIRTIO_BT_F_AOSP_EXT	2	/* Indicates AOSP vendor support */
-
-enum virtio_bt_config_type {
-	VIRTIO_BT_CONFIG_TYPE_PRIMARY	= 0,
-	VIRTIO_BT_CONFIG_TYPE_AMP	= 1,
-};
-
-enum virtio_bt_config_vendor {
-	VIRTIO_BT_CONFIG_VENDOR_NONE	= 0,
-	VIRTIO_BT_CONFIG_VENDOR_ZEPHYR	= 1,
-	VIRTIO_BT_CONFIG_VENDOR_INTEL	= 2,
-	VIRTIO_BT_CONFIG_VENDOR_REALTEK	= 3,
-};
-
-struct virtio_bt_config {
-	uint8_t  type;
-	uint16_t vendor;
-	uint16_t msft_opcode;
-} QEMU_PACKED;
-
-#endif /* _LINUX_VIRTIO_BT_H */
diff --git a/include/standard-headers/linux/virtio_ids.h b/include/standard-headers/linux/virtio_ids.h
index f0c35ce862..bc1c0621f5 100644
--- a/include/standard-headers/linux/virtio_ids.h
+++ b/include/standard-headers/linux/virtio_ids.h
@@ -51,10 +51,8 @@
 #define VIRTIO_ID_PSTORE		22 /* virtio pstore device */
 #define VIRTIO_ID_IOMMU			23 /* virtio IOMMU */
 #define VIRTIO_ID_MEM			24 /* virtio mem */
-#define VIRTIO_ID_SOUND			25 /* virtio sound */
 #define VIRTIO_ID_FS			26 /* virtio filesystem */
 #define VIRTIO_ID_PMEM			27 /* virtio pmem */
-#define VIRTIO_ID_BT			28 /* virtio bluetooth */
 #define VIRTIO_ID_MAC80211_HWSIM	29 /* virtio mac80211-hwsim */
 
 #endif /* _LINUX_VIRTIO_IDS_H */
diff --git a/include/standard-headers/linux/virtio_snd.h b/include/standard-headers/linux/virtio_snd.h
deleted file mode 100644
index 1af96b9fc6..0000000000
--- a/include/standard-headers/linux/virtio_snd.h
+++ /dev/null
@@ -1,334 +0,0 @@
-/* SPDX-License-Identifier: BSD-3-Clause */
-/*
- * Copyright (C) 2021 OpenSynergy GmbH
- */
-#ifndef VIRTIO_SND_IF_H
-#define VIRTIO_SND_IF_H
-
-#include "standard-headers/linux/virtio_types.h"
-
-/*******************************************************************************
- * CONFIGURATION SPACE
- */
-struct virtio_snd_config {
-	/* # of available physical jacks */
-	uint32_t jacks;
-	/* # of available PCM streams */
-	uint32_t streams;
-	/* # of available channel maps */
-	uint32_t chmaps;
-};
-
-enum {
-	/* device virtqueue indexes */
-	VIRTIO_SND_VQ_CONTROL = 0,
-	VIRTIO_SND_VQ_EVENT,
-	VIRTIO_SND_VQ_TX,
-	VIRTIO_SND_VQ_RX,
-	/* # of device virtqueues */
-	VIRTIO_SND_VQ_MAX
-};
-
-/*******************************************************************************
- * COMMON DEFINITIONS
- */
-
-/* supported dataflow directions */
-enum {
-	VIRTIO_SND_D_OUTPUT = 0,
-	VIRTIO_SND_D_INPUT
-};
-
-enum {
-	/* jack control request types */
-	VIRTIO_SND_R_JACK_INFO = 1,
-	VIRTIO_SND_R_JACK_REMAP,
-
-	/* PCM control request types */
-	VIRTIO_SND_R_PCM_INFO = 0x0100,
-	VIRTIO_SND_R_PCM_SET_PARAMS,
-	VIRTIO_SND_R_PCM_PREPARE,
-	VIRTIO_SND_R_PCM_RELEASE,
-	VIRTIO_SND_R_PCM_START,
-	VIRTIO_SND_R_PCM_STOP,
-
-	/* channel map control request types */
-	VIRTIO_SND_R_CHMAP_INFO = 0x0200,
-
-	/* jack event types */
-	VIRTIO_SND_EVT_JACK_CONNECTED = 0x1000,
-	VIRTIO_SND_EVT_JACK_DISCONNECTED,
-
-	/* PCM event types */
-	VIRTIO_SND_EVT_PCM_PERIOD_ELAPSED = 0x1100,
-	VIRTIO_SND_EVT_PCM_XRUN,
-
-	/* common status codes */
-	VIRTIO_SND_S_OK = 0x8000,
-	VIRTIO_SND_S_BAD_MSG,
-	VIRTIO_SND_S_NOT_SUPP,
-	VIRTIO_SND_S_IO_ERR
-};
-
-/* common header */
-struct virtio_snd_hdr {
-	uint32_t code;
-};
-
-/* event notification */
-struct virtio_snd_event {
-	/* VIRTIO_SND_EVT_XXX */
-	struct virtio_snd_hdr hdr;
-	/* optional event data */
-	uint32_t data;
-};
-
-/* common control request to query an item information */
-struct virtio_snd_query_info {
-	/* VIRTIO_SND_R_XXX_INFO */
-	struct virtio_snd_hdr hdr;
-	/* item start identifier */
-	uint32_t start_id;
-	/* item count to query */
-	uint32_t count;
-	/* item information size in bytes */
-	uint32_t size;
-};
-
-/* common item information header */
-struct virtio_snd_info {
-	/* function group node id (High Definition Audio Specification 7.1.2) */
-	uint32_t hda_fn_nid;
-};
-
-/*******************************************************************************
- * JACK CONTROL MESSAGES
- */
-struct virtio_snd_jack_hdr {
-	/* VIRTIO_SND_R_JACK_XXX */
-	struct virtio_snd_hdr hdr;
-	/* 0 ... virtio_snd_config::jacks - 1 */
-	uint32_t jack_id;
-};
-
-/* supported jack features */
-enum {
-	VIRTIO_SND_JACK_F_REMAP = 0
-};
-
-struct virtio_snd_jack_info {
-	/* common header */
-	struct virtio_snd_info hdr;
-	/* supported feature bit map (1 << VIRTIO_SND_JACK_F_XXX) */
-	uint32_t features;
-	/* pin configuration (High Definition Audio Specification 7.3.3.31) */
-	uint32_t hda_reg_defconf;
-	/* pin capabilities (High Definition Audio Specification 7.3.4.9) */
-	uint32_t hda_reg_caps;
-	/* current jack connection status (0: disconnected, 1: connected) */
-	uint8_t connected;
-
-	uint8_t padding[7];
-};
-
-/* jack remapping control request */
-struct virtio_snd_jack_remap {
-	/* .code = VIRTIO_SND_R_JACK_REMAP */
-	struct virtio_snd_jack_hdr hdr;
-	/* selected association number */
-	uint32_t association;
-	/* selected sequence number */
-	uint32_t sequence;
-};
-
-/*******************************************************************************
- * PCM CONTROL MESSAGES
- */
-struct virtio_snd_pcm_hdr {
-	/* VIRTIO_SND_R_PCM_XXX */
-	struct virtio_snd_hdr hdr;
-	/* 0 ... virtio_snd_config::streams - 1 */
-	uint32_t stream_id;
-};
-
-/* supported PCM stream features */
-enum {
-	VIRTIO_SND_PCM_F_SHMEM_HOST = 0,
-	VIRTIO_SND_PCM_F_SHMEM_GUEST,
-	VIRTIO_SND_PCM_F_MSG_POLLING,
-	VIRTIO_SND_PCM_F_EVT_SHMEM_PERIODS,
-	VIRTIO_SND_PCM_F_EVT_XRUNS
-};
-
-/* supported PCM sample formats */
-enum {
-	/* analog formats (width / physical width) */
-	VIRTIO_SND_PCM_FMT_IMA_ADPCM = 0,	/*  4 /  4 bits */
-	VIRTIO_SND_PCM_FMT_MU_LAW,		/*  8 /  8 bits */
-	VIRTIO_SND_PCM_FMT_A_LAW,		/*  8 /  8 bits */
-	VIRTIO_SND_PCM_FMT_S8,			/*  8 /  8 bits */
-	VIRTIO_SND_PCM_FMT_U8,			/*  8 /  8 bits */
-	VIRTIO_SND_PCM_FMT_S16,			/* 16 / 16 bits */
-	VIRTIO_SND_PCM_FMT_U16,			/* 16 / 16 bits */
-	VIRTIO_SND_PCM_FMT_S18_3,		/* 18 / 24 bits */
-	VIRTIO_SND_PCM_FMT_U18_3,		/* 18 / 24 bits */
-	VIRTIO_SND_PCM_FMT_S20_3,		/* 20 / 24 bits */
-	VIRTIO_SND_PCM_FMT_U20_3,		/* 20 / 24 bits */
-	VIRTIO_SND_PCM_FMT_S24_3,		/* 24 / 24 bits */
-	VIRTIO_SND_PCM_FMT_U24_3,		/* 24 / 24 bits */
-	VIRTIO_SND_PCM_FMT_S20,			/* 20 / 32 bits */
-	VIRTIO_SND_PCM_FMT_U20,			/* 20 / 32 bits */
-	VIRTIO_SND_PCM_FMT_S24,			/* 24 / 32 bits */
-	VIRTIO_SND_PCM_FMT_U24,			/* 24 / 32 bits */
-	VIRTIO_SND_PCM_FMT_S32,			/* 32 / 32 bits */
-	VIRTIO_SND_PCM_FMT_U32,			/* 32 / 32 bits */
-	VIRTIO_SND_PCM_FMT_FLOAT,		/* 32 / 32 bits */
-	VIRTIO_SND_PCM_FMT_FLOAT64,		/* 64 / 64 bits */
-	/* digital formats (width / physical width) */
-	VIRTIO_SND_PCM_FMT_DSD_U8,		/*  8 /  8 bits */
-	VIRTIO_SND_PCM_FMT_DSD_U16,		/* 16 / 16 bits */
-	VIRTIO_SND_PCM_FMT_DSD_U32,		/* 32 / 32 bits */
-	VIRTIO_SND_PCM_FMT_IEC958_SUBFRAME	/* 32 / 32 bits */
-};
-
-/* supported PCM frame rates */
-enum {
-	VIRTIO_SND_PCM_RATE_5512 = 0,
-	VIRTIO_SND_PCM_RATE_8000,
-	VIRTIO_SND_PCM_RATE_11025,
-	VIRTIO_SND_PCM_RATE_16000,
-	VIRTIO_SND_PCM_RATE_22050,
-	VIRTIO_SND_PCM_RATE_32000,
-	VIRTIO_SND_PCM_RATE_44100,
-	VIRTIO_SND_PCM_RATE_48000,
-	VIRTIO_SND_PCM_RATE_64000,
-	VIRTIO_SND_PCM_RATE_88200,
-	VIRTIO_SND_PCM_RATE_96000,
-	VIRTIO_SND_PCM_RATE_176400,
-	VIRTIO_SND_PCM_RATE_192000,
-	VIRTIO_SND_PCM_RATE_384000
-};
-
-struct virtio_snd_pcm_info {
-	/* common header */
-	struct virtio_snd_info hdr;
-	/* supported feature bit map (1 << VIRTIO_SND_PCM_F_XXX) */
-	uint32_t features;
-	/* supported sample format bit map (1 << VIRTIO_SND_PCM_FMT_XXX) */
-	uint64_t formats;
-	/* supported frame rate bit map (1 << VIRTIO_SND_PCM_RATE_XXX) */
-	uint64_t rates;
-	/* dataflow direction (VIRTIO_SND_D_XXX) */
-	uint8_t direction;
-	/* minimum # of supported channels */
-	uint8_t channels_min;
-	/* maximum # of supported channels */
-	uint8_t channels_max;
-
-	uint8_t padding[5];
-};
-
-/* set PCM stream format */
-struct virtio_snd_pcm_set_params {
-	/* .code = VIRTIO_SND_R_PCM_SET_PARAMS */
-	struct virtio_snd_pcm_hdr hdr;
-	/* size of the hardware buffer */
-	uint32_t buffer_bytes;
-	/* size of the hardware period */
-	uint32_t period_bytes;
-	/* selected feature bit map (1 << VIRTIO_SND_PCM_F_XXX) */
-	uint32_t features;
-	/* selected # of channels */
-	uint8_t channels;
-	/* selected sample format (VIRTIO_SND_PCM_FMT_XXX) */
-	uint8_t format;
-	/* selected frame rate (VIRTIO_SND_PCM_RATE_XXX) */
-	uint8_t rate;
-
-	uint8_t padding;
-};
-
-/*******************************************************************************
- * PCM I/O MESSAGES
- */
-
-/* I/O request header */
-struct virtio_snd_pcm_xfer {
-	/* 0 ... virtio_snd_config::streams - 1 */
-	uint32_t stream_id;
-};
-
-/* I/O request status */
-struct virtio_snd_pcm_status {
-	/* VIRTIO_SND_S_XXX */
-	uint32_t status;
-	/* current device latency */
-	uint32_t latency_bytes;
-};
-
-/*******************************************************************************
- * CHANNEL MAP CONTROL MESSAGES
- */
-struct virtio_snd_chmap_hdr {
-	/* VIRTIO_SND_R_CHMAP_XXX */
-	struct virtio_snd_hdr hdr;
-	/* 0 ... virtio_snd_config::chmaps - 1 */
-	uint32_t chmap_id;
-};
-
-/* standard channel position definition */
-enum {
-	VIRTIO_SND_CHMAP_NONE = 0,	/* undefined */
-	VIRTIO_SND_CHMAP_NA,		/* silent */
-	VIRTIO_SND_CHMAP_MONO,		/* mono stream */
-	VIRTIO_SND_CHMAP_FL,		/* front left */
-	VIRTIO_SND_CHMAP_FR,		/* front right */
-	VIRTIO_SND_CHMAP_RL,		/* rear left */
-	VIRTIO_SND_CHMAP_RR,		/* rear right */
-	VIRTIO_SND_CHMAP_FC,		/* front center */
-	VIRTIO_SND_CHMAP_LFE,		/* low frequency (LFE) */
-	VIRTIO_SND_CHMAP_SL,		/* side left */
-	VIRTIO_SND_CHMAP_SR,		/* side right */
-	VIRTIO_SND_CHMAP_RC,		/* rear center */
-	VIRTIO_SND_CHMAP_FLC,		/* front left center */
-	VIRTIO_SND_CHMAP_FRC,		/* front right center */
-	VIRTIO_SND_CHMAP_RLC,		/* rear left center */
-	VIRTIO_SND_CHMAP_RRC,		/* rear right center */
-	VIRTIO_SND_CHMAP_FLW,		/* front left wide */
-	VIRTIO_SND_CHMAP_FRW,		/* front right wide */
-	VIRTIO_SND_CHMAP_FLH,		/* front left high */
-	VIRTIO_SND_CHMAP_FCH,		/* front center high */
-	VIRTIO_SND_CHMAP_FRH,		/* front right high */
-	VIRTIO_SND_CHMAP_TC,		/* top center */
-	VIRTIO_SND_CHMAP_TFL,		/* top front left */
-	VIRTIO_SND_CHMAP_TFR,		/* top front right */
-	VIRTIO_SND_CHMAP_TFC,		/* top front center */
-	VIRTIO_SND_CHMAP_TRL,		/* top rear left */
-	VIRTIO_SND_CHMAP_TRR,		/* top rear right */
-	VIRTIO_SND_CHMAP_TRC,		/* top rear center */
-	VIRTIO_SND_CHMAP_TFLC,		/* top front left center */
-	VIRTIO_SND_CHMAP_TFRC,		/* top front right center */
-	VIRTIO_SND_CHMAP_TSL,		/* top side left */
-	VIRTIO_SND_CHMAP_TSR,		/* top side right */
-	VIRTIO_SND_CHMAP_LLFE,		/* left LFE */
-	VIRTIO_SND_CHMAP_RLFE,		/* right LFE */
-	VIRTIO_SND_CHMAP_BC,		/* bottom center */
-	VIRTIO_SND_CHMAP_BLC,		/* bottom left center */
-	VIRTIO_SND_CHMAP_BRC		/* bottom right center */
-};
-
-/* maximum possible number of channels */
-#define VIRTIO_SND_CHMAP_MAX_SIZE	18
-
-struct virtio_snd_chmap_info {
-	/* common header */
-	struct virtio_snd_info hdr;
-	/* dataflow direction (VIRTIO_SND_D_XXX) */
-	uint8_t direction;
-	/* # of valid channel position values */
-	uint8_t channels;
-	/* channel position values (VIRTIO_SND_CHMAP_XXX) */
-	uint8_t positions[VIRTIO_SND_CHMAP_MAX_SIZE];
-};
-
-#endif /* VIRTIO_SND_IF_H */
diff --git a/include/standard-headers/rdma/vmw_pvrdma-abi.h b/include/standard-headers/rdma/vmw_pvrdma-abi.h
index c30182a7ae..0989426a3f 100644
--- a/include/standard-headers/rdma/vmw_pvrdma-abi.h
+++ b/include/standard-headers/rdma/vmw_pvrdma-abi.h
@@ -133,13 +133,6 @@ enum pvrdma_wc_flags {
 	PVRDMA_WC_FLAGS_MAX		= PVRDMA_WC_WITH_NETWORK_HDR_TYPE,
 };
 
-enum pvrdma_network_type {
-	PVRDMA_NETWORK_IB,
-	PVRDMA_NETWORK_ROCE_V1 = PVRDMA_NETWORK_IB,
-	PVRDMA_NETWORK_IPV4,
-	PVRDMA_NETWORK_IPV6
-};
-
 struct pvrdma_alloc_ucontext_resp {
 	uint32_t qp_tab_size;
 	uint32_t reserved;
diff --git a/include/user/syscall-trace.h b/include/user/syscall-trace.h
index 42e3b48b03..614cfacfa5 100644
--- a/include/user/syscall-trace.h
+++ b/include/user/syscall-trace.h
@@ -7,8 +7,8 @@
  * SPDX-License-Identifier: GPL-2.0-or-later
  */
 
-#ifndef _SYSCALL_TRACE_H_
-#define _SYSCALL_TRACE_H_
+#ifndef SYSCALL_TRACE_H
+#define SYSCALL_TRACE_H
 
 #include "trace/trace-root.h"
 
diff --git a/iothread.c b/iothread.c
index 2c5ccd7367..7f086387be 100644
--- a/iothread.c
+++ b/iothread.c
@@ -39,6 +39,13 @@ DECLARE_CLASS_CHECKERS(IOThreadClass, IOTHREAD,
 #define IOTHREAD_POLL_MAX_NS_DEFAULT 0ULL
 #endif
 
+static __thread IOThread *my_iothread;
+
+AioContext *qemu_get_current_aio_context(void)
+{
+    return my_iothread ? my_iothread->ctx : qemu_get_aio_context();
+}
+
 static void *iothread_run(void *opaque)
 {
     IOThread *iothread = opaque;
@@ -49,7 +56,7 @@ static void *iothread_run(void *opaque)
      * in this new thread uses glib.
      */
     g_main_context_push_thread_default(iothread->worker_context);
-    qemu_set_current_aio_context(iothread->ctx);
+    my_iothread = iothread;
     iothread->thread_id = qemu_get_thread_id();
     qemu_sem_post(&iothread->init_done_sem);
 
diff --git a/linux-headers/asm-generic/unistd.h b/linux-headers/asm-generic/unistd.h
index 6de5a7fc06..7287529177 100644
--- a/linux-headers/asm-generic/unistd.h
+++ b/linux-headers/asm-generic/unistd.h
@@ -861,20 +861,9 @@ __SYSCALL(__NR_faccessat2, sys_faccessat2)
 __SYSCALL(__NR_process_madvise, sys_process_madvise)
 #define __NR_epoll_pwait2 441
 __SC_COMP(__NR_epoll_pwait2, sys_epoll_pwait2, compat_sys_epoll_pwait2)
-#define __NR_mount_setattr 442
-__SYSCALL(__NR_mount_setattr, sys_mount_setattr)
-#define __NR_quotactl_path 443
-__SYSCALL(__NR_quotactl_path, sys_quotactl_path)
-
-#define __NR_landlock_create_ruleset 444
-__SYSCALL(__NR_landlock_create_ruleset, sys_landlock_create_ruleset)
-#define __NR_landlock_add_rule 445
-__SYSCALL(__NR_landlock_add_rule, sys_landlock_add_rule)
-#define __NR_landlock_restrict_self 446
-__SYSCALL(__NR_landlock_restrict_self, sys_landlock_restrict_self)
 
 #undef __NR_syscalls
-#define __NR_syscalls 447
+#define __NR_syscalls 442
 
 /*
  * 32 bit systems traditionally used different
diff --git a/linux-headers/asm-mips/unistd_n32.h b/linux-headers/asm-mips/unistd_n32.h
index fce51fee09..59e53b6e07 100644
--- a/linux-headers/asm-mips/unistd_n32.h
+++ b/linux-headers/asm-mips/unistd_n32.h
@@ -1,379 +1,376 @@
-#ifndef _ASM_UNISTD_N32_H
-#define _ASM_UNISTD_N32_H
+#ifndef _ASM_MIPS_UNISTD_N32_H
+#define _ASM_MIPS_UNISTD_N32_H
 
-#define __NR_read (__NR_Linux + 0)
-#define __NR_write (__NR_Linux + 1)
-#define __NR_open (__NR_Linux + 2)
-#define __NR_close (__NR_Linux + 3)
-#define __NR_stat (__NR_Linux + 4)
-#define __NR_fstat (__NR_Linux + 5)
-#define __NR_lstat (__NR_Linux + 6)
-#define __NR_poll (__NR_Linux + 7)
-#define __NR_lseek (__NR_Linux + 8)
-#define __NR_mmap (__NR_Linux + 9)
-#define __NR_mprotect (__NR_Linux + 10)
-#define __NR_munmap (__NR_Linux + 11)
-#define __NR_brk (__NR_Linux + 12)
-#define __NR_rt_sigaction (__NR_Linux + 13)
-#define __NR_rt_sigprocmask (__NR_Linux + 14)
-#define __NR_ioctl (__NR_Linux + 15)
-#define __NR_pread64 (__NR_Linux + 16)
-#define __NR_pwrite64 (__NR_Linux + 17)
-#define __NR_readv (__NR_Linux + 18)
-#define __NR_writev (__NR_Linux + 19)
-#define __NR_access (__NR_Linux + 20)
-#define __NR_pipe (__NR_Linux + 21)
-#define __NR__newselect (__NR_Linux + 22)
-#define __NR_sched_yield (__NR_Linux + 23)
-#define __NR_mremap (__NR_Linux + 24)
-#define __NR_msync (__NR_Linux + 25)
-#define __NR_mincore (__NR_Linux + 26)
-#define __NR_madvise (__NR_Linux + 27)
-#define __NR_shmget (__NR_Linux + 28)
-#define __NR_shmat (__NR_Linux + 29)
-#define __NR_shmctl (__NR_Linux + 30)
-#define __NR_dup (__NR_Linux + 31)
-#define __NR_dup2 (__NR_Linux + 32)
-#define __NR_pause (__NR_Linux + 33)
-#define __NR_nanosleep (__NR_Linux + 34)
-#define __NR_getitimer (__NR_Linux + 35)
-#define __NR_setitimer (__NR_Linux + 36)
-#define __NR_alarm (__NR_Linux + 37)
-#define __NR_getpid (__NR_Linux + 38)
-#define __NR_sendfile (__NR_Linux + 39)
-#define __NR_socket (__NR_Linux + 40)
-#define __NR_connect (__NR_Linux + 41)
-#define __NR_accept (__NR_Linux + 42)
-#define __NR_sendto (__NR_Linux + 43)
-#define __NR_recvfrom (__NR_Linux + 44)
-#define __NR_sendmsg (__NR_Linux + 45)
-#define __NR_recvmsg (__NR_Linux + 46)
-#define __NR_shutdown (__NR_Linux + 47)
-#define __NR_bind (__NR_Linux + 48)
-#define __NR_listen (__NR_Linux + 49)
-#define __NR_getsockname (__NR_Linux + 50)
-#define __NR_getpeername (__NR_Linux + 51)
-#define __NR_socketpair (__NR_Linux + 52)
-#define __NR_setsockopt (__NR_Linux + 53)
-#define __NR_getsockopt (__NR_Linux + 54)
-#define __NR_clone (__NR_Linux + 55)
-#define __NR_fork (__NR_Linux + 56)
-#define __NR_execve (__NR_Linux + 57)
-#define __NR_exit (__NR_Linux + 58)
-#define __NR_wait4 (__NR_Linux + 59)
-#define __NR_kill (__NR_Linux + 60)
-#define __NR_uname (__NR_Linux + 61)
-#define __NR_semget (__NR_Linux + 62)
-#define __NR_semop (__NR_Linux + 63)
-#define __NR_semctl (__NR_Linux + 64)
-#define __NR_shmdt (__NR_Linux + 65)
-#define __NR_msgget (__NR_Linux + 66)
-#define __NR_msgsnd (__NR_Linux + 67)
-#define __NR_msgrcv (__NR_Linux + 68)
-#define __NR_msgctl (__NR_Linux + 69)
-#define __NR_fcntl (__NR_Linux + 70)
-#define __NR_flock (__NR_Linux + 71)
-#define __NR_fsync (__NR_Linux + 72)
-#define __NR_fdatasync (__NR_Linux + 73)
-#define __NR_truncate (__NR_Linux + 74)
-#define __NR_ftruncate (__NR_Linux + 75)
-#define __NR_getdents (__NR_Linux + 76)
-#define __NR_getcwd (__NR_Linux + 77)
-#define __NR_chdir (__NR_Linux + 78)
-#define __NR_fchdir (__NR_Linux + 79)
-#define __NR_rename (__NR_Linux + 80)
-#define __NR_mkdir (__NR_Linux + 81)
-#define __NR_rmdir (__NR_Linux + 82)
-#define __NR_creat (__NR_Linux + 83)
-#define __NR_link (__NR_Linux + 84)
-#define __NR_unlink (__NR_Linux + 85)
-#define __NR_symlink (__NR_Linux + 86)
-#define __NR_readlink (__NR_Linux + 87)
-#define __NR_chmod (__NR_Linux + 88)
-#define __NR_fchmod (__NR_Linux + 89)
-#define __NR_chown (__NR_Linux + 90)
-#define __NR_fchown (__NR_Linux + 91)
-#define __NR_lchown (__NR_Linux + 92)
-#define __NR_umask (__NR_Linux + 93)
-#define __NR_gettimeofday (__NR_Linux + 94)
-#define __NR_getrlimit (__NR_Linux + 95)
-#define __NR_getrusage (__NR_Linux + 96)
-#define __NR_sysinfo (__NR_Linux + 97)
-#define __NR_times (__NR_Linux + 98)
-#define __NR_ptrace (__NR_Linux + 99)
-#define __NR_getuid (__NR_Linux + 100)
-#define __NR_syslog (__NR_Linux + 101)
-#define __NR_getgid (__NR_Linux + 102)
-#define __NR_setuid (__NR_Linux + 103)
-#define __NR_setgid (__NR_Linux + 104)
-#define __NR_geteuid (__NR_Linux + 105)
-#define __NR_getegid (__NR_Linux + 106)
-#define __NR_setpgid (__NR_Linux + 107)
-#define __NR_getppid (__NR_Linux + 108)
-#define __NR_getpgrp (__NR_Linux + 109)
-#define __NR_setsid (__NR_Linux + 110)
-#define __NR_setreuid (__NR_Linux + 111)
-#define __NR_setregid (__NR_Linux + 112)
-#define __NR_getgroups (__NR_Linux + 113)
-#define __NR_setgroups (__NR_Linux + 114)
-#define __NR_setresuid (__NR_Linux + 115)
-#define __NR_getresuid (__NR_Linux + 116)
-#define __NR_setresgid (__NR_Linux + 117)
-#define __NR_getresgid (__NR_Linux + 118)
-#define __NR_getpgid (__NR_Linux + 119)
-#define __NR_setfsuid (__NR_Linux + 120)
-#define __NR_setfsgid (__NR_Linux + 121)
-#define __NR_getsid (__NR_Linux + 122)
-#define __NR_capget (__NR_Linux + 123)
-#define __NR_capset (__NR_Linux + 124)
-#define __NR_rt_sigpending (__NR_Linux + 125)
-#define __NR_rt_sigtimedwait (__NR_Linux + 126)
-#define __NR_rt_sigqueueinfo (__NR_Linux + 127)
-#define __NR_rt_sigsuspend (__NR_Linux + 128)
-#define __NR_sigaltstack (__NR_Linux + 129)
-#define __NR_utime (__NR_Linux + 130)
-#define __NR_mknod (__NR_Linux + 131)
-#define __NR_personality (__NR_Linux + 132)
-#define __NR_ustat (__NR_Linux + 133)
-#define __NR_statfs (__NR_Linux + 134)
-#define __NR_fstatfs (__NR_Linux + 135)
-#define __NR_sysfs (__NR_Linux + 136)
-#define __NR_getpriority (__NR_Linux + 137)
-#define __NR_setpriority (__NR_Linux + 138)
-#define __NR_sched_setparam (__NR_Linux + 139)
-#define __NR_sched_getparam (__NR_Linux + 140)
-#define __NR_sched_setscheduler (__NR_Linux + 141)
-#define __NR_sched_getscheduler (__NR_Linux + 142)
-#define __NR_sched_get_priority_max (__NR_Linux + 143)
-#define __NR_sched_get_priority_min (__NR_Linux + 144)
-#define __NR_sched_rr_get_interval (__NR_Linux + 145)
-#define __NR_mlock (__NR_Linux + 146)
-#define __NR_munlock (__NR_Linux + 147)
-#define __NR_mlockall (__NR_Linux + 148)
-#define __NR_munlockall (__NR_Linux + 149)
-#define __NR_vhangup (__NR_Linux + 150)
-#define __NR_pivot_root (__NR_Linux + 151)
-#define __NR__sysctl (__NR_Linux + 152)
-#define __NR_prctl (__NR_Linux + 153)
-#define __NR_adjtimex (__NR_Linux + 154)
-#define __NR_setrlimit (__NR_Linux + 155)
-#define __NR_chroot (__NR_Linux + 156)
-#define __NR_sync (__NR_Linux + 157)
-#define __NR_acct (__NR_Linux + 158)
-#define __NR_settimeofday (__NR_Linux + 159)
-#define __NR_mount (__NR_Linux + 160)
-#define __NR_umount2 (__NR_Linux + 161)
-#define __NR_swapon (__NR_Linux + 162)
-#define __NR_swapoff (__NR_Linux + 163)
-#define __NR_reboot (__NR_Linux + 164)
-#define __NR_sethostname (__NR_Linux + 165)
-#define __NR_setdomainname (__NR_Linux + 166)
-#define __NR_create_module (__NR_Linux + 167)
-#define __NR_init_module (__NR_Linux + 168)
-#define __NR_delete_module (__NR_Linux + 169)
-#define __NR_get_kernel_syms (__NR_Linux + 170)
-#define __NR_query_module (__NR_Linux + 171)
-#define __NR_quotactl (__NR_Linux + 172)
-#define __NR_nfsservctl (__NR_Linux + 173)
-#define __NR_getpmsg (__NR_Linux + 174)
-#define __NR_putpmsg (__NR_Linux + 175)
-#define __NR_afs_syscall (__NR_Linux + 176)
-#define __NR_reserved177 (__NR_Linux + 177)
-#define __NR_gettid (__NR_Linux + 178)
-#define __NR_readahead (__NR_Linux + 179)
-#define __NR_setxattr (__NR_Linux + 180)
-#define __NR_lsetxattr (__NR_Linux + 181)
-#define __NR_fsetxattr (__NR_Linux + 182)
-#define __NR_getxattr (__NR_Linux + 183)
-#define __NR_lgetxattr (__NR_Linux + 184)
-#define __NR_fgetxattr (__NR_Linux + 185)
-#define __NR_listxattr (__NR_Linux + 186)
-#define __NR_llistxattr (__NR_Linux + 187)
-#define __NR_flistxattr (__NR_Linux + 188)
-#define __NR_removexattr (__NR_Linux + 189)
-#define __NR_lremovexattr (__NR_Linux + 190)
-#define __NR_fremovexattr (__NR_Linux + 191)
-#define __NR_tkill (__NR_Linux + 192)
-#define __NR_reserved193 (__NR_Linux + 193)
-#define __NR_futex (__NR_Linux + 194)
-#define __NR_sched_setaffinity (__NR_Linux + 195)
-#define __NR_sched_getaffinity (__NR_Linux + 196)
-#define __NR_cacheflush (__NR_Linux + 197)
-#define __NR_cachectl (__NR_Linux + 198)
-#define __NR_sysmips (__NR_Linux + 199)
-#define __NR_io_setup (__NR_Linux + 200)
-#define __NR_io_destroy (__NR_Linux + 201)
-#define __NR_io_getevents (__NR_Linux + 202)
-#define __NR_io_submit (__NR_Linux + 203)
-#define __NR_io_cancel (__NR_Linux + 204)
-#define __NR_exit_group (__NR_Linux + 205)
-#define __NR_lookup_dcookie (__NR_Linux + 206)
-#define __NR_epoll_create (__NR_Linux + 207)
-#define __NR_epoll_ctl (__NR_Linux + 208)
-#define __NR_epoll_wait (__NR_Linux + 209)
-#define __NR_remap_file_pages (__NR_Linux + 210)
-#define __NR_rt_sigreturn (__NR_Linux + 211)
-#define __NR_fcntl64 (__NR_Linux + 212)
-#define __NR_set_tid_address (__NR_Linux + 213)
-#define __NR_restart_syscall (__NR_Linux + 214)
-#define __NR_semtimedop (__NR_Linux + 215)
-#define __NR_fadvise64 (__NR_Linux + 216)
-#define __NR_statfs64 (__NR_Linux + 217)
-#define __NR_fstatfs64 (__NR_Linux + 218)
-#define __NR_sendfile64 (__NR_Linux + 219)
-#define __NR_timer_create (__NR_Linux + 220)
-#define __NR_timer_settime (__NR_Linux + 221)
-#define __NR_timer_gettime (__NR_Linux + 222)
-#define __NR_timer_getoverrun (__NR_Linux + 223)
-#define __NR_timer_delete (__NR_Linux + 224)
-#define __NR_clock_settime (__NR_Linux + 225)
-#define __NR_clock_gettime (__NR_Linux + 226)
-#define __NR_clock_getres (__NR_Linux + 227)
-#define __NR_clock_nanosleep (__NR_Linux + 228)
-#define __NR_tgkill (__NR_Linux + 229)
-#define __NR_utimes (__NR_Linux + 230)
-#define __NR_mbind (__NR_Linux + 231)
-#define __NR_get_mempolicy (__NR_Linux + 232)
-#define __NR_set_mempolicy (__NR_Linux + 233)
-#define __NR_mq_open (__NR_Linux + 234)
-#define __NR_mq_unlink (__NR_Linux + 235)
-#define __NR_mq_timedsend (__NR_Linux + 236)
-#define __NR_mq_timedreceive (__NR_Linux + 237)
-#define __NR_mq_notify (__NR_Linux + 238)
-#define __NR_mq_getsetattr (__NR_Linux + 239)
-#define __NR_vserver (__NR_Linux + 240)
-#define __NR_waitid (__NR_Linux + 241)
-#define __NR_add_key (__NR_Linux + 243)
-#define __NR_request_key (__NR_Linux + 244)
-#define __NR_keyctl (__NR_Linux + 245)
-#define __NR_set_thread_area (__NR_Linux + 246)
-#define __NR_inotify_init (__NR_Linux + 247)
-#define __NR_inotify_add_watch (__NR_Linux + 248)
-#define __NR_inotify_rm_watch (__NR_Linux + 249)
-#define __NR_migrate_pages (__NR_Linux + 250)
-#define __NR_openat (__NR_Linux + 251)
-#define __NR_mkdirat (__NR_Linux + 252)
-#define __NR_mknodat (__NR_Linux + 253)
-#define __NR_fchownat (__NR_Linux + 254)
-#define __NR_futimesat (__NR_Linux + 255)
-#define __NR_newfstatat (__NR_Linux + 256)
-#define __NR_unlinkat (__NR_Linux + 257)
-#define __NR_renameat (__NR_Linux + 258)
-#define __NR_linkat (__NR_Linux + 259)
-#define __NR_symlinkat (__NR_Linux + 260)
-#define __NR_readlinkat (__NR_Linux + 261)
-#define __NR_fchmodat (__NR_Linux + 262)
-#define __NR_faccessat (__NR_Linux + 263)
-#define __NR_pselect6 (__NR_Linux + 264)
-#define __NR_ppoll (__NR_Linux + 265)
-#define __NR_unshare (__NR_Linux + 266)
-#define __NR_splice (__NR_Linux + 267)
-#define __NR_sync_file_range (__NR_Linux + 268)
-#define __NR_tee (__NR_Linux + 269)
-#define __NR_vmsplice (__NR_Linux + 270)
-#define __NR_move_pages (__NR_Linux + 271)
-#define __NR_set_robust_list (__NR_Linux + 272)
-#define __NR_get_robust_list (__NR_Linux + 273)
-#define __NR_kexec_load (__NR_Linux + 274)
-#define __NR_getcpu (__NR_Linux + 275)
-#define __NR_epoll_pwait (__NR_Linux + 276)
-#define __NR_ioprio_set (__NR_Linux + 277)
-#define __NR_ioprio_get (__NR_Linux + 278)
-#define __NR_utimensat (__NR_Linux + 279)
-#define __NR_signalfd (__NR_Linux + 280)
-#define __NR_timerfd (__NR_Linux + 281)
-#define __NR_eventfd (__NR_Linux + 282)
-#define __NR_fallocate (__NR_Linux + 283)
-#define __NR_timerfd_create (__NR_Linux + 284)
-#define __NR_timerfd_gettime (__NR_Linux + 285)
-#define __NR_timerfd_settime (__NR_Linux + 286)
-#define __NR_signalfd4 (__NR_Linux + 287)
-#define __NR_eventfd2 (__NR_Linux + 288)
-#define __NR_epoll_create1 (__NR_Linux + 289)
-#define __NR_dup3 (__NR_Linux + 290)
-#define __NR_pipe2 (__NR_Linux + 291)
-#define __NR_inotify_init1 (__NR_Linux + 292)
-#define __NR_preadv (__NR_Linux + 293)
-#define __NR_pwritev (__NR_Linux + 294)
-#define __NR_rt_tgsigqueueinfo (__NR_Linux + 295)
-#define __NR_perf_event_open (__NR_Linux + 296)
-#define __NR_accept4 (__NR_Linux + 297)
-#define __NR_recvmmsg (__NR_Linux + 298)
-#define __NR_getdents64 (__NR_Linux + 299)
-#define __NR_fanotify_init (__NR_Linux + 300)
-#define __NR_fanotify_mark (__NR_Linux + 301)
-#define __NR_prlimit64 (__NR_Linux + 302)
-#define __NR_name_to_handle_at (__NR_Linux + 303)
-#define __NR_open_by_handle_at (__NR_Linux + 304)
-#define __NR_clock_adjtime (__NR_Linux + 305)
-#define __NR_syncfs (__NR_Linux + 306)
-#define __NR_sendmmsg (__NR_Linux + 307)
-#define __NR_setns (__NR_Linux + 308)
-#define __NR_process_vm_readv (__NR_Linux + 309)
-#define __NR_process_vm_writev (__NR_Linux + 310)
-#define __NR_kcmp (__NR_Linux + 311)
-#define __NR_finit_module (__NR_Linux + 312)
-#define __NR_sched_setattr (__NR_Linux + 313)
-#define __NR_sched_getattr (__NR_Linux + 314)
-#define __NR_renameat2 (__NR_Linux + 315)
-#define __NR_seccomp (__NR_Linux + 316)
-#define __NR_getrandom (__NR_Linux + 317)
-#define __NR_memfd_create (__NR_Linux + 318)
-#define __NR_bpf (__NR_Linux + 319)
-#define __NR_execveat (__NR_Linux + 320)
-#define __NR_userfaultfd (__NR_Linux + 321)
-#define __NR_membarrier (__NR_Linux + 322)
-#define __NR_mlock2 (__NR_Linux + 323)
-#define __NR_copy_file_range (__NR_Linux + 324)
-#define __NR_preadv2 (__NR_Linux + 325)
-#define __NR_pwritev2 (__NR_Linux + 326)
-#define __NR_pkey_mprotect (__NR_Linux + 327)
-#define __NR_pkey_alloc (__NR_Linux + 328)
-#define __NR_pkey_free (__NR_Linux + 329)
-#define __NR_statx (__NR_Linux + 330)
-#define __NR_rseq (__NR_Linux + 331)
-#define __NR_io_pgetevents (__NR_Linux + 332)
-#define __NR_clock_gettime64 (__NR_Linux + 403)
-#define __NR_clock_settime64 (__NR_Linux + 404)
-#define __NR_clock_adjtime64 (__NR_Linux + 405)
-#define __NR_clock_getres_time64 (__NR_Linux + 406)
-#define __NR_clock_nanosleep_time64 (__NR_Linux + 407)
-#define __NR_timer_gettime64 (__NR_Linux + 408)
-#define __NR_timer_settime64 (__NR_Linux + 409)
-#define __NR_timerfd_gettime64 (__NR_Linux + 410)
-#define __NR_timerfd_settime64 (__NR_Linux + 411)
-#define __NR_utimensat_time64 (__NR_Linux + 412)
-#define __NR_pselect6_time64 (__NR_Linux + 413)
-#define __NR_ppoll_time64 (__NR_Linux + 414)
-#define __NR_io_pgetevents_time64 (__NR_Linux + 416)
-#define __NR_recvmmsg_time64 (__NR_Linux + 417)
-#define __NR_mq_timedsend_time64 (__NR_Linux + 418)
-#define __NR_mq_timedreceive_time64 (__NR_Linux + 419)
-#define __NR_semtimedop_time64 (__NR_Linux + 420)
-#define __NR_rt_sigtimedwait_time64 (__NR_Linux + 421)
-#define __NR_futex_time64 (__NR_Linux + 422)
-#define __NR_sched_rr_get_interval_time64 (__NR_Linux + 423)
-#define __NR_pidfd_send_signal (__NR_Linux + 424)
-#define __NR_io_uring_setup (__NR_Linux + 425)
-#define __NR_io_uring_enter (__NR_Linux + 426)
-#define __NR_io_uring_register (__NR_Linux + 427)
-#define __NR_open_tree (__NR_Linux + 428)
-#define __NR_move_mount (__NR_Linux + 429)
-#define __NR_fsopen (__NR_Linux + 430)
-#define __NR_fsconfig (__NR_Linux + 431)
-#define __NR_fsmount (__NR_Linux + 432)
-#define __NR_fspick (__NR_Linux + 433)
-#define __NR_pidfd_open (__NR_Linux + 434)
-#define __NR_clone3 (__NR_Linux + 435)
-#define __NR_close_range (__NR_Linux + 436)
-#define __NR_openat2 (__NR_Linux + 437)
-#define __NR_pidfd_getfd (__NR_Linux + 438)
-#define __NR_faccessat2 (__NR_Linux + 439)
-#define __NR_process_madvise (__NR_Linux + 440)
-#define __NR_epoll_pwait2 (__NR_Linux + 441)
-#define __NR_mount_setattr (__NR_Linux + 442)
-#define __NR_landlock_create_ruleset (__NR_Linux + 444)
-#define __NR_landlock_add_rule (__NR_Linux + 445)
-#define __NR_landlock_restrict_self (__NR_Linux + 446)
+#define __NR_read	(__NR_Linux + 0)
+#define __NR_write	(__NR_Linux + 1)
+#define __NR_open	(__NR_Linux + 2)
+#define __NR_close	(__NR_Linux + 3)
+#define __NR_stat	(__NR_Linux + 4)
+#define __NR_fstat	(__NR_Linux + 5)
+#define __NR_lstat	(__NR_Linux + 6)
+#define __NR_poll	(__NR_Linux + 7)
+#define __NR_lseek	(__NR_Linux + 8)
+#define __NR_mmap	(__NR_Linux + 9)
+#define __NR_mprotect	(__NR_Linux + 10)
+#define __NR_munmap	(__NR_Linux + 11)
+#define __NR_brk	(__NR_Linux + 12)
+#define __NR_rt_sigaction	(__NR_Linux + 13)
+#define __NR_rt_sigprocmask	(__NR_Linux + 14)
+#define __NR_ioctl	(__NR_Linux + 15)
+#define __NR_pread64	(__NR_Linux + 16)
+#define __NR_pwrite64	(__NR_Linux + 17)
+#define __NR_readv	(__NR_Linux + 18)
+#define __NR_writev	(__NR_Linux + 19)
+#define __NR_access	(__NR_Linux + 20)
+#define __NR_pipe	(__NR_Linux + 21)
+#define __NR__newselect	(__NR_Linux + 22)
+#define __NR_sched_yield	(__NR_Linux + 23)
+#define __NR_mremap	(__NR_Linux + 24)
+#define __NR_msync	(__NR_Linux + 25)
+#define __NR_mincore	(__NR_Linux + 26)
+#define __NR_madvise	(__NR_Linux + 27)
+#define __NR_shmget	(__NR_Linux + 28)
+#define __NR_shmat	(__NR_Linux + 29)
+#define __NR_shmctl	(__NR_Linux + 30)
+#define __NR_dup	(__NR_Linux + 31)
+#define __NR_dup2	(__NR_Linux + 32)
+#define __NR_pause	(__NR_Linux + 33)
+#define __NR_nanosleep	(__NR_Linux + 34)
+#define __NR_getitimer	(__NR_Linux + 35)
+#define __NR_setitimer	(__NR_Linux + 36)
+#define __NR_alarm	(__NR_Linux + 37)
+#define __NR_getpid	(__NR_Linux + 38)
+#define __NR_sendfile	(__NR_Linux + 39)
+#define __NR_socket	(__NR_Linux + 40)
+#define __NR_connect	(__NR_Linux + 41)
+#define __NR_accept	(__NR_Linux + 42)
+#define __NR_sendto	(__NR_Linux + 43)
+#define __NR_recvfrom	(__NR_Linux + 44)
+#define __NR_sendmsg	(__NR_Linux + 45)
+#define __NR_recvmsg	(__NR_Linux + 46)
+#define __NR_shutdown	(__NR_Linux + 47)
+#define __NR_bind	(__NR_Linux + 48)
+#define __NR_listen	(__NR_Linux + 49)
+#define __NR_getsockname	(__NR_Linux + 50)
+#define __NR_getpeername	(__NR_Linux + 51)
+#define __NR_socketpair	(__NR_Linux + 52)
+#define __NR_setsockopt	(__NR_Linux + 53)
+#define __NR_getsockopt	(__NR_Linux + 54)
+#define __NR_clone	(__NR_Linux + 55)
+#define __NR_fork	(__NR_Linux + 56)
+#define __NR_execve	(__NR_Linux + 57)
+#define __NR_exit	(__NR_Linux + 58)
+#define __NR_wait4	(__NR_Linux + 59)
+#define __NR_kill	(__NR_Linux + 60)
+#define __NR_uname	(__NR_Linux + 61)
+#define __NR_semget	(__NR_Linux + 62)
+#define __NR_semop	(__NR_Linux + 63)
+#define __NR_semctl	(__NR_Linux + 64)
+#define __NR_shmdt	(__NR_Linux + 65)
+#define __NR_msgget	(__NR_Linux + 66)
+#define __NR_msgsnd	(__NR_Linux + 67)
+#define __NR_msgrcv	(__NR_Linux + 68)
+#define __NR_msgctl	(__NR_Linux + 69)
+#define __NR_fcntl	(__NR_Linux + 70)
+#define __NR_flock	(__NR_Linux + 71)
+#define __NR_fsync	(__NR_Linux + 72)
+#define __NR_fdatasync	(__NR_Linux + 73)
+#define __NR_truncate	(__NR_Linux + 74)
+#define __NR_ftruncate	(__NR_Linux + 75)
+#define __NR_getdents	(__NR_Linux + 76)
+#define __NR_getcwd	(__NR_Linux + 77)
+#define __NR_chdir	(__NR_Linux + 78)
+#define __NR_fchdir	(__NR_Linux + 79)
+#define __NR_rename	(__NR_Linux + 80)
+#define __NR_mkdir	(__NR_Linux + 81)
+#define __NR_rmdir	(__NR_Linux + 82)
+#define __NR_creat	(__NR_Linux + 83)
+#define __NR_link	(__NR_Linux + 84)
+#define __NR_unlink	(__NR_Linux + 85)
+#define __NR_symlink	(__NR_Linux + 86)
+#define __NR_readlink	(__NR_Linux + 87)
+#define __NR_chmod	(__NR_Linux + 88)
+#define __NR_fchmod	(__NR_Linux + 89)
+#define __NR_chown	(__NR_Linux + 90)
+#define __NR_fchown	(__NR_Linux + 91)
+#define __NR_lchown	(__NR_Linux + 92)
+#define __NR_umask	(__NR_Linux + 93)
+#define __NR_gettimeofday	(__NR_Linux + 94)
+#define __NR_getrlimit	(__NR_Linux + 95)
+#define __NR_getrusage	(__NR_Linux + 96)
+#define __NR_sysinfo	(__NR_Linux + 97)
+#define __NR_times	(__NR_Linux + 98)
+#define __NR_ptrace	(__NR_Linux + 99)
+#define __NR_getuid	(__NR_Linux + 100)
+#define __NR_syslog	(__NR_Linux + 101)
+#define __NR_getgid	(__NR_Linux + 102)
+#define __NR_setuid	(__NR_Linux + 103)
+#define __NR_setgid	(__NR_Linux + 104)
+#define __NR_geteuid	(__NR_Linux + 105)
+#define __NR_getegid	(__NR_Linux + 106)
+#define __NR_setpgid	(__NR_Linux + 107)
+#define __NR_getppid	(__NR_Linux + 108)
+#define __NR_getpgrp	(__NR_Linux + 109)
+#define __NR_setsid	(__NR_Linux + 110)
+#define __NR_setreuid	(__NR_Linux + 111)
+#define __NR_setregid	(__NR_Linux + 112)
+#define __NR_getgroups	(__NR_Linux + 113)
+#define __NR_setgroups	(__NR_Linux + 114)
+#define __NR_setresuid	(__NR_Linux + 115)
+#define __NR_getresuid	(__NR_Linux + 116)
+#define __NR_setresgid	(__NR_Linux + 117)
+#define __NR_getresgid	(__NR_Linux + 118)
+#define __NR_getpgid	(__NR_Linux + 119)
+#define __NR_setfsuid	(__NR_Linux + 120)
+#define __NR_setfsgid	(__NR_Linux + 121)
+#define __NR_getsid	(__NR_Linux + 122)
+#define __NR_capget	(__NR_Linux + 123)
+#define __NR_capset	(__NR_Linux + 124)
+#define __NR_rt_sigpending	(__NR_Linux + 125)
+#define __NR_rt_sigtimedwait	(__NR_Linux + 126)
+#define __NR_rt_sigqueueinfo	(__NR_Linux + 127)
+#define __NR_rt_sigsuspend	(__NR_Linux + 128)
+#define __NR_sigaltstack	(__NR_Linux + 129)
+#define __NR_utime	(__NR_Linux + 130)
+#define __NR_mknod	(__NR_Linux + 131)
+#define __NR_personality	(__NR_Linux + 132)
+#define __NR_ustat	(__NR_Linux + 133)
+#define __NR_statfs	(__NR_Linux + 134)
+#define __NR_fstatfs	(__NR_Linux + 135)
+#define __NR_sysfs	(__NR_Linux + 136)
+#define __NR_getpriority	(__NR_Linux + 137)
+#define __NR_setpriority	(__NR_Linux + 138)
+#define __NR_sched_setparam	(__NR_Linux + 139)
+#define __NR_sched_getparam	(__NR_Linux + 140)
+#define __NR_sched_setscheduler	(__NR_Linux + 141)
+#define __NR_sched_getscheduler	(__NR_Linux + 142)
+#define __NR_sched_get_priority_max	(__NR_Linux + 143)
+#define __NR_sched_get_priority_min	(__NR_Linux + 144)
+#define __NR_sched_rr_get_interval	(__NR_Linux + 145)
+#define __NR_mlock	(__NR_Linux + 146)
+#define __NR_munlock	(__NR_Linux + 147)
+#define __NR_mlockall	(__NR_Linux + 148)
+#define __NR_munlockall	(__NR_Linux + 149)
+#define __NR_vhangup	(__NR_Linux + 150)
+#define __NR_pivot_root	(__NR_Linux + 151)
+#define __NR__sysctl	(__NR_Linux + 152)
+#define __NR_prctl	(__NR_Linux + 153)
+#define __NR_adjtimex	(__NR_Linux + 154)
+#define __NR_setrlimit	(__NR_Linux + 155)
+#define __NR_chroot	(__NR_Linux + 156)
+#define __NR_sync	(__NR_Linux + 157)
+#define __NR_acct	(__NR_Linux + 158)
+#define __NR_settimeofday	(__NR_Linux + 159)
+#define __NR_mount	(__NR_Linux + 160)
+#define __NR_umount2	(__NR_Linux + 161)
+#define __NR_swapon	(__NR_Linux + 162)
+#define __NR_swapoff	(__NR_Linux + 163)
+#define __NR_reboot	(__NR_Linux + 164)
+#define __NR_sethostname	(__NR_Linux + 165)
+#define __NR_setdomainname	(__NR_Linux + 166)
+#define __NR_create_module	(__NR_Linux + 167)
+#define __NR_init_module	(__NR_Linux + 168)
+#define __NR_delete_module	(__NR_Linux + 169)
+#define __NR_get_kernel_syms	(__NR_Linux + 170)
+#define __NR_query_module	(__NR_Linux + 171)
+#define __NR_quotactl	(__NR_Linux + 172)
+#define __NR_nfsservctl	(__NR_Linux + 173)
+#define __NR_getpmsg	(__NR_Linux + 174)
+#define __NR_putpmsg	(__NR_Linux + 175)
+#define __NR_afs_syscall	(__NR_Linux + 176)
+#define __NR_reserved177	(__NR_Linux + 177)
+#define __NR_gettid	(__NR_Linux + 178)
+#define __NR_readahead	(__NR_Linux + 179)
+#define __NR_setxattr	(__NR_Linux + 180)
+#define __NR_lsetxattr	(__NR_Linux + 181)
+#define __NR_fsetxattr	(__NR_Linux + 182)
+#define __NR_getxattr	(__NR_Linux + 183)
+#define __NR_lgetxattr	(__NR_Linux + 184)
+#define __NR_fgetxattr	(__NR_Linux + 185)
+#define __NR_listxattr	(__NR_Linux + 186)
+#define __NR_llistxattr	(__NR_Linux + 187)
+#define __NR_flistxattr	(__NR_Linux + 188)
+#define __NR_removexattr	(__NR_Linux + 189)
+#define __NR_lremovexattr	(__NR_Linux + 190)
+#define __NR_fremovexattr	(__NR_Linux + 191)
+#define __NR_tkill	(__NR_Linux + 192)
+#define __NR_reserved193	(__NR_Linux + 193)
+#define __NR_futex	(__NR_Linux + 194)
+#define __NR_sched_setaffinity	(__NR_Linux + 195)
+#define __NR_sched_getaffinity	(__NR_Linux + 196)
+#define __NR_cacheflush	(__NR_Linux + 197)
+#define __NR_cachectl	(__NR_Linux + 198)
+#define __NR_sysmips	(__NR_Linux + 199)
+#define __NR_io_setup	(__NR_Linux + 200)
+#define __NR_io_destroy	(__NR_Linux + 201)
+#define __NR_io_getevents	(__NR_Linux + 202)
+#define __NR_io_submit	(__NR_Linux + 203)
+#define __NR_io_cancel	(__NR_Linux + 204)
+#define __NR_exit_group	(__NR_Linux + 205)
+#define __NR_lookup_dcookie	(__NR_Linux + 206)
+#define __NR_epoll_create	(__NR_Linux + 207)
+#define __NR_epoll_ctl	(__NR_Linux + 208)
+#define __NR_epoll_wait	(__NR_Linux + 209)
+#define __NR_remap_file_pages	(__NR_Linux + 210)
+#define __NR_rt_sigreturn	(__NR_Linux + 211)
+#define __NR_fcntl64	(__NR_Linux + 212)
+#define __NR_set_tid_address	(__NR_Linux + 213)
+#define __NR_restart_syscall	(__NR_Linux + 214)
+#define __NR_semtimedop	(__NR_Linux + 215)
+#define __NR_fadvise64	(__NR_Linux + 216)
+#define __NR_statfs64	(__NR_Linux + 217)
+#define __NR_fstatfs64	(__NR_Linux + 218)
+#define __NR_sendfile64	(__NR_Linux + 219)
+#define __NR_timer_create	(__NR_Linux + 220)
+#define __NR_timer_settime	(__NR_Linux + 221)
+#define __NR_timer_gettime	(__NR_Linux + 222)
+#define __NR_timer_getoverrun	(__NR_Linux + 223)
+#define __NR_timer_delete	(__NR_Linux + 224)
+#define __NR_clock_settime	(__NR_Linux + 225)
+#define __NR_clock_gettime	(__NR_Linux + 226)
+#define __NR_clock_getres	(__NR_Linux + 227)
+#define __NR_clock_nanosleep	(__NR_Linux + 228)
+#define __NR_tgkill	(__NR_Linux + 229)
+#define __NR_utimes	(__NR_Linux + 230)
+#define __NR_mbind	(__NR_Linux + 231)
+#define __NR_get_mempolicy	(__NR_Linux + 232)
+#define __NR_set_mempolicy	(__NR_Linux + 233)
+#define __NR_mq_open	(__NR_Linux + 234)
+#define __NR_mq_unlink	(__NR_Linux + 235)
+#define __NR_mq_timedsend	(__NR_Linux + 236)
+#define __NR_mq_timedreceive	(__NR_Linux + 237)
+#define __NR_mq_notify	(__NR_Linux + 238)
+#define __NR_mq_getsetattr	(__NR_Linux + 239)
+#define __NR_vserver	(__NR_Linux + 240)
+#define __NR_waitid	(__NR_Linux + 241)
+#define __NR_add_key	(__NR_Linux + 243)
+#define __NR_request_key	(__NR_Linux + 244)
+#define __NR_keyctl	(__NR_Linux + 245)
+#define __NR_set_thread_area	(__NR_Linux + 246)
+#define __NR_inotify_init	(__NR_Linux + 247)
+#define __NR_inotify_add_watch	(__NR_Linux + 248)
+#define __NR_inotify_rm_watch	(__NR_Linux + 249)
+#define __NR_migrate_pages	(__NR_Linux + 250)
+#define __NR_openat	(__NR_Linux + 251)
+#define __NR_mkdirat	(__NR_Linux + 252)
+#define __NR_mknodat	(__NR_Linux + 253)
+#define __NR_fchownat	(__NR_Linux + 254)
+#define __NR_futimesat	(__NR_Linux + 255)
+#define __NR_newfstatat	(__NR_Linux + 256)
+#define __NR_unlinkat	(__NR_Linux + 257)
+#define __NR_renameat	(__NR_Linux + 258)
+#define __NR_linkat	(__NR_Linux + 259)
+#define __NR_symlinkat	(__NR_Linux + 260)
+#define __NR_readlinkat	(__NR_Linux + 261)
+#define __NR_fchmodat	(__NR_Linux + 262)
+#define __NR_faccessat	(__NR_Linux + 263)
+#define __NR_pselect6	(__NR_Linux + 264)
+#define __NR_ppoll	(__NR_Linux + 265)
+#define __NR_unshare	(__NR_Linux + 266)
+#define __NR_splice	(__NR_Linux + 267)
+#define __NR_sync_file_range	(__NR_Linux + 268)
+#define __NR_tee	(__NR_Linux + 269)
+#define __NR_vmsplice	(__NR_Linux + 270)
+#define __NR_move_pages	(__NR_Linux + 271)
+#define __NR_set_robust_list	(__NR_Linux + 272)
+#define __NR_get_robust_list	(__NR_Linux + 273)
+#define __NR_kexec_load	(__NR_Linux + 274)
+#define __NR_getcpu	(__NR_Linux + 275)
+#define __NR_epoll_pwait	(__NR_Linux + 276)
+#define __NR_ioprio_set	(__NR_Linux + 277)
+#define __NR_ioprio_get	(__NR_Linux + 278)
+#define __NR_utimensat	(__NR_Linux + 279)
+#define __NR_signalfd	(__NR_Linux + 280)
+#define __NR_timerfd	(__NR_Linux + 281)
+#define __NR_eventfd	(__NR_Linux + 282)
+#define __NR_fallocate	(__NR_Linux + 283)
+#define __NR_timerfd_create	(__NR_Linux + 284)
+#define __NR_timerfd_gettime	(__NR_Linux + 285)
+#define __NR_timerfd_settime	(__NR_Linux + 286)
+#define __NR_signalfd4	(__NR_Linux + 287)
+#define __NR_eventfd2	(__NR_Linux + 288)
+#define __NR_epoll_create1	(__NR_Linux + 289)
+#define __NR_dup3	(__NR_Linux + 290)
+#define __NR_pipe2	(__NR_Linux + 291)
+#define __NR_inotify_init1	(__NR_Linux + 292)
+#define __NR_preadv	(__NR_Linux + 293)
+#define __NR_pwritev	(__NR_Linux + 294)
+#define __NR_rt_tgsigqueueinfo	(__NR_Linux + 295)
+#define __NR_perf_event_open	(__NR_Linux + 296)
+#define __NR_accept4	(__NR_Linux + 297)
+#define __NR_recvmmsg	(__NR_Linux + 298)
+#define __NR_getdents64	(__NR_Linux + 299)
+#define __NR_fanotify_init	(__NR_Linux + 300)
+#define __NR_fanotify_mark	(__NR_Linux + 301)
+#define __NR_prlimit64	(__NR_Linux + 302)
+#define __NR_name_to_handle_at	(__NR_Linux + 303)
+#define __NR_open_by_handle_at	(__NR_Linux + 304)
+#define __NR_clock_adjtime	(__NR_Linux + 305)
+#define __NR_syncfs	(__NR_Linux + 306)
+#define __NR_sendmmsg	(__NR_Linux + 307)
+#define __NR_setns	(__NR_Linux + 308)
+#define __NR_process_vm_readv	(__NR_Linux + 309)
+#define __NR_process_vm_writev	(__NR_Linux + 310)
+#define __NR_kcmp	(__NR_Linux + 311)
+#define __NR_finit_module	(__NR_Linux + 312)
+#define __NR_sched_setattr	(__NR_Linux + 313)
+#define __NR_sched_getattr	(__NR_Linux + 314)
+#define __NR_renameat2	(__NR_Linux + 315)
+#define __NR_seccomp	(__NR_Linux + 316)
+#define __NR_getrandom	(__NR_Linux + 317)
+#define __NR_memfd_create	(__NR_Linux + 318)
+#define __NR_bpf	(__NR_Linux + 319)
+#define __NR_execveat	(__NR_Linux + 320)
+#define __NR_userfaultfd	(__NR_Linux + 321)
+#define __NR_membarrier	(__NR_Linux + 322)
+#define __NR_mlock2	(__NR_Linux + 323)
+#define __NR_copy_file_range	(__NR_Linux + 324)
+#define __NR_preadv2	(__NR_Linux + 325)
+#define __NR_pwritev2	(__NR_Linux + 326)
+#define __NR_pkey_mprotect	(__NR_Linux + 327)
+#define __NR_pkey_alloc	(__NR_Linux + 328)
+#define __NR_pkey_free	(__NR_Linux + 329)
+#define __NR_statx	(__NR_Linux + 330)
+#define __NR_rseq	(__NR_Linux + 331)
+#define __NR_io_pgetevents	(__NR_Linux + 332)
+#define __NR_clock_gettime64	(__NR_Linux + 403)
+#define __NR_clock_settime64	(__NR_Linux + 404)
+#define __NR_clock_adjtime64	(__NR_Linux + 405)
+#define __NR_clock_getres_time64	(__NR_Linux + 406)
+#define __NR_clock_nanosleep_time64	(__NR_Linux + 407)
+#define __NR_timer_gettime64	(__NR_Linux + 408)
+#define __NR_timer_settime64	(__NR_Linux + 409)
+#define __NR_timerfd_gettime64	(__NR_Linux + 410)
+#define __NR_timerfd_settime64	(__NR_Linux + 411)
+#define __NR_utimensat_time64	(__NR_Linux + 412)
+#define __NR_pselect6_time64	(__NR_Linux + 413)
+#define __NR_ppoll_time64	(__NR_Linux + 414)
+#define __NR_io_pgetevents_time64	(__NR_Linux + 416)
+#define __NR_recvmmsg_time64	(__NR_Linux + 417)
+#define __NR_mq_timedsend_time64	(__NR_Linux + 418)
+#define __NR_mq_timedreceive_time64	(__NR_Linux + 419)
+#define __NR_semtimedop_time64	(__NR_Linux + 420)
+#define __NR_rt_sigtimedwait_time64	(__NR_Linux + 421)
+#define __NR_futex_time64	(__NR_Linux + 422)
+#define __NR_sched_rr_get_interval_time64	(__NR_Linux + 423)
+#define __NR_pidfd_send_signal	(__NR_Linux + 424)
+#define __NR_io_uring_setup	(__NR_Linux + 425)
+#define __NR_io_uring_enter	(__NR_Linux + 426)
+#define __NR_io_uring_register	(__NR_Linux + 427)
+#define __NR_open_tree	(__NR_Linux + 428)
+#define __NR_move_mount	(__NR_Linux + 429)
+#define __NR_fsopen	(__NR_Linux + 430)
+#define __NR_fsconfig	(__NR_Linux + 431)
+#define __NR_fsmount	(__NR_Linux + 432)
+#define __NR_fspick	(__NR_Linux + 433)
+#define __NR_pidfd_open	(__NR_Linux + 434)
+#define __NR_clone3	(__NR_Linux + 435)
+#define __NR_close_range	(__NR_Linux + 436)
+#define __NR_openat2	(__NR_Linux + 437)
+#define __NR_pidfd_getfd	(__NR_Linux + 438)
+#define __NR_faccessat2	(__NR_Linux + 439)
+#define __NR_process_madvise	(__NR_Linux + 440)
+#define __NR_epoll_pwait2	(__NR_Linux + 441)
 
-#endif /* _ASM_UNISTD_N32_H */
+
+#endif /* _ASM_MIPS_UNISTD_N32_H */
diff --git a/linux-headers/asm-mips/unistd_n64.h b/linux-headers/asm-mips/unistd_n64.h
index 0996001802..683558a7f8 100644
--- a/linux-headers/asm-mips/unistd_n64.h
+++ b/linux-headers/asm-mips/unistd_n64.h
@@ -1,355 +1,352 @@
-#ifndef _ASM_UNISTD_N64_H
-#define _ASM_UNISTD_N64_H
+#ifndef _ASM_MIPS_UNISTD_N64_H
+#define _ASM_MIPS_UNISTD_N64_H
 
-#define __NR_read (__NR_Linux + 0)
-#define __NR_write (__NR_Linux + 1)
-#define __NR_open (__NR_Linux + 2)
-#define __NR_close (__NR_Linux + 3)
-#define __NR_stat (__NR_Linux + 4)
-#define __NR_fstat (__NR_Linux + 5)
-#define __NR_lstat (__NR_Linux + 6)
-#define __NR_poll (__NR_Linux + 7)
-#define __NR_lseek (__NR_Linux + 8)
-#define __NR_mmap (__NR_Linux + 9)
-#define __NR_mprotect (__NR_Linux + 10)
-#define __NR_munmap (__NR_Linux + 11)
-#define __NR_brk (__NR_Linux + 12)
-#define __NR_rt_sigaction (__NR_Linux + 13)
-#define __NR_rt_sigprocmask (__NR_Linux + 14)
-#define __NR_ioctl (__NR_Linux + 15)
-#define __NR_pread64 (__NR_Linux + 16)
-#define __NR_pwrite64 (__NR_Linux + 17)
-#define __NR_readv (__NR_Linux + 18)
-#define __NR_writev (__NR_Linux + 19)
-#define __NR_access (__NR_Linux + 20)
-#define __NR_pipe (__NR_Linux + 21)
-#define __NR__newselect (__NR_Linux + 22)
-#define __NR_sched_yield (__NR_Linux + 23)
-#define __NR_mremap (__NR_Linux + 24)
-#define __NR_msync (__NR_Linux + 25)
-#define __NR_mincore (__NR_Linux + 26)
-#define __NR_madvise (__NR_Linux + 27)
-#define __NR_shmget (__NR_Linux + 28)
-#define __NR_shmat (__NR_Linux + 29)
-#define __NR_shmctl (__NR_Linux + 30)
-#define __NR_dup (__NR_Linux + 31)
-#define __NR_dup2 (__NR_Linux + 32)
-#define __NR_pause (__NR_Linux + 33)
-#define __NR_nanosleep (__NR_Linux + 34)
-#define __NR_getitimer (__NR_Linux + 35)
-#define __NR_setitimer (__NR_Linux + 36)
-#define __NR_alarm (__NR_Linux + 37)
-#define __NR_getpid (__NR_Linux + 38)
-#define __NR_sendfile (__NR_Linux + 39)
-#define __NR_socket (__NR_Linux + 40)
-#define __NR_connect (__NR_Linux + 41)
-#define __NR_accept (__NR_Linux + 42)
-#define __NR_sendto (__NR_Linux + 43)
-#define __NR_recvfrom (__NR_Linux + 44)
-#define __NR_sendmsg (__NR_Linux + 45)
-#define __NR_recvmsg (__NR_Linux + 46)
-#define __NR_shutdown (__NR_Linux + 47)
-#define __NR_bind (__NR_Linux + 48)
-#define __NR_listen (__NR_Linux + 49)
-#define __NR_getsockname (__NR_Linux + 50)
-#define __NR_getpeername (__NR_Linux + 51)
-#define __NR_socketpair (__NR_Linux + 52)
-#define __NR_setsockopt (__NR_Linux + 53)
-#define __NR_getsockopt (__NR_Linux + 54)
-#define __NR_clone (__NR_Linux + 55)
-#define __NR_fork (__NR_Linux + 56)
-#define __NR_execve (__NR_Linux + 57)
-#define __NR_exit (__NR_Linux + 58)
-#define __NR_wait4 (__NR_Linux + 59)
-#define __NR_kill (__NR_Linux + 60)
-#define __NR_uname (__NR_Linux + 61)
-#define __NR_semget (__NR_Linux + 62)
-#define __NR_semop (__NR_Linux + 63)
-#define __NR_semctl (__NR_Linux + 64)
-#define __NR_shmdt (__NR_Linux + 65)
-#define __NR_msgget (__NR_Linux + 66)
-#define __NR_msgsnd (__NR_Linux + 67)
-#define __NR_msgrcv (__NR_Linux + 68)
-#define __NR_msgctl (__NR_Linux + 69)
-#define __NR_fcntl (__NR_Linux + 70)
-#define __NR_flock (__NR_Linux + 71)
-#define __NR_fsync (__NR_Linux + 72)
-#define __NR_fdatasync (__NR_Linux + 73)
-#define __NR_truncate (__NR_Linux + 74)
-#define __NR_ftruncate (__NR_Linux + 75)
-#define __NR_getdents (__NR_Linux + 76)
-#define __NR_getcwd (__NR_Linux + 77)
-#define __NR_chdir (__NR_Linux + 78)
-#define __NR_fchdir (__NR_Linux + 79)
-#define __NR_rename (__NR_Linux + 80)
-#define __NR_mkdir (__NR_Linux + 81)
-#define __NR_rmdir (__NR_Linux + 82)
-#define __NR_creat (__NR_Linux + 83)
-#define __NR_link (__NR_Linux + 84)
-#define __NR_unlink (__NR_Linux + 85)
-#define __NR_symlink (__NR_Linux + 86)
-#define __NR_readlink (__NR_Linux + 87)
-#define __NR_chmod (__NR_Linux + 88)
-#define __NR_fchmod (__NR_Linux + 89)
-#define __NR_chown (__NR_Linux + 90)
-#define __NR_fchown (__NR_Linux + 91)
-#define __NR_lchown (__NR_Linux + 92)
-#define __NR_umask (__NR_Linux + 93)
-#define __NR_gettimeofday (__NR_Linux + 94)
-#define __NR_getrlimit (__NR_Linux + 95)
-#define __NR_getrusage (__NR_Linux + 96)
-#define __NR_sysinfo (__NR_Linux + 97)
-#define __NR_times (__NR_Linux + 98)
-#define __NR_ptrace (__NR_Linux + 99)
-#define __NR_getuid (__NR_Linux + 100)
-#define __NR_syslog (__NR_Linux + 101)
-#define __NR_getgid (__NR_Linux + 102)
-#define __NR_setuid (__NR_Linux + 103)
-#define __NR_setgid (__NR_Linux + 104)
-#define __NR_geteuid (__NR_Linux + 105)
-#define __NR_getegid (__NR_Linux + 106)
-#define __NR_setpgid (__NR_Linux + 107)
-#define __NR_getppid (__NR_Linux + 108)
-#define __NR_getpgrp (__NR_Linux + 109)
-#define __NR_setsid (__NR_Linux + 110)
-#define __NR_setreuid (__NR_Linux + 111)
-#define __NR_setregid (__NR_Linux + 112)
-#define __NR_getgroups (__NR_Linux + 113)
-#define __NR_setgroups (__NR_Linux + 114)
-#define __NR_setresuid (__NR_Linux + 115)
-#define __NR_getresuid (__NR_Linux + 116)
-#define __NR_setresgid (__NR_Linux + 117)
-#define __NR_getresgid (__NR_Linux + 118)
-#define __NR_getpgid (__NR_Linux + 119)
-#define __NR_setfsuid (__NR_Linux + 120)
-#define __NR_setfsgid (__NR_Linux + 121)
-#define __NR_getsid (__NR_Linux + 122)
-#define __NR_capget (__NR_Linux + 123)
-#define __NR_capset (__NR_Linux + 124)
-#define __NR_rt_sigpending (__NR_Linux + 125)
-#define __NR_rt_sigtimedwait (__NR_Linux + 126)
-#define __NR_rt_sigqueueinfo (__NR_Linux + 127)
-#define __NR_rt_sigsuspend (__NR_Linux + 128)
-#define __NR_sigaltstack (__NR_Linux + 129)
-#define __NR_utime (__NR_Linux + 130)
-#define __NR_mknod (__NR_Linux + 131)
-#define __NR_personality (__NR_Linux + 132)
-#define __NR_ustat (__NR_Linux + 133)
-#define __NR_statfs (__NR_Linux + 134)
-#define __NR_fstatfs (__NR_Linux + 135)
-#define __NR_sysfs (__NR_Linux + 136)
-#define __NR_getpriority (__NR_Linux + 137)
-#define __NR_setpriority (__NR_Linux + 138)
-#define __NR_sched_setparam (__NR_Linux + 139)
-#define __NR_sched_getparam (__NR_Linux + 140)
-#define __NR_sched_setscheduler (__NR_Linux + 141)
-#define __NR_sched_getscheduler (__NR_Linux + 142)
-#define __NR_sched_get_priority_max (__NR_Linux + 143)
-#define __NR_sched_get_priority_min (__NR_Linux + 144)
-#define __NR_sched_rr_get_interval (__NR_Linux + 145)
-#define __NR_mlock (__NR_Linux + 146)
-#define __NR_munlock (__NR_Linux + 147)
-#define __NR_mlockall (__NR_Linux + 148)
-#define __NR_munlockall (__NR_Linux + 149)
-#define __NR_vhangup (__NR_Linux + 150)
-#define __NR_pivot_root (__NR_Linux + 151)
-#define __NR__sysctl (__NR_Linux + 152)
-#define __NR_prctl (__NR_Linux + 153)
-#define __NR_adjtimex (__NR_Linux + 154)
-#define __NR_setrlimit (__NR_Linux + 155)
-#define __NR_chroot (__NR_Linux + 156)
-#define __NR_sync (__NR_Linux + 157)
-#define __NR_acct (__NR_Linux + 158)
-#define __NR_settimeofday (__NR_Linux + 159)
-#define __NR_mount (__NR_Linux + 160)
-#define __NR_umount2 (__NR_Linux + 161)
-#define __NR_swapon (__NR_Linux + 162)
-#define __NR_swapoff (__NR_Linux + 163)
-#define __NR_reboot (__NR_Linux + 164)
-#define __NR_sethostname (__NR_Linux + 165)
-#define __NR_setdomainname (__NR_Linux + 166)
-#define __NR_create_module (__NR_Linux + 167)
-#define __NR_init_module (__NR_Linux + 168)
-#define __NR_delete_module (__NR_Linux + 169)
-#define __NR_get_kernel_syms (__NR_Linux + 170)
-#define __NR_query_module (__NR_Linux + 171)
-#define __NR_quotactl (__NR_Linux + 172)
-#define __NR_nfsservctl (__NR_Linux + 173)
-#define __NR_getpmsg (__NR_Linux + 174)
-#define __NR_putpmsg (__NR_Linux + 175)
-#define __NR_afs_syscall (__NR_Linux + 176)
-#define __NR_reserved177 (__NR_Linux + 177)
-#define __NR_gettid (__NR_Linux + 178)
-#define __NR_readahead (__NR_Linux + 179)
-#define __NR_setxattr (__NR_Linux + 180)
-#define __NR_lsetxattr (__NR_Linux + 181)
-#define __NR_fsetxattr (__NR_Linux + 182)
-#define __NR_getxattr (__NR_Linux + 183)
-#define __NR_lgetxattr (__NR_Linux + 184)
-#define __NR_fgetxattr (__NR_Linux + 185)
-#define __NR_listxattr (__NR_Linux + 186)
-#define __NR_llistxattr (__NR_Linux + 187)
-#define __NR_flistxattr (__NR_Linux + 188)
-#define __NR_removexattr (__NR_Linux + 189)
-#define __NR_lremovexattr (__NR_Linux + 190)
-#define __NR_fremovexattr (__NR_Linux + 191)
-#define __NR_tkill (__NR_Linux + 192)
-#define __NR_reserved193 (__NR_Linux + 193)
-#define __NR_futex (__NR_Linux + 194)
-#define __NR_sched_setaffinity (__NR_Linux + 195)
-#define __NR_sched_getaffinity (__NR_Linux + 196)
-#define __NR_cacheflush (__NR_Linux + 197)
-#define __NR_cachectl (__NR_Linux + 198)
-#define __NR_sysmips (__NR_Linux + 199)
-#define __NR_io_setup (__NR_Linux + 200)
-#define __NR_io_destroy (__NR_Linux + 201)
-#define __NR_io_getevents (__NR_Linux + 202)
-#define __NR_io_submit (__NR_Linux + 203)
-#define __NR_io_cancel (__NR_Linux + 204)
-#define __NR_exit_group (__NR_Linux + 205)
-#define __NR_lookup_dcookie (__NR_Linux + 206)
-#define __NR_epoll_create (__NR_Linux + 207)
-#define __NR_epoll_ctl (__NR_Linux + 208)
-#define __NR_epoll_wait (__NR_Linux + 209)
-#define __NR_remap_file_pages (__NR_Linux + 210)
-#define __NR_rt_sigreturn (__NR_Linux + 211)
-#define __NR_set_tid_address (__NR_Linux + 212)
-#define __NR_restart_syscall (__NR_Linux + 213)
-#define __NR_semtimedop (__NR_Linux + 214)
-#define __NR_fadvise64 (__NR_Linux + 215)
-#define __NR_timer_create (__NR_Linux + 216)
-#define __NR_timer_settime (__NR_Linux + 217)
-#define __NR_timer_gettime (__NR_Linux + 218)
-#define __NR_timer_getoverrun (__NR_Linux + 219)
-#define __NR_timer_delete (__NR_Linux + 220)
-#define __NR_clock_settime (__NR_Linux + 221)
-#define __NR_clock_gettime (__NR_Linux + 222)
-#define __NR_clock_getres (__NR_Linux + 223)
-#define __NR_clock_nanosleep (__NR_Linux + 224)
-#define __NR_tgkill (__NR_Linux + 225)
-#define __NR_utimes (__NR_Linux + 226)
-#define __NR_mbind (__NR_Linux + 227)
-#define __NR_get_mempolicy (__NR_Linux + 228)
-#define __NR_set_mempolicy (__NR_Linux + 229)
-#define __NR_mq_open (__NR_Linux + 230)
-#define __NR_mq_unlink (__NR_Linux + 231)
-#define __NR_mq_timedsend (__NR_Linux + 232)
-#define __NR_mq_timedreceive (__NR_Linux + 233)
-#define __NR_mq_notify (__NR_Linux + 234)
-#define __NR_mq_getsetattr (__NR_Linux + 235)
-#define __NR_vserver (__NR_Linux + 236)
-#define __NR_waitid (__NR_Linux + 237)
-#define __NR_add_key (__NR_Linux + 239)
-#define __NR_request_key (__NR_Linux + 240)
-#define __NR_keyctl (__NR_Linux + 241)
-#define __NR_set_thread_area (__NR_Linux + 242)
-#define __NR_inotify_init (__NR_Linux + 243)
-#define __NR_inotify_add_watch (__NR_Linux + 244)
-#define __NR_inotify_rm_watch (__NR_Linux + 245)
-#define __NR_migrate_pages (__NR_Linux + 246)
-#define __NR_openat (__NR_Linux + 247)
-#define __NR_mkdirat (__NR_Linux + 248)
-#define __NR_mknodat (__NR_Linux + 249)
-#define __NR_fchownat (__NR_Linux + 250)
-#define __NR_futimesat (__NR_Linux + 251)
-#define __NR_newfstatat (__NR_Linux + 252)
-#define __NR_unlinkat (__NR_Linux + 253)
-#define __NR_renameat (__NR_Linux + 254)
-#define __NR_linkat (__NR_Linux + 255)
-#define __NR_symlinkat (__NR_Linux + 256)
-#define __NR_readlinkat (__NR_Linux + 257)
-#define __NR_fchmodat (__NR_Linux + 258)
-#define __NR_faccessat (__NR_Linux + 259)
-#define __NR_pselect6 (__NR_Linux + 260)
-#define __NR_ppoll (__NR_Linux + 261)
-#define __NR_unshare (__NR_Linux + 262)
-#define __NR_splice (__NR_Linux + 263)
-#define __NR_sync_file_range (__NR_Linux + 264)
-#define __NR_tee (__NR_Linux + 265)
-#define __NR_vmsplice (__NR_Linux + 266)
-#define __NR_move_pages (__NR_Linux + 267)
-#define __NR_set_robust_list (__NR_Linux + 268)
-#define __NR_get_robust_list (__NR_Linux + 269)
-#define __NR_kexec_load (__NR_Linux + 270)
-#define __NR_getcpu (__NR_Linux + 271)
-#define __NR_epoll_pwait (__NR_Linux + 272)
-#define __NR_ioprio_set (__NR_Linux + 273)
-#define __NR_ioprio_get (__NR_Linux + 274)
-#define __NR_utimensat (__NR_Linux + 275)
-#define __NR_signalfd (__NR_Linux + 276)
-#define __NR_timerfd (__NR_Linux + 277)
-#define __NR_eventfd (__NR_Linux + 278)
-#define __NR_fallocate (__NR_Linux + 279)
-#define __NR_timerfd_create (__NR_Linux + 280)
-#define __NR_timerfd_gettime (__NR_Linux + 281)
-#define __NR_timerfd_settime (__NR_Linux + 282)
-#define __NR_signalfd4 (__NR_Linux + 283)
-#define __NR_eventfd2 (__NR_Linux + 284)
-#define __NR_epoll_create1 (__NR_Linux + 285)
-#define __NR_dup3 (__NR_Linux + 286)
-#define __NR_pipe2 (__NR_Linux + 287)
-#define __NR_inotify_init1 (__NR_Linux + 288)
-#define __NR_preadv (__NR_Linux + 289)
-#define __NR_pwritev (__NR_Linux + 290)
-#define __NR_rt_tgsigqueueinfo (__NR_Linux + 291)
-#define __NR_perf_event_open (__NR_Linux + 292)
-#define __NR_accept4 (__NR_Linux + 293)
-#define __NR_recvmmsg (__NR_Linux + 294)
-#define __NR_fanotify_init (__NR_Linux + 295)
-#define __NR_fanotify_mark (__NR_Linux + 296)
-#define __NR_prlimit64 (__NR_Linux + 297)
-#define __NR_name_to_handle_at (__NR_Linux + 298)
-#define __NR_open_by_handle_at (__NR_Linux + 299)
-#define __NR_clock_adjtime (__NR_Linux + 300)
-#define __NR_syncfs (__NR_Linux + 301)
-#define __NR_sendmmsg (__NR_Linux + 302)
-#define __NR_setns (__NR_Linux + 303)
-#define __NR_process_vm_readv (__NR_Linux + 304)
-#define __NR_process_vm_writev (__NR_Linux + 305)
-#define __NR_kcmp (__NR_Linux + 306)
-#define __NR_finit_module (__NR_Linux + 307)
-#define __NR_getdents64 (__NR_Linux + 308)
-#define __NR_sched_setattr (__NR_Linux + 309)
-#define __NR_sched_getattr (__NR_Linux + 310)
-#define __NR_renameat2 (__NR_Linux + 311)
-#define __NR_seccomp (__NR_Linux + 312)
-#define __NR_getrandom (__NR_Linux + 313)
-#define __NR_memfd_create (__NR_Linux + 314)
-#define __NR_bpf (__NR_Linux + 315)
-#define __NR_execveat (__NR_Linux + 316)
-#define __NR_userfaultfd (__NR_Linux + 317)
-#define __NR_membarrier (__NR_Linux + 318)
-#define __NR_mlock2 (__NR_Linux + 319)
-#define __NR_copy_file_range (__NR_Linux + 320)
-#define __NR_preadv2 (__NR_Linux + 321)
-#define __NR_pwritev2 (__NR_Linux + 322)
-#define __NR_pkey_mprotect (__NR_Linux + 323)
-#define __NR_pkey_alloc (__NR_Linux + 324)
-#define __NR_pkey_free (__NR_Linux + 325)
-#define __NR_statx (__NR_Linux + 326)
-#define __NR_rseq (__NR_Linux + 327)
-#define __NR_io_pgetevents (__NR_Linux + 328)
-#define __NR_pidfd_send_signal (__NR_Linux + 424)
-#define __NR_io_uring_setup (__NR_Linux + 425)
-#define __NR_io_uring_enter (__NR_Linux + 426)
-#define __NR_io_uring_register (__NR_Linux + 427)
-#define __NR_open_tree (__NR_Linux + 428)
-#define __NR_move_mount (__NR_Linux + 429)
-#define __NR_fsopen (__NR_Linux + 430)
-#define __NR_fsconfig (__NR_Linux + 431)
-#define __NR_fsmount (__NR_Linux + 432)
-#define __NR_fspick (__NR_Linux + 433)
-#define __NR_pidfd_open (__NR_Linux + 434)
-#define __NR_clone3 (__NR_Linux + 435)
-#define __NR_close_range (__NR_Linux + 436)
-#define __NR_openat2 (__NR_Linux + 437)
-#define __NR_pidfd_getfd (__NR_Linux + 438)
-#define __NR_faccessat2 (__NR_Linux + 439)
-#define __NR_process_madvise (__NR_Linux + 440)
-#define __NR_epoll_pwait2 (__NR_Linux + 441)
-#define __NR_mount_setattr (__NR_Linux + 442)
-#define __NR_landlock_create_ruleset (__NR_Linux + 444)
-#define __NR_landlock_add_rule (__NR_Linux + 445)
-#define __NR_landlock_restrict_self (__NR_Linux + 446)
+#define __NR_read	(__NR_Linux + 0)
+#define __NR_write	(__NR_Linux + 1)
+#define __NR_open	(__NR_Linux + 2)
+#define __NR_close	(__NR_Linux + 3)
+#define __NR_stat	(__NR_Linux + 4)
+#define __NR_fstat	(__NR_Linux + 5)
+#define __NR_lstat	(__NR_Linux + 6)
+#define __NR_poll	(__NR_Linux + 7)
+#define __NR_lseek	(__NR_Linux + 8)
+#define __NR_mmap	(__NR_Linux + 9)
+#define __NR_mprotect	(__NR_Linux + 10)
+#define __NR_munmap	(__NR_Linux + 11)
+#define __NR_brk	(__NR_Linux + 12)
+#define __NR_rt_sigaction	(__NR_Linux + 13)
+#define __NR_rt_sigprocmask	(__NR_Linux + 14)
+#define __NR_ioctl	(__NR_Linux + 15)
+#define __NR_pread64	(__NR_Linux + 16)
+#define __NR_pwrite64	(__NR_Linux + 17)
+#define __NR_readv	(__NR_Linux + 18)
+#define __NR_writev	(__NR_Linux + 19)
+#define __NR_access	(__NR_Linux + 20)
+#define __NR_pipe	(__NR_Linux + 21)
+#define __NR__newselect	(__NR_Linux + 22)
+#define __NR_sched_yield	(__NR_Linux + 23)
+#define __NR_mremap	(__NR_Linux + 24)
+#define __NR_msync	(__NR_Linux + 25)
+#define __NR_mincore	(__NR_Linux + 26)
+#define __NR_madvise	(__NR_Linux + 27)
+#define __NR_shmget	(__NR_Linux + 28)
+#define __NR_shmat	(__NR_Linux + 29)
+#define __NR_shmctl	(__NR_Linux + 30)
+#define __NR_dup	(__NR_Linux + 31)
+#define __NR_dup2	(__NR_Linux + 32)
+#define __NR_pause	(__NR_Linux + 33)
+#define __NR_nanosleep	(__NR_Linux + 34)
+#define __NR_getitimer	(__NR_Linux + 35)
+#define __NR_setitimer	(__NR_Linux + 36)
+#define __NR_alarm	(__NR_Linux + 37)
+#define __NR_getpid	(__NR_Linux + 38)
+#define __NR_sendfile	(__NR_Linux + 39)
+#define __NR_socket	(__NR_Linux + 40)
+#define __NR_connect	(__NR_Linux + 41)
+#define __NR_accept	(__NR_Linux + 42)
+#define __NR_sendto	(__NR_Linux + 43)
+#define __NR_recvfrom	(__NR_Linux + 44)
+#define __NR_sendmsg	(__NR_Linux + 45)
+#define __NR_recvmsg	(__NR_Linux + 46)
+#define __NR_shutdown	(__NR_Linux + 47)
+#define __NR_bind	(__NR_Linux + 48)
+#define __NR_listen	(__NR_Linux + 49)
+#define __NR_getsockname	(__NR_Linux + 50)
+#define __NR_getpeername	(__NR_Linux + 51)
+#define __NR_socketpair	(__NR_Linux + 52)
+#define __NR_setsockopt	(__NR_Linux + 53)
+#define __NR_getsockopt	(__NR_Linux + 54)
+#define __NR_clone	(__NR_Linux + 55)
+#define __NR_fork	(__NR_Linux + 56)
+#define __NR_execve	(__NR_Linux + 57)
+#define __NR_exit	(__NR_Linux + 58)
+#define __NR_wait4	(__NR_Linux + 59)
+#define __NR_kill	(__NR_Linux + 60)
+#define __NR_uname	(__NR_Linux + 61)
+#define __NR_semget	(__NR_Linux + 62)
+#define __NR_semop	(__NR_Linux + 63)
+#define __NR_semctl	(__NR_Linux + 64)
+#define __NR_shmdt	(__NR_Linux + 65)
+#define __NR_msgget	(__NR_Linux + 66)
+#define __NR_msgsnd	(__NR_Linux + 67)
+#define __NR_msgrcv	(__NR_Linux + 68)
+#define __NR_msgctl	(__NR_Linux + 69)
+#define __NR_fcntl	(__NR_Linux + 70)
+#define __NR_flock	(__NR_Linux + 71)
+#define __NR_fsync	(__NR_Linux + 72)
+#define __NR_fdatasync	(__NR_Linux + 73)
+#define __NR_truncate	(__NR_Linux + 74)
+#define __NR_ftruncate	(__NR_Linux + 75)
+#define __NR_getdents	(__NR_Linux + 76)
+#define __NR_getcwd	(__NR_Linux + 77)
+#define __NR_chdir	(__NR_Linux + 78)
+#define __NR_fchdir	(__NR_Linux + 79)
+#define __NR_rename	(__NR_Linux + 80)
+#define __NR_mkdir	(__NR_Linux + 81)
+#define __NR_rmdir	(__NR_Linux + 82)
+#define __NR_creat	(__NR_Linux + 83)
+#define __NR_link	(__NR_Linux + 84)
+#define __NR_unlink	(__NR_Linux + 85)
+#define __NR_symlink	(__NR_Linux + 86)
+#define __NR_readlink	(__NR_Linux + 87)
+#define __NR_chmod	(__NR_Linux + 88)
+#define __NR_fchmod	(__NR_Linux + 89)
+#define __NR_chown	(__NR_Linux + 90)
+#define __NR_fchown	(__NR_Linux + 91)
+#define __NR_lchown	(__NR_Linux + 92)
+#define __NR_umask	(__NR_Linux + 93)
+#define __NR_gettimeofday	(__NR_Linux + 94)
+#define __NR_getrlimit	(__NR_Linux + 95)
+#define __NR_getrusage	(__NR_Linux + 96)
+#define __NR_sysinfo	(__NR_Linux + 97)
+#define __NR_times	(__NR_Linux + 98)
+#define __NR_ptrace	(__NR_Linux + 99)
+#define __NR_getuid	(__NR_Linux + 100)
+#define __NR_syslog	(__NR_Linux + 101)
+#define __NR_getgid	(__NR_Linux + 102)
+#define __NR_setuid	(__NR_Linux + 103)
+#define __NR_setgid	(__NR_Linux + 104)
+#define __NR_geteuid	(__NR_Linux + 105)
+#define __NR_getegid	(__NR_Linux + 106)
+#define __NR_setpgid	(__NR_Linux + 107)
+#define __NR_getppid	(__NR_Linux + 108)
+#define __NR_getpgrp	(__NR_Linux + 109)
+#define __NR_setsid	(__NR_Linux + 110)
+#define __NR_setreuid	(__NR_Linux + 111)
+#define __NR_setregid	(__NR_Linux + 112)
+#define __NR_getgroups	(__NR_Linux + 113)
+#define __NR_setgroups	(__NR_Linux + 114)
+#define __NR_setresuid	(__NR_Linux + 115)
+#define __NR_getresuid	(__NR_Linux + 116)
+#define __NR_setresgid	(__NR_Linux + 117)
+#define __NR_getresgid	(__NR_Linux + 118)
+#define __NR_getpgid	(__NR_Linux + 119)
+#define __NR_setfsuid	(__NR_Linux + 120)
+#define __NR_setfsgid	(__NR_Linux + 121)
+#define __NR_getsid	(__NR_Linux + 122)
+#define __NR_capget	(__NR_Linux + 123)
+#define __NR_capset	(__NR_Linux + 124)
+#define __NR_rt_sigpending	(__NR_Linux + 125)
+#define __NR_rt_sigtimedwait	(__NR_Linux + 126)
+#define __NR_rt_sigqueueinfo	(__NR_Linux + 127)
+#define __NR_rt_sigsuspend	(__NR_Linux + 128)
+#define __NR_sigaltstack	(__NR_Linux + 129)
+#define __NR_utime	(__NR_Linux + 130)
+#define __NR_mknod	(__NR_Linux + 131)
+#define __NR_personality	(__NR_Linux + 132)
+#define __NR_ustat	(__NR_Linux + 133)
+#define __NR_statfs	(__NR_Linux + 134)
+#define __NR_fstatfs	(__NR_Linux + 135)
+#define __NR_sysfs	(__NR_Linux + 136)
+#define __NR_getpriority	(__NR_Linux + 137)
+#define __NR_setpriority	(__NR_Linux + 138)
+#define __NR_sched_setparam	(__NR_Linux + 139)
+#define __NR_sched_getparam	(__NR_Linux + 140)
+#define __NR_sched_setscheduler	(__NR_Linux + 141)
+#define __NR_sched_getscheduler	(__NR_Linux + 142)
+#define __NR_sched_get_priority_max	(__NR_Linux + 143)
+#define __NR_sched_get_priority_min	(__NR_Linux + 144)
+#define __NR_sched_rr_get_interval	(__NR_Linux + 145)
+#define __NR_mlock	(__NR_Linux + 146)
+#define __NR_munlock	(__NR_Linux + 147)
+#define __NR_mlockall	(__NR_Linux + 148)
+#define __NR_munlockall	(__NR_Linux + 149)
+#define __NR_vhangup	(__NR_Linux + 150)
+#define __NR_pivot_root	(__NR_Linux + 151)
+#define __NR__sysctl	(__NR_Linux + 152)
+#define __NR_prctl	(__NR_Linux + 153)
+#define __NR_adjtimex	(__NR_Linux + 154)
+#define __NR_setrlimit	(__NR_Linux + 155)
+#define __NR_chroot	(__NR_Linux + 156)
+#define __NR_sync	(__NR_Linux + 157)
+#define __NR_acct	(__NR_Linux + 158)
+#define __NR_settimeofday	(__NR_Linux + 159)
+#define __NR_mount	(__NR_Linux + 160)
+#define __NR_umount2	(__NR_Linux + 161)
+#define __NR_swapon	(__NR_Linux + 162)
+#define __NR_swapoff	(__NR_Linux + 163)
+#define __NR_reboot	(__NR_Linux + 164)
+#define __NR_sethostname	(__NR_Linux + 165)
+#define __NR_setdomainname	(__NR_Linux + 166)
+#define __NR_create_module	(__NR_Linux + 167)
+#define __NR_init_module	(__NR_Linux + 168)
+#define __NR_delete_module	(__NR_Linux + 169)
+#define __NR_get_kernel_syms	(__NR_Linux + 170)
+#define __NR_query_module	(__NR_Linux + 171)
+#define __NR_quotactl	(__NR_Linux + 172)
+#define __NR_nfsservctl	(__NR_Linux + 173)
+#define __NR_getpmsg	(__NR_Linux + 174)
+#define __NR_putpmsg	(__NR_Linux + 175)
+#define __NR_afs_syscall	(__NR_Linux + 176)
+#define __NR_reserved177	(__NR_Linux + 177)
+#define __NR_gettid	(__NR_Linux + 178)
+#define __NR_readahead	(__NR_Linux + 179)
+#define __NR_setxattr	(__NR_Linux + 180)
+#define __NR_lsetxattr	(__NR_Linux + 181)
+#define __NR_fsetxattr	(__NR_Linux + 182)
+#define __NR_getxattr	(__NR_Linux + 183)
+#define __NR_lgetxattr	(__NR_Linux + 184)
+#define __NR_fgetxattr	(__NR_Linux + 185)
+#define __NR_listxattr	(__NR_Linux + 186)
+#define __NR_llistxattr	(__NR_Linux + 187)
+#define __NR_flistxattr	(__NR_Linux + 188)
+#define __NR_removexattr	(__NR_Linux + 189)
+#define __NR_lremovexattr	(__NR_Linux + 190)
+#define __NR_fremovexattr	(__NR_Linux + 191)
+#define __NR_tkill	(__NR_Linux + 192)
+#define __NR_reserved193	(__NR_Linux + 193)
+#define __NR_futex	(__NR_Linux + 194)
+#define __NR_sched_setaffinity	(__NR_Linux + 195)
+#define __NR_sched_getaffinity	(__NR_Linux + 196)
+#define __NR_cacheflush	(__NR_Linux + 197)
+#define __NR_cachectl	(__NR_Linux + 198)
+#define __NR_sysmips	(__NR_Linux + 199)
+#define __NR_io_setup	(__NR_Linux + 200)
+#define __NR_io_destroy	(__NR_Linux + 201)
+#define __NR_io_getevents	(__NR_Linux + 202)
+#define __NR_io_submit	(__NR_Linux + 203)
+#define __NR_io_cancel	(__NR_Linux + 204)
+#define __NR_exit_group	(__NR_Linux + 205)
+#define __NR_lookup_dcookie	(__NR_Linux + 206)
+#define __NR_epoll_create	(__NR_Linux + 207)
+#define __NR_epoll_ctl	(__NR_Linux + 208)
+#define __NR_epoll_wait	(__NR_Linux + 209)
+#define __NR_remap_file_pages	(__NR_Linux + 210)
+#define __NR_rt_sigreturn	(__NR_Linux + 211)
+#define __NR_set_tid_address	(__NR_Linux + 212)
+#define __NR_restart_syscall	(__NR_Linux + 213)
+#define __NR_semtimedop	(__NR_Linux + 214)
+#define __NR_fadvise64	(__NR_Linux + 215)
+#define __NR_timer_create	(__NR_Linux + 216)
+#define __NR_timer_settime	(__NR_Linux + 217)
+#define __NR_timer_gettime	(__NR_Linux + 218)
+#define __NR_timer_getoverrun	(__NR_Linux + 219)
+#define __NR_timer_delete	(__NR_Linux + 220)
+#define __NR_clock_settime	(__NR_Linux + 221)
+#define __NR_clock_gettime	(__NR_Linux + 222)
+#define __NR_clock_getres	(__NR_Linux + 223)
+#define __NR_clock_nanosleep	(__NR_Linux + 224)
+#define __NR_tgkill	(__NR_Linux + 225)
+#define __NR_utimes	(__NR_Linux + 226)
+#define __NR_mbind	(__NR_Linux + 227)
+#define __NR_get_mempolicy	(__NR_Linux + 228)
+#define __NR_set_mempolicy	(__NR_Linux + 229)
+#define __NR_mq_open	(__NR_Linux + 230)
+#define __NR_mq_unlink	(__NR_Linux + 231)
+#define __NR_mq_timedsend	(__NR_Linux + 232)
+#define __NR_mq_timedreceive	(__NR_Linux + 233)
+#define __NR_mq_notify	(__NR_Linux + 234)
+#define __NR_mq_getsetattr	(__NR_Linux + 235)
+#define __NR_vserver	(__NR_Linux + 236)
+#define __NR_waitid	(__NR_Linux + 237)
+#define __NR_add_key	(__NR_Linux + 239)
+#define __NR_request_key	(__NR_Linux + 240)
+#define __NR_keyctl	(__NR_Linux + 241)
+#define __NR_set_thread_area	(__NR_Linux + 242)
+#define __NR_inotify_init	(__NR_Linux + 243)
+#define __NR_inotify_add_watch	(__NR_Linux + 244)
+#define __NR_inotify_rm_watch	(__NR_Linux + 245)
+#define __NR_migrate_pages	(__NR_Linux + 246)
+#define __NR_openat	(__NR_Linux + 247)
+#define __NR_mkdirat	(__NR_Linux + 248)
+#define __NR_mknodat	(__NR_Linux + 249)
+#define __NR_fchownat	(__NR_Linux + 250)
+#define __NR_futimesat	(__NR_Linux + 251)
+#define __NR_newfstatat	(__NR_Linux + 252)
+#define __NR_unlinkat	(__NR_Linux + 253)
+#define __NR_renameat	(__NR_Linux + 254)
+#define __NR_linkat	(__NR_Linux + 255)
+#define __NR_symlinkat	(__NR_Linux + 256)
+#define __NR_readlinkat	(__NR_Linux + 257)
+#define __NR_fchmodat	(__NR_Linux + 258)
+#define __NR_faccessat	(__NR_Linux + 259)
+#define __NR_pselect6	(__NR_Linux + 260)
+#define __NR_ppoll	(__NR_Linux + 261)
+#define __NR_unshare	(__NR_Linux + 262)
+#define __NR_splice	(__NR_Linux + 263)
+#define __NR_sync_file_range	(__NR_Linux + 264)
+#define __NR_tee	(__NR_Linux + 265)
+#define __NR_vmsplice	(__NR_Linux + 266)
+#define __NR_move_pages	(__NR_Linux + 267)
+#define __NR_set_robust_list	(__NR_Linux + 268)
+#define __NR_get_robust_list	(__NR_Linux + 269)
+#define __NR_kexec_load	(__NR_Linux + 270)
+#define __NR_getcpu	(__NR_Linux + 271)
+#define __NR_epoll_pwait	(__NR_Linux + 272)
+#define __NR_ioprio_set	(__NR_Linux + 273)
+#define __NR_ioprio_get	(__NR_Linux + 274)
+#define __NR_utimensat	(__NR_Linux + 275)
+#define __NR_signalfd	(__NR_Linux + 276)
+#define __NR_timerfd	(__NR_Linux + 277)
+#define __NR_eventfd	(__NR_Linux + 278)
+#define __NR_fallocate	(__NR_Linux + 279)
+#define __NR_timerfd_create	(__NR_Linux + 280)
+#define __NR_timerfd_gettime	(__NR_Linux + 281)
+#define __NR_timerfd_settime	(__NR_Linux + 282)
+#define __NR_signalfd4	(__NR_Linux + 283)
+#define __NR_eventfd2	(__NR_Linux + 284)
+#define __NR_epoll_create1	(__NR_Linux + 285)
+#define __NR_dup3	(__NR_Linux + 286)
+#define __NR_pipe2	(__NR_Linux + 287)
+#define __NR_inotify_init1	(__NR_Linux + 288)
+#define __NR_preadv	(__NR_Linux + 289)
+#define __NR_pwritev	(__NR_Linux + 290)
+#define __NR_rt_tgsigqueueinfo	(__NR_Linux + 291)
+#define __NR_perf_event_open	(__NR_Linux + 292)
+#define __NR_accept4	(__NR_Linux + 293)
+#define __NR_recvmmsg	(__NR_Linux + 294)
+#define __NR_fanotify_init	(__NR_Linux + 295)
+#define __NR_fanotify_mark	(__NR_Linux + 296)
+#define __NR_prlimit64	(__NR_Linux + 297)
+#define __NR_name_to_handle_at	(__NR_Linux + 298)
+#define __NR_open_by_handle_at	(__NR_Linux + 299)
+#define __NR_clock_adjtime	(__NR_Linux + 300)
+#define __NR_syncfs	(__NR_Linux + 301)
+#define __NR_sendmmsg	(__NR_Linux + 302)
+#define __NR_setns	(__NR_Linux + 303)
+#define __NR_process_vm_readv	(__NR_Linux + 304)
+#define __NR_process_vm_writev	(__NR_Linux + 305)
+#define __NR_kcmp	(__NR_Linux + 306)
+#define __NR_finit_module	(__NR_Linux + 307)
+#define __NR_getdents64	(__NR_Linux + 308)
+#define __NR_sched_setattr	(__NR_Linux + 309)
+#define __NR_sched_getattr	(__NR_Linux + 310)
+#define __NR_renameat2	(__NR_Linux + 311)
+#define __NR_seccomp	(__NR_Linux + 312)
+#define __NR_getrandom	(__NR_Linux + 313)
+#define __NR_memfd_create	(__NR_Linux + 314)
+#define __NR_bpf	(__NR_Linux + 315)
+#define __NR_execveat	(__NR_Linux + 316)
+#define __NR_userfaultfd	(__NR_Linux + 317)
+#define __NR_membarrier	(__NR_Linux + 318)
+#define __NR_mlock2	(__NR_Linux + 319)
+#define __NR_copy_file_range	(__NR_Linux + 320)
+#define __NR_preadv2	(__NR_Linux + 321)
+#define __NR_pwritev2	(__NR_Linux + 322)
+#define __NR_pkey_mprotect	(__NR_Linux + 323)
+#define __NR_pkey_alloc	(__NR_Linux + 324)
+#define __NR_pkey_free	(__NR_Linux + 325)
+#define __NR_statx	(__NR_Linux + 326)
+#define __NR_rseq	(__NR_Linux + 327)
+#define __NR_io_pgetevents	(__NR_Linux + 328)
+#define __NR_pidfd_send_signal	(__NR_Linux + 424)
+#define __NR_io_uring_setup	(__NR_Linux + 425)
+#define __NR_io_uring_enter	(__NR_Linux + 426)
+#define __NR_io_uring_register	(__NR_Linux + 427)
+#define __NR_open_tree	(__NR_Linux + 428)
+#define __NR_move_mount	(__NR_Linux + 429)
+#define __NR_fsopen	(__NR_Linux + 430)
+#define __NR_fsconfig	(__NR_Linux + 431)
+#define __NR_fsmount	(__NR_Linux + 432)
+#define __NR_fspick	(__NR_Linux + 433)
+#define __NR_pidfd_open	(__NR_Linux + 434)
+#define __NR_clone3	(__NR_Linux + 435)
+#define __NR_close_range	(__NR_Linux + 436)
+#define __NR_openat2	(__NR_Linux + 437)
+#define __NR_pidfd_getfd	(__NR_Linux + 438)
+#define __NR_faccessat2	(__NR_Linux + 439)
+#define __NR_process_madvise	(__NR_Linux + 440)
+#define __NR_epoll_pwait2	(__NR_Linux + 441)
 
-#endif /* _ASM_UNISTD_N64_H */
+
+#endif /* _ASM_MIPS_UNISTD_N64_H */
diff --git a/linux-headers/asm-mips/unistd_o32.h b/linux-headers/asm-mips/unistd_o32.h
index 954303ad69..ca6a7e5c0b 100644
--- a/linux-headers/asm-mips/unistd_o32.h
+++ b/linux-headers/asm-mips/unistd_o32.h
@@ -1,425 +1,422 @@
-#ifndef _ASM_UNISTD_O32_H
-#define _ASM_UNISTD_O32_H
+#ifndef _ASM_MIPS_UNISTD_O32_H
+#define _ASM_MIPS_UNISTD_O32_H
 
-#define __NR_syscall (__NR_Linux + 0)
-#define __NR_exit (__NR_Linux + 1)
-#define __NR_fork (__NR_Linux + 2)
-#define __NR_read (__NR_Linux + 3)
-#define __NR_write (__NR_Linux + 4)
-#define __NR_open (__NR_Linux + 5)
-#define __NR_close (__NR_Linux + 6)
-#define __NR_waitpid (__NR_Linux + 7)
-#define __NR_creat (__NR_Linux + 8)
-#define __NR_link (__NR_Linux + 9)
-#define __NR_unlink (__NR_Linux + 10)
-#define __NR_execve (__NR_Linux + 11)
-#define __NR_chdir (__NR_Linux + 12)
-#define __NR_time (__NR_Linux + 13)
-#define __NR_mknod (__NR_Linux + 14)
-#define __NR_chmod (__NR_Linux + 15)
-#define __NR_lchown (__NR_Linux + 16)
-#define __NR_break (__NR_Linux + 17)
-#define __NR_unused18 (__NR_Linux + 18)
-#define __NR_lseek (__NR_Linux + 19)
-#define __NR_getpid (__NR_Linux + 20)
-#define __NR_mount (__NR_Linux + 21)
-#define __NR_umount (__NR_Linux + 22)
-#define __NR_setuid (__NR_Linux + 23)
-#define __NR_getuid (__NR_Linux + 24)
-#define __NR_stime (__NR_Linux + 25)
-#define __NR_ptrace (__NR_Linux + 26)
-#define __NR_alarm (__NR_Linux + 27)
-#define __NR_unused28 (__NR_Linux + 28)
-#define __NR_pause (__NR_Linux + 29)
-#define __NR_utime (__NR_Linux + 30)
-#define __NR_stty (__NR_Linux + 31)
-#define __NR_gtty (__NR_Linux + 32)
-#define __NR_access (__NR_Linux + 33)
-#define __NR_nice (__NR_Linux + 34)
-#define __NR_ftime (__NR_Linux + 35)
-#define __NR_sync (__NR_Linux + 36)
-#define __NR_kill (__NR_Linux + 37)
-#define __NR_rename (__NR_Linux + 38)
-#define __NR_mkdir (__NR_Linux + 39)
-#define __NR_rmdir (__NR_Linux + 40)
-#define __NR_dup (__NR_Linux + 41)
-#define __NR_pipe (__NR_Linux + 42)
-#define __NR_times (__NR_Linux + 43)
-#define __NR_prof (__NR_Linux + 44)
-#define __NR_brk (__NR_Linux + 45)
-#define __NR_setgid (__NR_Linux + 46)
-#define __NR_getgid (__NR_Linux + 47)
-#define __NR_signal (__NR_Linux + 48)
-#define __NR_geteuid (__NR_Linux + 49)
-#define __NR_getegid (__NR_Linux + 50)
-#define __NR_acct (__NR_Linux + 51)
-#define __NR_umount2 (__NR_Linux + 52)
-#define __NR_lock (__NR_Linux + 53)
-#define __NR_ioctl (__NR_Linux + 54)
-#define __NR_fcntl (__NR_Linux + 55)
-#define __NR_mpx (__NR_Linux + 56)
-#define __NR_setpgid (__NR_Linux + 57)
-#define __NR_ulimit (__NR_Linux + 58)
-#define __NR_unused59 (__NR_Linux + 59)
-#define __NR_umask (__NR_Linux + 60)
-#define __NR_chroot (__NR_Linux + 61)
-#define __NR_ustat (__NR_Linux + 62)
-#define __NR_dup2 (__NR_Linux + 63)
-#define __NR_getppid (__NR_Linux + 64)
-#define __NR_getpgrp (__NR_Linux + 65)
-#define __NR_setsid (__NR_Linux + 66)
-#define __NR_sigaction (__NR_Linux + 67)
-#define __NR_sgetmask (__NR_Linux + 68)
-#define __NR_ssetmask (__NR_Linux + 69)
-#define __NR_setreuid (__NR_Linux + 70)
-#define __NR_setregid (__NR_Linux + 71)
-#define __NR_sigsuspend (__NR_Linux + 72)
-#define __NR_sigpending (__NR_Linux + 73)
-#define __NR_sethostname (__NR_Linux + 74)
-#define __NR_setrlimit (__NR_Linux + 75)
-#define __NR_getrlimit (__NR_Linux + 76)
-#define __NR_getrusage (__NR_Linux + 77)
-#define __NR_gettimeofday (__NR_Linux + 78)
-#define __NR_settimeofday (__NR_Linux + 79)
-#define __NR_getgroups (__NR_Linux + 80)
-#define __NR_setgroups (__NR_Linux + 81)
-#define __NR_reserved82 (__NR_Linux + 82)
-#define __NR_symlink (__NR_Linux + 83)
-#define __NR_unused84 (__NR_Linux + 84)
-#define __NR_readlink (__NR_Linux + 85)
-#define __NR_uselib (__NR_Linux + 86)
-#define __NR_swapon (__NR_Linux + 87)
-#define __NR_reboot (__NR_Linux + 88)
-#define __NR_readdir (__NR_Linux + 89)
-#define __NR_mmap (__NR_Linux + 90)
-#define __NR_munmap (__NR_Linux + 91)
-#define __NR_truncate (__NR_Linux + 92)
-#define __NR_ftruncate (__NR_Linux + 93)
-#define __NR_fchmod (__NR_Linux + 94)
-#define __NR_fchown (__NR_Linux + 95)
-#define __NR_getpriority (__NR_Linux + 96)
-#define __NR_setpriority (__NR_Linux + 97)
-#define __NR_profil (__NR_Linux + 98)
-#define __NR_statfs (__NR_Linux + 99)
-#define __NR_fstatfs (__NR_Linux + 100)
-#define __NR_ioperm (__NR_Linux + 101)
-#define __NR_socketcall (__NR_Linux + 102)
-#define __NR_syslog (__NR_Linux + 103)
-#define __NR_setitimer (__NR_Linux + 104)
-#define __NR_getitimer (__NR_Linux + 105)
-#define __NR_stat (__NR_Linux + 106)
-#define __NR_lstat (__NR_Linux + 107)
-#define __NR_fstat (__NR_Linux + 108)
-#define __NR_unused109 (__NR_Linux + 109)
-#define __NR_iopl (__NR_Linux + 110)
-#define __NR_vhangup (__NR_Linux + 111)
-#define __NR_idle (__NR_Linux + 112)
-#define __NR_vm86 (__NR_Linux + 113)
-#define __NR_wait4 (__NR_Linux + 114)
-#define __NR_swapoff (__NR_Linux + 115)
-#define __NR_sysinfo (__NR_Linux + 116)
-#define __NR_ipc (__NR_Linux + 117)
-#define __NR_fsync (__NR_Linux + 118)
-#define __NR_sigreturn (__NR_Linux + 119)
-#define __NR_clone (__NR_Linux + 120)
-#define __NR_setdomainname (__NR_Linux + 121)
-#define __NR_uname (__NR_Linux + 122)
-#define __NR_modify_ldt (__NR_Linux + 123)
-#define __NR_adjtimex (__NR_Linux + 124)
-#define __NR_mprotect (__NR_Linux + 125)
-#define __NR_sigprocmask (__NR_Linux + 126)
-#define __NR_create_module (__NR_Linux + 127)
-#define __NR_init_module (__NR_Linux + 128)
-#define __NR_delete_module (__NR_Linux + 129)
-#define __NR_get_kernel_syms (__NR_Linux + 130)
-#define __NR_quotactl (__NR_Linux + 131)
-#define __NR_getpgid (__NR_Linux + 132)
-#define __NR_fchdir (__NR_Linux + 133)
-#define __NR_bdflush (__NR_Linux + 134)
-#define __NR_sysfs (__NR_Linux + 135)
-#define __NR_personality (__NR_Linux + 136)
-#define __NR_afs_syscall (__NR_Linux + 137)
-#define __NR_setfsuid (__NR_Linux + 138)
-#define __NR_setfsgid (__NR_Linux + 139)
-#define __NR__llseek (__NR_Linux + 140)
-#define __NR_getdents (__NR_Linux + 141)
-#define __NR__newselect (__NR_Linux + 142)
-#define __NR_flock (__NR_Linux + 143)
-#define __NR_msync (__NR_Linux + 144)
-#define __NR_readv (__NR_Linux + 145)
-#define __NR_writev (__NR_Linux + 146)
-#define __NR_cacheflush (__NR_Linux + 147)
-#define __NR_cachectl (__NR_Linux + 148)
-#define __NR_sysmips (__NR_Linux + 149)
-#define __NR_unused150 (__NR_Linux + 150)
-#define __NR_getsid (__NR_Linux + 151)
-#define __NR_fdatasync (__NR_Linux + 152)
-#define __NR__sysctl (__NR_Linux + 153)
-#define __NR_mlock (__NR_Linux + 154)
-#define __NR_munlock (__NR_Linux + 155)
-#define __NR_mlockall (__NR_Linux + 156)
-#define __NR_munlockall (__NR_Linux + 157)
-#define __NR_sched_setparam (__NR_Linux + 158)
-#define __NR_sched_getparam (__NR_Linux + 159)
-#define __NR_sched_setscheduler (__NR_Linux + 160)
-#define __NR_sched_getscheduler (__NR_Linux + 161)
-#define __NR_sched_yield (__NR_Linux + 162)
-#define __NR_sched_get_priority_max (__NR_Linux + 163)
-#define __NR_sched_get_priority_min (__NR_Linux + 164)
-#define __NR_sched_rr_get_interval (__NR_Linux + 165)
-#define __NR_nanosleep (__NR_Linux + 166)
-#define __NR_mremap (__NR_Linux + 167)
-#define __NR_accept (__NR_Linux + 168)
-#define __NR_bind (__NR_Linux + 169)
-#define __NR_connect (__NR_Linux + 170)
-#define __NR_getpeername (__NR_Linux + 171)
-#define __NR_getsockname (__NR_Linux + 172)
-#define __NR_getsockopt (__NR_Linux + 173)
-#define __NR_listen (__NR_Linux + 174)
-#define __NR_recv (__NR_Linux + 175)
-#define __NR_recvfrom (__NR_Linux + 176)
-#define __NR_recvmsg (__NR_Linux + 177)
-#define __NR_send (__NR_Linux + 178)
-#define __NR_sendmsg (__NR_Linux + 179)
-#define __NR_sendto (__NR_Linux + 180)
-#define __NR_setsockopt (__NR_Linux + 181)
-#define __NR_shutdown (__NR_Linux + 182)
-#define __NR_socket (__NR_Linux + 183)
-#define __NR_socketpair (__NR_Linux + 184)
-#define __NR_setresuid (__NR_Linux + 185)
-#define __NR_getresuid (__NR_Linux + 186)
-#define __NR_query_module (__NR_Linux + 187)
-#define __NR_poll (__NR_Linux + 188)
-#define __NR_nfsservctl (__NR_Linux + 189)
-#define __NR_setresgid (__NR_Linux + 190)
-#define __NR_getresgid (__NR_Linux + 191)
-#define __NR_prctl (__NR_Linux + 192)
-#define __NR_rt_sigreturn (__NR_Linux + 193)
-#define __NR_rt_sigaction (__NR_Linux + 194)
-#define __NR_rt_sigprocmask (__NR_Linux + 195)
-#define __NR_rt_sigpending (__NR_Linux + 196)
-#define __NR_rt_sigtimedwait (__NR_Linux + 197)
-#define __NR_rt_sigqueueinfo (__NR_Linux + 198)
-#define __NR_rt_sigsuspend (__NR_Linux + 199)
-#define __NR_pread64 (__NR_Linux + 200)
-#define __NR_pwrite64 (__NR_Linux + 201)
-#define __NR_chown (__NR_Linux + 202)
-#define __NR_getcwd (__NR_Linux + 203)
-#define __NR_capget (__NR_Linux + 204)
-#define __NR_capset (__NR_Linux + 205)
-#define __NR_sigaltstack (__NR_Linux + 206)
-#define __NR_sendfile (__NR_Linux + 207)
-#define __NR_getpmsg (__NR_Linux + 208)
-#define __NR_putpmsg (__NR_Linux + 209)
-#define __NR_mmap2 (__NR_Linux + 210)
-#define __NR_truncate64 (__NR_Linux + 211)
-#define __NR_ftruncate64 (__NR_Linux + 212)
-#define __NR_stat64 (__NR_Linux + 213)
-#define __NR_lstat64 (__NR_Linux + 214)
-#define __NR_fstat64 (__NR_Linux + 215)
-#define __NR_pivot_root (__NR_Linux + 216)
-#define __NR_mincore (__NR_Linux + 217)
-#define __NR_madvise (__NR_Linux + 218)
-#define __NR_getdents64 (__NR_Linux + 219)
-#define __NR_fcntl64 (__NR_Linux + 220)
-#define __NR_reserved221 (__NR_Linux + 221)
-#define __NR_gettid (__NR_Linux + 222)
-#define __NR_readahead (__NR_Linux + 223)
-#define __NR_setxattr (__NR_Linux + 224)
-#define __NR_lsetxattr (__NR_Linux + 225)
-#define __NR_fsetxattr (__NR_Linux + 226)
-#define __NR_getxattr (__NR_Linux + 227)
-#define __NR_lgetxattr (__NR_Linux + 228)
-#define __NR_fgetxattr (__NR_Linux + 229)
-#define __NR_listxattr (__NR_Linux + 230)
-#define __NR_llistxattr (__NR_Linux + 231)
-#define __NR_flistxattr (__NR_Linux + 232)
-#define __NR_removexattr (__NR_Linux + 233)
-#define __NR_lremovexattr (__NR_Linux + 234)
-#define __NR_fremovexattr (__NR_Linux + 235)
-#define __NR_tkill (__NR_Linux + 236)
-#define __NR_sendfile64 (__NR_Linux + 237)
-#define __NR_futex (__NR_Linux + 238)
-#define __NR_sched_setaffinity (__NR_Linux + 239)
-#define __NR_sched_getaffinity (__NR_Linux + 240)
-#define __NR_io_setup (__NR_Linux + 241)
-#define __NR_io_destroy (__NR_Linux + 242)
-#define __NR_io_getevents (__NR_Linux + 243)
-#define __NR_io_submit (__NR_Linux + 244)
-#define __NR_io_cancel (__NR_Linux + 245)
-#define __NR_exit_group (__NR_Linux + 246)
-#define __NR_lookup_dcookie (__NR_Linux + 247)
-#define __NR_epoll_create (__NR_Linux + 248)
-#define __NR_epoll_ctl (__NR_Linux + 249)
-#define __NR_epoll_wait (__NR_Linux + 250)
-#define __NR_remap_file_pages (__NR_Linux + 251)
-#define __NR_set_tid_address (__NR_Linux + 252)
-#define __NR_restart_syscall (__NR_Linux + 253)
-#define __NR_fadvise64 (__NR_Linux + 254)
-#define __NR_statfs64 (__NR_Linux + 255)
-#define __NR_fstatfs64 (__NR_Linux + 256)
-#define __NR_timer_create (__NR_Linux + 257)
-#define __NR_timer_settime (__NR_Linux + 258)
-#define __NR_timer_gettime (__NR_Linux + 259)
-#define __NR_timer_getoverrun (__NR_Linux + 260)
-#define __NR_timer_delete (__NR_Linux + 261)
-#define __NR_clock_settime (__NR_Linux + 262)
-#define __NR_clock_gettime (__NR_Linux + 263)
-#define __NR_clock_getres (__NR_Linux + 264)
-#define __NR_clock_nanosleep (__NR_Linux + 265)
-#define __NR_tgkill (__NR_Linux + 266)
-#define __NR_utimes (__NR_Linux + 267)
-#define __NR_mbind (__NR_Linux + 268)
-#define __NR_get_mempolicy (__NR_Linux + 269)
-#define __NR_set_mempolicy (__NR_Linux + 270)
-#define __NR_mq_open (__NR_Linux + 271)
-#define __NR_mq_unlink (__NR_Linux + 272)
-#define __NR_mq_timedsend (__NR_Linux + 273)
-#define __NR_mq_timedreceive (__NR_Linux + 274)
-#define __NR_mq_notify (__NR_Linux + 275)
-#define __NR_mq_getsetattr (__NR_Linux + 276)
-#define __NR_vserver (__NR_Linux + 277)
-#define __NR_waitid (__NR_Linux + 278)
-#define __NR_add_key (__NR_Linux + 280)
-#define __NR_request_key (__NR_Linux + 281)
-#define __NR_keyctl (__NR_Linux + 282)
-#define __NR_set_thread_area (__NR_Linux + 283)
-#define __NR_inotify_init (__NR_Linux + 284)
-#define __NR_inotify_add_watch (__NR_Linux + 285)
-#define __NR_inotify_rm_watch (__NR_Linux + 286)
-#define __NR_migrate_pages (__NR_Linux + 287)
-#define __NR_openat (__NR_Linux + 288)
-#define __NR_mkdirat (__NR_Linux + 289)
-#define __NR_mknodat (__NR_Linux + 290)
-#define __NR_fchownat (__NR_Linux + 291)
-#define __NR_futimesat (__NR_Linux + 292)
-#define __NR_fstatat64 (__NR_Linux + 293)
-#define __NR_unlinkat (__NR_Linux + 294)
-#define __NR_renameat (__NR_Linux + 295)
-#define __NR_linkat (__NR_Linux + 296)
-#define __NR_symlinkat (__NR_Linux + 297)
-#define __NR_readlinkat (__NR_Linux + 298)
-#define __NR_fchmodat (__NR_Linux + 299)
-#define __NR_faccessat (__NR_Linux + 300)
-#define __NR_pselect6 (__NR_Linux + 301)
-#define __NR_ppoll (__NR_Linux + 302)
-#define __NR_unshare (__NR_Linux + 303)
-#define __NR_splice (__NR_Linux + 304)
-#define __NR_sync_file_range (__NR_Linux + 305)
-#define __NR_tee (__NR_Linux + 306)
-#define __NR_vmsplice (__NR_Linux + 307)
-#define __NR_move_pages (__NR_Linux + 308)
-#define __NR_set_robust_list (__NR_Linux + 309)
-#define __NR_get_robust_list (__NR_Linux + 310)
-#define __NR_kexec_load (__NR_Linux + 311)
-#define __NR_getcpu (__NR_Linux + 312)
-#define __NR_epoll_pwait (__NR_Linux + 313)
-#define __NR_ioprio_set (__NR_Linux + 314)
-#define __NR_ioprio_get (__NR_Linux + 315)
-#define __NR_utimensat (__NR_Linux + 316)
-#define __NR_signalfd (__NR_Linux + 317)
-#define __NR_timerfd (__NR_Linux + 318)
-#define __NR_eventfd (__NR_Linux + 319)
-#define __NR_fallocate (__NR_Linux + 320)
-#define __NR_timerfd_create (__NR_Linux + 321)
-#define __NR_timerfd_gettime (__NR_Linux + 322)
-#define __NR_timerfd_settime (__NR_Linux + 323)
-#define __NR_signalfd4 (__NR_Linux + 324)
-#define __NR_eventfd2 (__NR_Linux + 325)
-#define __NR_epoll_create1 (__NR_Linux + 326)
-#define __NR_dup3 (__NR_Linux + 327)
-#define __NR_pipe2 (__NR_Linux + 328)
-#define __NR_inotify_init1 (__NR_Linux + 329)
-#define __NR_preadv (__NR_Linux + 330)
-#define __NR_pwritev (__NR_Linux + 331)
-#define __NR_rt_tgsigqueueinfo (__NR_Linux + 332)
-#define __NR_perf_event_open (__NR_Linux + 333)
-#define __NR_accept4 (__NR_Linux + 334)
-#define __NR_recvmmsg (__NR_Linux + 335)
-#define __NR_fanotify_init (__NR_Linux + 336)
-#define __NR_fanotify_mark (__NR_Linux + 337)
-#define __NR_prlimit64 (__NR_Linux + 338)
-#define __NR_name_to_handle_at (__NR_Linux + 339)
-#define __NR_open_by_handle_at (__NR_Linux + 340)
-#define __NR_clock_adjtime (__NR_Linux + 341)
-#define __NR_syncfs (__NR_Linux + 342)
-#define __NR_sendmmsg (__NR_Linux + 343)
-#define __NR_setns (__NR_Linux + 344)
-#define __NR_process_vm_readv (__NR_Linux + 345)
-#define __NR_process_vm_writev (__NR_Linux + 346)
-#define __NR_kcmp (__NR_Linux + 347)
-#define __NR_finit_module (__NR_Linux + 348)
-#define __NR_sched_setattr (__NR_Linux + 349)
-#define __NR_sched_getattr (__NR_Linux + 350)
-#define __NR_renameat2 (__NR_Linux + 351)
-#define __NR_seccomp (__NR_Linux + 352)
-#define __NR_getrandom (__NR_Linux + 353)
-#define __NR_memfd_create (__NR_Linux + 354)
-#define __NR_bpf (__NR_Linux + 355)
-#define __NR_execveat (__NR_Linux + 356)
-#define __NR_userfaultfd (__NR_Linux + 357)
-#define __NR_membarrier (__NR_Linux + 358)
-#define __NR_mlock2 (__NR_Linux + 359)
-#define __NR_copy_file_range (__NR_Linux + 360)
-#define __NR_preadv2 (__NR_Linux + 361)
-#define __NR_pwritev2 (__NR_Linux + 362)
-#define __NR_pkey_mprotect (__NR_Linux + 363)
-#define __NR_pkey_alloc (__NR_Linux + 364)
-#define __NR_pkey_free (__NR_Linux + 365)
-#define __NR_statx (__NR_Linux + 366)
-#define __NR_rseq (__NR_Linux + 367)
-#define __NR_io_pgetevents (__NR_Linux + 368)
-#define __NR_semget (__NR_Linux + 393)
-#define __NR_semctl (__NR_Linux + 394)
-#define __NR_shmget (__NR_Linux + 395)
-#define __NR_shmctl (__NR_Linux + 396)
-#define __NR_shmat (__NR_Linux + 397)
-#define __NR_shmdt (__NR_Linux + 398)
-#define __NR_msgget (__NR_Linux + 399)
-#define __NR_msgsnd (__NR_Linux + 400)
-#define __NR_msgrcv (__NR_Linux + 401)
-#define __NR_msgctl (__NR_Linux + 402)
-#define __NR_clock_gettime64 (__NR_Linux + 403)
-#define __NR_clock_settime64 (__NR_Linux + 404)
-#define __NR_clock_adjtime64 (__NR_Linux + 405)
-#define __NR_clock_getres_time64 (__NR_Linux + 406)
-#define __NR_clock_nanosleep_time64 (__NR_Linux + 407)
-#define __NR_timer_gettime64 (__NR_Linux + 408)
-#define __NR_timer_settime64 (__NR_Linux + 409)
-#define __NR_timerfd_gettime64 (__NR_Linux + 410)
-#define __NR_timerfd_settime64 (__NR_Linux + 411)
-#define __NR_utimensat_time64 (__NR_Linux + 412)
-#define __NR_pselect6_time64 (__NR_Linux + 413)
-#define __NR_ppoll_time64 (__NR_Linux + 414)
-#define __NR_io_pgetevents_time64 (__NR_Linux + 416)
-#define __NR_recvmmsg_time64 (__NR_Linux + 417)
-#define __NR_mq_timedsend_time64 (__NR_Linux + 418)
-#define __NR_mq_timedreceive_time64 (__NR_Linux + 419)
-#define __NR_semtimedop_time64 (__NR_Linux + 420)
-#define __NR_rt_sigtimedwait_time64 (__NR_Linux + 421)
-#define __NR_futex_time64 (__NR_Linux + 422)
-#define __NR_sched_rr_get_interval_time64 (__NR_Linux + 423)
-#define __NR_pidfd_send_signal (__NR_Linux + 424)
-#define __NR_io_uring_setup (__NR_Linux + 425)
-#define __NR_io_uring_enter (__NR_Linux + 426)
-#define __NR_io_uring_register (__NR_Linux + 427)
-#define __NR_open_tree (__NR_Linux + 428)
-#define __NR_move_mount (__NR_Linux + 429)
-#define __NR_fsopen (__NR_Linux + 430)
-#define __NR_fsconfig (__NR_Linux + 431)
-#define __NR_fsmount (__NR_Linux + 432)
-#define __NR_fspick (__NR_Linux + 433)
-#define __NR_pidfd_open (__NR_Linux + 434)
-#define __NR_clone3 (__NR_Linux + 435)
-#define __NR_close_range (__NR_Linux + 436)
-#define __NR_openat2 (__NR_Linux + 437)
-#define __NR_pidfd_getfd (__NR_Linux + 438)
-#define __NR_faccessat2 (__NR_Linux + 439)
-#define __NR_process_madvise (__NR_Linux + 440)
-#define __NR_epoll_pwait2 (__NR_Linux + 441)
-#define __NR_mount_setattr (__NR_Linux + 442)
-#define __NR_landlock_create_ruleset (__NR_Linux + 444)
-#define __NR_landlock_add_rule (__NR_Linux + 445)
-#define __NR_landlock_restrict_self (__NR_Linux + 446)
+#define __NR_syscall	(__NR_Linux + 0)
+#define __NR_exit	(__NR_Linux + 1)
+#define __NR_fork	(__NR_Linux + 2)
+#define __NR_read	(__NR_Linux + 3)
+#define __NR_write	(__NR_Linux + 4)
+#define __NR_open	(__NR_Linux + 5)
+#define __NR_close	(__NR_Linux + 6)
+#define __NR_waitpid	(__NR_Linux + 7)
+#define __NR_creat	(__NR_Linux + 8)
+#define __NR_link	(__NR_Linux + 9)
+#define __NR_unlink	(__NR_Linux + 10)
+#define __NR_execve	(__NR_Linux + 11)
+#define __NR_chdir	(__NR_Linux + 12)
+#define __NR_time	(__NR_Linux + 13)
+#define __NR_mknod	(__NR_Linux + 14)
+#define __NR_chmod	(__NR_Linux + 15)
+#define __NR_lchown	(__NR_Linux + 16)
+#define __NR_break	(__NR_Linux + 17)
+#define __NR_unused18	(__NR_Linux + 18)
+#define __NR_lseek	(__NR_Linux + 19)
+#define __NR_getpid	(__NR_Linux + 20)
+#define __NR_mount	(__NR_Linux + 21)
+#define __NR_umount	(__NR_Linux + 22)
+#define __NR_setuid	(__NR_Linux + 23)
+#define __NR_getuid	(__NR_Linux + 24)
+#define __NR_stime	(__NR_Linux + 25)
+#define __NR_ptrace	(__NR_Linux + 26)
+#define __NR_alarm	(__NR_Linux + 27)
+#define __NR_unused28	(__NR_Linux + 28)
+#define __NR_pause	(__NR_Linux + 29)
+#define __NR_utime	(__NR_Linux + 30)
+#define __NR_stty	(__NR_Linux + 31)
+#define __NR_gtty	(__NR_Linux + 32)
+#define __NR_access	(__NR_Linux + 33)
+#define __NR_nice	(__NR_Linux + 34)
+#define __NR_ftime	(__NR_Linux + 35)
+#define __NR_sync	(__NR_Linux + 36)
+#define __NR_kill	(__NR_Linux + 37)
+#define __NR_rename	(__NR_Linux + 38)
+#define __NR_mkdir	(__NR_Linux + 39)
+#define __NR_rmdir	(__NR_Linux + 40)
+#define __NR_dup	(__NR_Linux + 41)
+#define __NR_pipe	(__NR_Linux + 42)
+#define __NR_times	(__NR_Linux + 43)
+#define __NR_prof	(__NR_Linux + 44)
+#define __NR_brk	(__NR_Linux + 45)
+#define __NR_setgid	(__NR_Linux + 46)
+#define __NR_getgid	(__NR_Linux + 47)
+#define __NR_signal	(__NR_Linux + 48)
+#define __NR_geteuid	(__NR_Linux + 49)
+#define __NR_getegid	(__NR_Linux + 50)
+#define __NR_acct	(__NR_Linux + 51)
+#define __NR_umount2	(__NR_Linux + 52)
+#define __NR_lock	(__NR_Linux + 53)
+#define __NR_ioctl	(__NR_Linux + 54)
+#define __NR_fcntl	(__NR_Linux + 55)
+#define __NR_mpx	(__NR_Linux + 56)
+#define __NR_setpgid	(__NR_Linux + 57)
+#define __NR_ulimit	(__NR_Linux + 58)
+#define __NR_unused59	(__NR_Linux + 59)
+#define __NR_umask	(__NR_Linux + 60)
+#define __NR_chroot	(__NR_Linux + 61)
+#define __NR_ustat	(__NR_Linux + 62)
+#define __NR_dup2	(__NR_Linux + 63)
+#define __NR_getppid	(__NR_Linux + 64)
+#define __NR_getpgrp	(__NR_Linux + 65)
+#define __NR_setsid	(__NR_Linux + 66)
+#define __NR_sigaction	(__NR_Linux + 67)
+#define __NR_sgetmask	(__NR_Linux + 68)
+#define __NR_ssetmask	(__NR_Linux + 69)
+#define __NR_setreuid	(__NR_Linux + 70)
+#define __NR_setregid	(__NR_Linux + 71)
+#define __NR_sigsuspend	(__NR_Linux + 72)
+#define __NR_sigpending	(__NR_Linux + 73)
+#define __NR_sethostname	(__NR_Linux + 74)
+#define __NR_setrlimit	(__NR_Linux + 75)
+#define __NR_getrlimit	(__NR_Linux + 76)
+#define __NR_getrusage	(__NR_Linux + 77)
+#define __NR_gettimeofday	(__NR_Linux + 78)
+#define __NR_settimeofday	(__NR_Linux + 79)
+#define __NR_getgroups	(__NR_Linux + 80)
+#define __NR_setgroups	(__NR_Linux + 81)
+#define __NR_reserved82	(__NR_Linux + 82)
+#define __NR_symlink	(__NR_Linux + 83)
+#define __NR_unused84	(__NR_Linux + 84)
+#define __NR_readlink	(__NR_Linux + 85)
+#define __NR_uselib	(__NR_Linux + 86)
+#define __NR_swapon	(__NR_Linux + 87)
+#define __NR_reboot	(__NR_Linux + 88)
+#define __NR_readdir	(__NR_Linux + 89)
+#define __NR_mmap	(__NR_Linux + 90)
+#define __NR_munmap	(__NR_Linux + 91)
+#define __NR_truncate	(__NR_Linux + 92)
+#define __NR_ftruncate	(__NR_Linux + 93)
+#define __NR_fchmod	(__NR_Linux + 94)
+#define __NR_fchown	(__NR_Linux + 95)
+#define __NR_getpriority	(__NR_Linux + 96)
+#define __NR_setpriority	(__NR_Linux + 97)
+#define __NR_profil	(__NR_Linux + 98)
+#define __NR_statfs	(__NR_Linux + 99)
+#define __NR_fstatfs	(__NR_Linux + 100)
+#define __NR_ioperm	(__NR_Linux + 101)
+#define __NR_socketcall	(__NR_Linux + 102)
+#define __NR_syslog	(__NR_Linux + 103)
+#define __NR_setitimer	(__NR_Linux + 104)
+#define __NR_getitimer	(__NR_Linux + 105)
+#define __NR_stat	(__NR_Linux + 106)
+#define __NR_lstat	(__NR_Linux + 107)
+#define __NR_fstat	(__NR_Linux + 108)
+#define __NR_unused109	(__NR_Linux + 109)
+#define __NR_iopl	(__NR_Linux + 110)
+#define __NR_vhangup	(__NR_Linux + 111)
+#define __NR_idle	(__NR_Linux + 112)
+#define __NR_vm86	(__NR_Linux + 113)
+#define __NR_wait4	(__NR_Linux + 114)
+#define __NR_swapoff	(__NR_Linux + 115)
+#define __NR_sysinfo	(__NR_Linux + 116)
+#define __NR_ipc	(__NR_Linux + 117)
+#define __NR_fsync	(__NR_Linux + 118)
+#define __NR_sigreturn	(__NR_Linux + 119)
+#define __NR_clone	(__NR_Linux + 120)
+#define __NR_setdomainname	(__NR_Linux + 121)
+#define __NR_uname	(__NR_Linux + 122)
+#define __NR_modify_ldt	(__NR_Linux + 123)
+#define __NR_adjtimex	(__NR_Linux + 124)
+#define __NR_mprotect	(__NR_Linux + 125)
+#define __NR_sigprocmask	(__NR_Linux + 126)
+#define __NR_create_module	(__NR_Linux + 127)
+#define __NR_init_module	(__NR_Linux + 128)
+#define __NR_delete_module	(__NR_Linux + 129)
+#define __NR_get_kernel_syms	(__NR_Linux + 130)
+#define __NR_quotactl	(__NR_Linux + 131)
+#define __NR_getpgid	(__NR_Linux + 132)
+#define __NR_fchdir	(__NR_Linux + 133)
+#define __NR_bdflush	(__NR_Linux + 134)
+#define __NR_sysfs	(__NR_Linux + 135)
+#define __NR_personality	(__NR_Linux + 136)
+#define __NR_afs_syscall	(__NR_Linux + 137)
+#define __NR_setfsuid	(__NR_Linux + 138)
+#define __NR_setfsgid	(__NR_Linux + 139)
+#define __NR__llseek	(__NR_Linux + 140)
+#define __NR_getdents	(__NR_Linux + 141)
+#define __NR__newselect	(__NR_Linux + 142)
+#define __NR_flock	(__NR_Linux + 143)
+#define __NR_msync	(__NR_Linux + 144)
+#define __NR_readv	(__NR_Linux + 145)
+#define __NR_writev	(__NR_Linux + 146)
+#define __NR_cacheflush	(__NR_Linux + 147)
+#define __NR_cachectl	(__NR_Linux + 148)
+#define __NR_sysmips	(__NR_Linux + 149)
+#define __NR_unused150	(__NR_Linux + 150)
+#define __NR_getsid	(__NR_Linux + 151)
+#define __NR_fdatasync	(__NR_Linux + 152)
+#define __NR__sysctl	(__NR_Linux + 153)
+#define __NR_mlock	(__NR_Linux + 154)
+#define __NR_munlock	(__NR_Linux + 155)
+#define __NR_mlockall	(__NR_Linux + 156)
+#define __NR_munlockall	(__NR_Linux + 157)
+#define __NR_sched_setparam	(__NR_Linux + 158)
+#define __NR_sched_getparam	(__NR_Linux + 159)
+#define __NR_sched_setscheduler	(__NR_Linux + 160)
+#define __NR_sched_getscheduler	(__NR_Linux + 161)
+#define __NR_sched_yield	(__NR_Linux + 162)
+#define __NR_sched_get_priority_max	(__NR_Linux + 163)
+#define __NR_sched_get_priority_min	(__NR_Linux + 164)
+#define __NR_sched_rr_get_interval	(__NR_Linux + 165)
+#define __NR_nanosleep	(__NR_Linux + 166)
+#define __NR_mremap	(__NR_Linux + 167)
+#define __NR_accept	(__NR_Linux + 168)
+#define __NR_bind	(__NR_Linux + 169)
+#define __NR_connect	(__NR_Linux + 170)
+#define __NR_getpeername	(__NR_Linux + 171)
+#define __NR_getsockname	(__NR_Linux + 172)
+#define __NR_getsockopt	(__NR_Linux + 173)
+#define __NR_listen	(__NR_Linux + 174)
+#define __NR_recv	(__NR_Linux + 175)
+#define __NR_recvfrom	(__NR_Linux + 176)
+#define __NR_recvmsg	(__NR_Linux + 177)
+#define __NR_send	(__NR_Linux + 178)
+#define __NR_sendmsg	(__NR_Linux + 179)
+#define __NR_sendto	(__NR_Linux + 180)
+#define __NR_setsockopt	(__NR_Linux + 181)
+#define __NR_shutdown	(__NR_Linux + 182)
+#define __NR_socket	(__NR_Linux + 183)
+#define __NR_socketpair	(__NR_Linux + 184)
+#define __NR_setresuid	(__NR_Linux + 185)
+#define __NR_getresuid	(__NR_Linux + 186)
+#define __NR_query_module	(__NR_Linux + 187)
+#define __NR_poll	(__NR_Linux + 188)
+#define __NR_nfsservctl	(__NR_Linux + 189)
+#define __NR_setresgid	(__NR_Linux + 190)
+#define __NR_getresgid	(__NR_Linux + 191)
+#define __NR_prctl	(__NR_Linux + 192)
+#define __NR_rt_sigreturn	(__NR_Linux + 193)
+#define __NR_rt_sigaction	(__NR_Linux + 194)
+#define __NR_rt_sigprocmask	(__NR_Linux + 195)
+#define __NR_rt_sigpending	(__NR_Linux + 196)
+#define __NR_rt_sigtimedwait	(__NR_Linux + 197)
+#define __NR_rt_sigqueueinfo	(__NR_Linux + 198)
+#define __NR_rt_sigsuspend	(__NR_Linux + 199)
+#define __NR_pread64	(__NR_Linux + 200)
+#define __NR_pwrite64	(__NR_Linux + 201)
+#define __NR_chown	(__NR_Linux + 202)
+#define __NR_getcwd	(__NR_Linux + 203)
+#define __NR_capget	(__NR_Linux + 204)
+#define __NR_capset	(__NR_Linux + 205)
+#define __NR_sigaltstack	(__NR_Linux + 206)
+#define __NR_sendfile	(__NR_Linux + 207)
+#define __NR_getpmsg	(__NR_Linux + 208)
+#define __NR_putpmsg	(__NR_Linux + 209)
+#define __NR_mmap2	(__NR_Linux + 210)
+#define __NR_truncate64	(__NR_Linux + 211)
+#define __NR_ftruncate64	(__NR_Linux + 212)
+#define __NR_stat64	(__NR_Linux + 213)
+#define __NR_lstat64	(__NR_Linux + 214)
+#define __NR_fstat64	(__NR_Linux + 215)
+#define __NR_pivot_root	(__NR_Linux + 216)
+#define __NR_mincore	(__NR_Linux + 217)
+#define __NR_madvise	(__NR_Linux + 218)
+#define __NR_getdents64	(__NR_Linux + 219)
+#define __NR_fcntl64	(__NR_Linux + 220)
+#define __NR_reserved221	(__NR_Linux + 221)
+#define __NR_gettid	(__NR_Linux + 222)
+#define __NR_readahead	(__NR_Linux + 223)
+#define __NR_setxattr	(__NR_Linux + 224)
+#define __NR_lsetxattr	(__NR_Linux + 225)
+#define __NR_fsetxattr	(__NR_Linux + 226)
+#define __NR_getxattr	(__NR_Linux + 227)
+#define __NR_lgetxattr	(__NR_Linux + 228)
+#define __NR_fgetxattr	(__NR_Linux + 229)
+#define __NR_listxattr	(__NR_Linux + 230)
+#define __NR_llistxattr	(__NR_Linux + 231)
+#define __NR_flistxattr	(__NR_Linux + 232)
+#define __NR_removexattr	(__NR_Linux + 233)
+#define __NR_lremovexattr	(__NR_Linux + 234)
+#define __NR_fremovexattr	(__NR_Linux + 235)
+#define __NR_tkill	(__NR_Linux + 236)
+#define __NR_sendfile64	(__NR_Linux + 237)
+#define __NR_futex	(__NR_Linux + 238)
+#define __NR_sched_setaffinity	(__NR_Linux + 239)
+#define __NR_sched_getaffinity	(__NR_Linux + 240)
+#define __NR_io_setup	(__NR_Linux + 241)
+#define __NR_io_destroy	(__NR_Linux + 242)
+#define __NR_io_getevents	(__NR_Linux + 243)
+#define __NR_io_submit	(__NR_Linux + 244)
+#define __NR_io_cancel	(__NR_Linux + 245)
+#define __NR_exit_group	(__NR_Linux + 246)
+#define __NR_lookup_dcookie	(__NR_Linux + 247)
+#define __NR_epoll_create	(__NR_Linux + 248)
+#define __NR_epoll_ctl	(__NR_Linux + 249)
+#define __NR_epoll_wait	(__NR_Linux + 250)
+#define __NR_remap_file_pages	(__NR_Linux + 251)
+#define __NR_set_tid_address	(__NR_Linux + 252)
+#define __NR_restart_syscall	(__NR_Linux + 253)
+#define __NR_fadvise64	(__NR_Linux + 254)
+#define __NR_statfs64	(__NR_Linux + 255)
+#define __NR_fstatfs64	(__NR_Linux + 256)
+#define __NR_timer_create	(__NR_Linux + 257)
+#define __NR_timer_settime	(__NR_Linux + 258)
+#define __NR_timer_gettime	(__NR_Linux + 259)
+#define __NR_timer_getoverrun	(__NR_Linux + 260)
+#define __NR_timer_delete	(__NR_Linux + 261)
+#define __NR_clock_settime	(__NR_Linux + 262)
+#define __NR_clock_gettime	(__NR_Linux + 263)
+#define __NR_clock_getres	(__NR_Linux + 264)
+#define __NR_clock_nanosleep	(__NR_Linux + 265)
+#define __NR_tgkill	(__NR_Linux + 266)
+#define __NR_utimes	(__NR_Linux + 267)
+#define __NR_mbind	(__NR_Linux + 268)
+#define __NR_get_mempolicy	(__NR_Linux + 269)
+#define __NR_set_mempolicy	(__NR_Linux + 270)
+#define __NR_mq_open	(__NR_Linux + 271)
+#define __NR_mq_unlink	(__NR_Linux + 272)
+#define __NR_mq_timedsend	(__NR_Linux + 273)
+#define __NR_mq_timedreceive	(__NR_Linux + 274)
+#define __NR_mq_notify	(__NR_Linux + 275)
+#define __NR_mq_getsetattr	(__NR_Linux + 276)
+#define __NR_vserver	(__NR_Linux + 277)
+#define __NR_waitid	(__NR_Linux + 278)
+#define __NR_add_key	(__NR_Linux + 280)
+#define __NR_request_key	(__NR_Linux + 281)
+#define __NR_keyctl	(__NR_Linux + 282)
+#define __NR_set_thread_area	(__NR_Linux + 283)
+#define __NR_inotify_init	(__NR_Linux + 284)
+#define __NR_inotify_add_watch	(__NR_Linux + 285)
+#define __NR_inotify_rm_watch	(__NR_Linux + 286)
+#define __NR_migrate_pages	(__NR_Linux + 287)
+#define __NR_openat	(__NR_Linux + 288)
+#define __NR_mkdirat	(__NR_Linux + 289)
+#define __NR_mknodat	(__NR_Linux + 290)
+#define __NR_fchownat	(__NR_Linux + 291)
+#define __NR_futimesat	(__NR_Linux + 292)
+#define __NR_fstatat64	(__NR_Linux + 293)
+#define __NR_unlinkat	(__NR_Linux + 294)
+#define __NR_renameat	(__NR_Linux + 295)
+#define __NR_linkat	(__NR_Linux + 296)
+#define __NR_symlinkat	(__NR_Linux + 297)
+#define __NR_readlinkat	(__NR_Linux + 298)
+#define __NR_fchmodat	(__NR_Linux + 299)
+#define __NR_faccessat	(__NR_Linux + 300)
+#define __NR_pselect6	(__NR_Linux + 301)
+#define __NR_ppoll	(__NR_Linux + 302)
+#define __NR_unshare	(__NR_Linux + 303)
+#define __NR_splice	(__NR_Linux + 304)
+#define __NR_sync_file_range	(__NR_Linux + 305)
+#define __NR_tee	(__NR_Linux + 306)
+#define __NR_vmsplice	(__NR_Linux + 307)
+#define __NR_move_pages	(__NR_Linux + 308)
+#define __NR_set_robust_list	(__NR_Linux + 309)
+#define __NR_get_robust_list	(__NR_Linux + 310)
+#define __NR_kexec_load	(__NR_Linux + 311)
+#define __NR_getcpu	(__NR_Linux + 312)
+#define __NR_epoll_pwait	(__NR_Linux + 313)
+#define __NR_ioprio_set	(__NR_Linux + 314)
+#define __NR_ioprio_get	(__NR_Linux + 315)
+#define __NR_utimensat	(__NR_Linux + 316)
+#define __NR_signalfd	(__NR_Linux + 317)
+#define __NR_timerfd	(__NR_Linux + 318)
+#define __NR_eventfd	(__NR_Linux + 319)
+#define __NR_fallocate	(__NR_Linux + 320)
+#define __NR_timerfd_create	(__NR_Linux + 321)
+#define __NR_timerfd_gettime	(__NR_Linux + 322)
+#define __NR_timerfd_settime	(__NR_Linux + 323)
+#define __NR_signalfd4	(__NR_Linux + 324)
+#define __NR_eventfd2	(__NR_Linux + 325)
+#define __NR_epoll_create1	(__NR_Linux + 326)
+#define __NR_dup3	(__NR_Linux + 327)
+#define __NR_pipe2	(__NR_Linux + 328)
+#define __NR_inotify_init1	(__NR_Linux + 329)
+#define __NR_preadv	(__NR_Linux + 330)
+#define __NR_pwritev	(__NR_Linux + 331)
+#define __NR_rt_tgsigqueueinfo	(__NR_Linux + 332)
+#define __NR_perf_event_open	(__NR_Linux + 333)
+#define __NR_accept4	(__NR_Linux + 334)
+#define __NR_recvmmsg	(__NR_Linux + 335)
+#define __NR_fanotify_init	(__NR_Linux + 336)
+#define __NR_fanotify_mark	(__NR_Linux + 337)
+#define __NR_prlimit64	(__NR_Linux + 338)
+#define __NR_name_to_handle_at	(__NR_Linux + 339)
+#define __NR_open_by_handle_at	(__NR_Linux + 340)
+#define __NR_clock_adjtime	(__NR_Linux + 341)
+#define __NR_syncfs	(__NR_Linux + 342)
+#define __NR_sendmmsg	(__NR_Linux + 343)
+#define __NR_setns	(__NR_Linux + 344)
+#define __NR_process_vm_readv	(__NR_Linux + 345)
+#define __NR_process_vm_writev	(__NR_Linux + 346)
+#define __NR_kcmp	(__NR_Linux + 347)
+#define __NR_finit_module	(__NR_Linux + 348)
+#define __NR_sched_setattr	(__NR_Linux + 349)
+#define __NR_sched_getattr	(__NR_Linux + 350)
+#define __NR_renameat2	(__NR_Linux + 351)
+#define __NR_seccomp	(__NR_Linux + 352)
+#define __NR_getrandom	(__NR_Linux + 353)
+#define __NR_memfd_create	(__NR_Linux + 354)
+#define __NR_bpf	(__NR_Linux + 355)
+#define __NR_execveat	(__NR_Linux + 356)
+#define __NR_userfaultfd	(__NR_Linux + 357)
+#define __NR_membarrier	(__NR_Linux + 358)
+#define __NR_mlock2	(__NR_Linux + 359)
+#define __NR_copy_file_range	(__NR_Linux + 360)
+#define __NR_preadv2	(__NR_Linux + 361)
+#define __NR_pwritev2	(__NR_Linux + 362)
+#define __NR_pkey_mprotect	(__NR_Linux + 363)
+#define __NR_pkey_alloc	(__NR_Linux + 364)
+#define __NR_pkey_free	(__NR_Linux + 365)
+#define __NR_statx	(__NR_Linux + 366)
+#define __NR_rseq	(__NR_Linux + 367)
+#define __NR_io_pgetevents	(__NR_Linux + 368)
+#define __NR_semget	(__NR_Linux + 393)
+#define __NR_semctl	(__NR_Linux + 394)
+#define __NR_shmget	(__NR_Linux + 395)
+#define __NR_shmctl	(__NR_Linux + 396)
+#define __NR_shmat	(__NR_Linux + 397)
+#define __NR_shmdt	(__NR_Linux + 398)
+#define __NR_msgget	(__NR_Linux + 399)
+#define __NR_msgsnd	(__NR_Linux + 400)
+#define __NR_msgrcv	(__NR_Linux + 401)
+#define __NR_msgctl	(__NR_Linux + 402)
+#define __NR_clock_gettime64	(__NR_Linux + 403)
+#define __NR_clock_settime64	(__NR_Linux + 404)
+#define __NR_clock_adjtime64	(__NR_Linux + 405)
+#define __NR_clock_getres_time64	(__NR_Linux + 406)
+#define __NR_clock_nanosleep_time64	(__NR_Linux + 407)
+#define __NR_timer_gettime64	(__NR_Linux + 408)
+#define __NR_timer_settime64	(__NR_Linux + 409)
+#define __NR_timerfd_gettime64	(__NR_Linux + 410)
+#define __NR_timerfd_settime64	(__NR_Linux + 411)
+#define __NR_utimensat_time64	(__NR_Linux + 412)
+#define __NR_pselect6_time64	(__NR_Linux + 413)
+#define __NR_ppoll_time64	(__NR_Linux + 414)
+#define __NR_io_pgetevents_time64	(__NR_Linux + 416)
+#define __NR_recvmmsg_time64	(__NR_Linux + 417)
+#define __NR_mq_timedsend_time64	(__NR_Linux + 418)
+#define __NR_mq_timedreceive_time64	(__NR_Linux + 419)
+#define __NR_semtimedop_time64	(__NR_Linux + 420)
+#define __NR_rt_sigtimedwait_time64	(__NR_Linux + 421)
+#define __NR_futex_time64	(__NR_Linux + 422)
+#define __NR_sched_rr_get_interval_time64	(__NR_Linux + 423)
+#define __NR_pidfd_send_signal	(__NR_Linux + 424)
+#define __NR_io_uring_setup	(__NR_Linux + 425)
+#define __NR_io_uring_enter	(__NR_Linux + 426)
+#define __NR_io_uring_register	(__NR_Linux + 427)
+#define __NR_open_tree	(__NR_Linux + 428)
+#define __NR_move_mount	(__NR_Linux + 429)
+#define __NR_fsopen	(__NR_Linux + 430)
+#define __NR_fsconfig	(__NR_Linux + 431)
+#define __NR_fsmount	(__NR_Linux + 432)
+#define __NR_fspick	(__NR_Linux + 433)
+#define __NR_pidfd_open	(__NR_Linux + 434)
+#define __NR_clone3	(__NR_Linux + 435)
+#define __NR_close_range	(__NR_Linux + 436)
+#define __NR_openat2	(__NR_Linux + 437)
+#define __NR_pidfd_getfd	(__NR_Linux + 438)
+#define __NR_faccessat2	(__NR_Linux + 439)
+#define __NR_process_madvise	(__NR_Linux + 440)
+#define __NR_epoll_pwait2	(__NR_Linux + 441)
 
-#endif /* _ASM_UNISTD_O32_H */
+
+#endif /* _ASM_MIPS_UNISTD_O32_H */
diff --git a/linux-headers/asm-powerpc/kvm.h b/linux-headers/asm-powerpc/kvm.h
index 9f18fa090f..c3af3f324c 100644
--- a/linux-headers/asm-powerpc/kvm.h
+++ b/linux-headers/asm-powerpc/kvm.h
@@ -644,8 +644,6 @@ struct kvm_ppc_cpu_char {
 #define KVM_REG_PPC_MMCR3	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xc1)
 #define KVM_REG_PPC_SIER2	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xc2)
 #define KVM_REG_PPC_SIER3	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xc3)
-#define KVM_REG_PPC_DAWR1	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xc4)
-#define KVM_REG_PPC_DAWRX1	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xc5)
 
 /* Transactional Memory checkpointed state:
  * This is all GPRs, all VSX regs and a subset of SPRs
diff --git a/linux-headers/asm-powerpc/unistd_32.h b/linux-headers/asm-powerpc/unistd_32.h
index 9155778c19..4624c90043 100644
--- a/linux-headers/asm-powerpc/unistd_32.h
+++ b/linux-headers/asm-powerpc/unistd_32.h
@@ -1,433 +1,429 @@
-#ifndef _ASM_UNISTD_32_H
-#define _ASM_UNISTD_32_H
+#ifndef _ASM_POWERPC_UNISTD_32_H
+#define _ASM_POWERPC_UNISTD_32_H
 
-#define __NR_restart_syscall 0
-#define __NR_exit 1
-#define __NR_fork 2
-#define __NR_read 3
-#define __NR_write 4
-#define __NR_open 5
-#define __NR_close 6
-#define __NR_waitpid 7
-#define __NR_creat 8
-#define __NR_link 9
-#define __NR_unlink 10
-#define __NR_execve 11
-#define __NR_chdir 12
-#define __NR_time 13
-#define __NR_mknod 14
-#define __NR_chmod 15
-#define __NR_lchown 16
-#define __NR_break 17
-#define __NR_oldstat 18
-#define __NR_lseek 19
-#define __NR_getpid 20
-#define __NR_mount 21
-#define __NR_umount 22
-#define __NR_setuid 23
-#define __NR_getuid 24
-#define __NR_stime 25
-#define __NR_ptrace 26
-#define __NR_alarm 27
-#define __NR_oldfstat 28
-#define __NR_pause 29
-#define __NR_utime 30
-#define __NR_stty 31
-#define __NR_gtty 32
-#define __NR_access 33
-#define __NR_nice 34
-#define __NR_ftime 35
-#define __NR_sync 36
-#define __NR_kill 37
-#define __NR_rename 38
-#define __NR_mkdir 39
-#define __NR_rmdir 40
-#define __NR_dup 41
-#define __NR_pipe 42
-#define __NR_times 43
-#define __NR_prof 44
-#define __NR_brk 45
-#define __NR_setgid 46
-#define __NR_getgid 47
-#define __NR_signal 48
-#define __NR_geteuid 49
-#define __NR_getegid 50
-#define __NR_acct 51
-#define __NR_umount2 52
-#define __NR_lock 53
-#define __NR_ioctl 54
-#define __NR_fcntl 55
-#define __NR_mpx 56
-#define __NR_setpgid 57
-#define __NR_ulimit 58
-#define __NR_oldolduname 59
-#define __NR_umask 60
-#define __NR_chroot 61
-#define __NR_ustat 62
-#define __NR_dup2 63
-#define __NR_getppid 64
-#define __NR_getpgrp 65
-#define __NR_setsid 66
-#define __NR_sigaction 67
-#define __NR_sgetmask 68
-#define __NR_ssetmask 69
-#define __NR_setreuid 70
-#define __NR_setregid 71
-#define __NR_sigsuspend 72
-#define __NR_sigpending 73
-#define __NR_sethostname 74
-#define __NR_setrlimit 75
-#define __NR_getrlimit 76
-#define __NR_getrusage 77
-#define __NR_gettimeofday 78
-#define __NR_settimeofday 79
-#define __NR_getgroups 80
-#define __NR_setgroups 81
-#define __NR_select 82
-#define __NR_symlink 83
-#define __NR_oldlstat 84
-#define __NR_readlink 85
-#define __NR_uselib 86
-#define __NR_swapon 87
-#define __NR_reboot 88
-#define __NR_readdir 89
-#define __NR_mmap 90
-#define __NR_munmap 91
-#define __NR_truncate 92
-#define __NR_ftruncate 93
-#define __NR_fchmod 94
-#define __NR_fchown 95
-#define __NR_getpriority 96
-#define __NR_setpriority 97
-#define __NR_profil 98
-#define __NR_statfs 99
-#define __NR_fstatfs 100
-#define __NR_ioperm 101
-#define __NR_socketcall 102
-#define __NR_syslog 103
-#define __NR_setitimer 104
-#define __NR_getitimer 105
-#define __NR_stat 106
-#define __NR_lstat 107
-#define __NR_fstat 108
-#define __NR_olduname 109
-#define __NR_iopl 110
-#define __NR_vhangup 111
-#define __NR_idle 112
-#define __NR_vm86 113
-#define __NR_wait4 114
-#define __NR_swapoff 115
-#define __NR_sysinfo 116
-#define __NR_ipc 117
-#define __NR_fsync 118
-#define __NR_sigreturn 119
-#define __NR_clone 120
-#define __NR_setdomainname 121
-#define __NR_uname 122
-#define __NR_modify_ldt 123
-#define __NR_adjtimex 124
-#define __NR_mprotect 125
-#define __NR_sigprocmask 126
-#define __NR_create_module 127
-#define __NR_init_module 128
-#define __NR_delete_module 129
-#define __NR_get_kernel_syms 130
-#define __NR_quotactl 131
-#define __NR_getpgid 132
-#define __NR_fchdir 133
-#define __NR_bdflush 134
-#define __NR_sysfs 135
-#define __NR_personality 136
-#define __NR_afs_syscall 137
-#define __NR_setfsuid 138
-#define __NR_setfsgid 139
-#define __NR__llseek 140
-#define __NR_getdents 141
-#define __NR__newselect 142
-#define __NR_flock 143
-#define __NR_msync 144
-#define __NR_readv 145
-#define __NR_writev 146
-#define __NR_getsid 147
-#define __NR_fdatasync 148
-#define __NR__sysctl 149
-#define __NR_mlock 150
-#define __NR_munlock 151
-#define __NR_mlockall 152
-#define __NR_munlockall 153
-#define __NR_sched_setparam 154
-#define __NR_sched_getparam 155
-#define __NR_sched_setscheduler 156
-#define __NR_sched_getscheduler 157
-#define __NR_sched_yield 158
-#define __NR_sched_get_priority_max 159
-#define __NR_sched_get_priority_min 160
-#define __NR_sched_rr_get_interval 161
-#define __NR_nanosleep 162
-#define __NR_mremap 163
-#define __NR_setresuid 164
-#define __NR_getresuid 165
-#define __NR_query_module 166
-#define __NR_poll 167
-#define __NR_nfsservctl 168
-#define __NR_setresgid 169
-#define __NR_getresgid 170
-#define __NR_prctl 171
-#define __NR_rt_sigreturn 172
-#define __NR_rt_sigaction 173
-#define __NR_rt_sigprocmask 174
-#define __NR_rt_sigpending 175
-#define __NR_rt_sigtimedwait 176
-#define __NR_rt_sigqueueinfo 177
-#define __NR_rt_sigsuspend 178
-#define __NR_pread64 179
-#define __NR_pwrite64 180
-#define __NR_chown 181
-#define __NR_getcwd 182
-#define __NR_capget 183
-#define __NR_capset 184
-#define __NR_sigaltstack 185
-#define __NR_sendfile 186
-#define __NR_getpmsg 187
-#define __NR_putpmsg 188
-#define __NR_vfork 189
-#define __NR_ugetrlimit 190
-#define __NR_readahead 191
-#define __NR_mmap2 192
-#define __NR_truncate64 193
-#define __NR_ftruncate64 194
-#define __NR_stat64 195
-#define __NR_lstat64 196
-#define __NR_fstat64 197
-#define __NR_pciconfig_read 198
-#define __NR_pciconfig_write 199
-#define __NR_pciconfig_iobase 200
-#define __NR_multiplexer 201
-#define __NR_getdents64 202
-#define __NR_pivot_root 203
-#define __NR_fcntl64 204
-#define __NR_madvise 205
-#define __NR_mincore 206
-#define __NR_gettid 207
-#define __NR_tkill 208
-#define __NR_setxattr 209
-#define __NR_lsetxattr 210
-#define __NR_fsetxattr 211
-#define __NR_getxattr 212
-#define __NR_lgetxattr 213
-#define __NR_fgetxattr 214
-#define __NR_listxattr 215
-#define __NR_llistxattr 216
-#define __NR_flistxattr 217
-#define __NR_removexattr 218
-#define __NR_lremovexattr 219
-#define __NR_fremovexattr 220
-#define __NR_futex 221
-#define __NR_sched_setaffinity 222
-#define __NR_sched_getaffinity 223
-#define __NR_tuxcall 225
-#define __NR_sendfile64 226
-#define __NR_io_setup 227
-#define __NR_io_destroy 228
-#define __NR_io_getevents 229
-#define __NR_io_submit 230
-#define __NR_io_cancel 231
-#define __NR_set_tid_address 232
-#define __NR_fadvise64 233
-#define __NR_exit_group 234
-#define __NR_lookup_dcookie 235
-#define __NR_epoll_create 236
-#define __NR_epoll_ctl 237
-#define __NR_epoll_wait 238
-#define __NR_remap_file_pages 239
-#define __NR_timer_create 240
-#define __NR_timer_settime 241
-#define __NR_timer_gettime 242
-#define __NR_timer_getoverrun 243
-#define __NR_timer_delete 244
-#define __NR_clock_settime 245
-#define __NR_clock_gettime 246
-#define __NR_clock_getres 247
-#define __NR_clock_nanosleep 248
-#define __NR_swapcontext 249
-#define __NR_tgkill 250
-#define __NR_utimes 251
-#define __NR_statfs64 252
-#define __NR_fstatfs64 253
-#define __NR_fadvise64_64 254
-#define __NR_rtas 255
-#define __NR_sys_debug_setcontext 256
-#define __NR_migrate_pages 258
-#define __NR_mbind 259
-#define __NR_get_mempolicy 260
-#define __NR_set_mempolicy 261
-#define __NR_mq_open 262
-#define __NR_mq_unlink 263
-#define __NR_mq_timedsend 264
-#define __NR_mq_timedreceive 265
-#define __NR_mq_notify 266
-#define __NR_mq_getsetattr 267
-#define __NR_kexec_load 268
-#define __NR_add_key 269
-#define __NR_request_key 270
-#define __NR_keyctl 271
-#define __NR_waitid 272
-#define __NR_ioprio_set 273
-#define __NR_ioprio_get 274
-#define __NR_inotify_init 275
-#define __NR_inotify_add_watch 276
-#define __NR_inotify_rm_watch 277
-#define __NR_spu_run 278
-#define __NR_spu_create 279
-#define __NR_pselect6 280
-#define __NR_ppoll 281
-#define __NR_unshare 282
-#define __NR_splice 283
-#define __NR_tee 284
-#define __NR_vmsplice 285
-#define __NR_openat 286
-#define __NR_mkdirat 287
-#define __NR_mknodat 288
-#define __NR_fchownat 289
-#define __NR_futimesat 290
-#define __NR_fstatat64 291
-#define __NR_unlinkat 292
-#define __NR_renameat 293
-#define __NR_linkat 294
-#define __NR_symlinkat 295
-#define __NR_readlinkat 296
-#define __NR_fchmodat 297
-#define __NR_faccessat 298
-#define __NR_get_robust_list 299
-#define __NR_set_robust_list 300
-#define __NR_move_pages 301
-#define __NR_getcpu 302
-#define __NR_epoll_pwait 303
-#define __NR_utimensat 304
-#define __NR_signalfd 305
-#define __NR_timerfd_create 306
-#define __NR_eventfd 307
-#define __NR_sync_file_range2 308
-#define __NR_fallocate 309
-#define __NR_subpage_prot 310
-#define __NR_timerfd_settime 311
-#define __NR_timerfd_gettime 312
-#define __NR_signalfd4 313
-#define __NR_eventfd2 314
-#define __NR_epoll_create1 315
-#define __NR_dup3 316
-#define __NR_pipe2 317
-#define __NR_inotify_init1 318
-#define __NR_perf_event_open 319
-#define __NR_preadv 320
-#define __NR_pwritev 321
-#define __NR_rt_tgsigqueueinfo 322
-#define __NR_fanotify_init 323
-#define __NR_fanotify_mark 324
-#define __NR_prlimit64 325
-#define __NR_socket 326
-#define __NR_bind 327
-#define __NR_connect 328
-#define __NR_listen 329
-#define __NR_accept 330
-#define __NR_getsockname 331
-#define __NR_getpeername 332
-#define __NR_socketpair 333
-#define __NR_send 334
-#define __NR_sendto 335
-#define __NR_recv 336
-#define __NR_recvfrom 337
-#define __NR_shutdown 338
-#define __NR_setsockopt 339
-#define __NR_getsockopt 340
-#define __NR_sendmsg 341
-#define __NR_recvmsg 342
-#define __NR_recvmmsg 343
-#define __NR_accept4 344
-#define __NR_name_to_handle_at 345
-#define __NR_open_by_handle_at 346
-#define __NR_clock_adjtime 347
-#define __NR_syncfs 348
-#define __NR_sendmmsg 349
-#define __NR_setns 350
-#define __NR_process_vm_readv 351
-#define __NR_process_vm_writev 352
-#define __NR_finit_module 353
-#define __NR_kcmp 354
-#define __NR_sched_setattr 355
-#define __NR_sched_getattr 356
-#define __NR_renameat2 357
-#define __NR_seccomp 358
-#define __NR_getrandom 359
-#define __NR_memfd_create 360
-#define __NR_bpf 361
-#define __NR_execveat 362
-#define __NR_switch_endian 363
-#define __NR_userfaultfd 364
-#define __NR_membarrier 365
-#define __NR_mlock2 378
-#define __NR_copy_file_range 379
-#define __NR_preadv2 380
-#define __NR_pwritev2 381
-#define __NR_kexec_file_load 382
-#define __NR_statx 383
-#define __NR_pkey_alloc 384
-#define __NR_pkey_free 385
-#define __NR_pkey_mprotect 386
-#define __NR_rseq 387
-#define __NR_io_pgetevents 388
-#define __NR_semget 393
-#define __NR_semctl 394
-#define __NR_shmget 395
-#define __NR_shmctl 396
-#define __NR_shmat 397
-#define __NR_shmdt 398
-#define __NR_msgget 399
-#define __NR_msgsnd 400
-#define __NR_msgrcv 401
-#define __NR_msgctl 402
-#define __NR_clock_gettime64 403
-#define __NR_clock_settime64 404
-#define __NR_clock_adjtime64 405
-#define __NR_clock_getres_time64 406
-#define __NR_clock_nanosleep_time64 407
-#define __NR_timer_gettime64 408
-#define __NR_timer_settime64 409
-#define __NR_timerfd_gettime64 410
-#define __NR_timerfd_settime64 411
-#define __NR_utimensat_time64 412
-#define __NR_pselect6_time64 413
-#define __NR_ppoll_time64 414
-#define __NR_io_pgetevents_time64 416
-#define __NR_recvmmsg_time64 417
-#define __NR_mq_timedsend_time64 418
-#define __NR_mq_timedreceive_time64 419
-#define __NR_semtimedop_time64 420
-#define __NR_rt_sigtimedwait_time64 421
-#define __NR_futex_time64 422
-#define __NR_sched_rr_get_interval_time64 423
-#define __NR_pidfd_send_signal 424
-#define __NR_io_uring_setup 425
-#define __NR_io_uring_enter 426
-#define __NR_io_uring_register 427
-#define __NR_open_tree 428
-#define __NR_move_mount 429
-#define __NR_fsopen 430
-#define __NR_fsconfig 431
-#define __NR_fsmount 432
-#define __NR_fspick 433
-#define __NR_pidfd_open 434
-#define __NR_clone3 435
-#define __NR_close_range 436
-#define __NR_openat2 437
-#define __NR_pidfd_getfd 438
-#define __NR_faccessat2 439
-#define __NR_process_madvise 440
-#define __NR_epoll_pwait2 441
-#define __NR_mount_setattr 442
-#define __NR_landlock_create_ruleset 444
-#define __NR_landlock_add_rule 445
-#define __NR_landlock_restrict_self 446
+#define __NR_restart_syscall	0
+#define __NR_exit	1
+#define __NR_fork	2
+#define __NR_read	3
+#define __NR_write	4
+#define __NR_open	5
+#define __NR_close	6
+#define __NR_waitpid	7
+#define __NR_creat	8
+#define __NR_link	9
+#define __NR_unlink	10
+#define __NR_execve	11
+#define __NR_chdir	12
+#define __NR_time	13
+#define __NR_mknod	14
+#define __NR_chmod	15
+#define __NR_lchown	16
+#define __NR_break	17
+#define __NR_oldstat	18
+#define __NR_lseek	19
+#define __NR_getpid	20
+#define __NR_mount	21
+#define __NR_umount	22
+#define __NR_setuid	23
+#define __NR_getuid	24
+#define __NR_stime	25
+#define __NR_ptrace	26
+#define __NR_alarm	27
+#define __NR_oldfstat	28
+#define __NR_pause	29
+#define __NR_utime	30
+#define __NR_stty	31
+#define __NR_gtty	32
+#define __NR_access	33
+#define __NR_nice	34
+#define __NR_ftime	35
+#define __NR_sync	36
+#define __NR_kill	37
+#define __NR_rename	38
+#define __NR_mkdir	39
+#define __NR_rmdir	40
+#define __NR_dup	41
+#define __NR_pipe	42
+#define __NR_times	43
+#define __NR_prof	44
+#define __NR_brk	45
+#define __NR_setgid	46
+#define __NR_getgid	47
+#define __NR_signal	48
+#define __NR_geteuid	49
+#define __NR_getegid	50
+#define __NR_acct	51
+#define __NR_umount2	52
+#define __NR_lock	53
+#define __NR_ioctl	54
+#define __NR_fcntl	55
+#define __NR_mpx	56
+#define __NR_setpgid	57
+#define __NR_ulimit	58
+#define __NR_oldolduname	59
+#define __NR_umask	60
+#define __NR_chroot	61
+#define __NR_ustat	62
+#define __NR_dup2	63
+#define __NR_getppid	64
+#define __NR_getpgrp	65
+#define __NR_setsid	66
+#define __NR_sigaction	67
+#define __NR_sgetmask	68
+#define __NR_ssetmask	69
+#define __NR_setreuid	70
+#define __NR_setregid	71
+#define __NR_sigsuspend	72
+#define __NR_sigpending	73
+#define __NR_sethostname	74
+#define __NR_setrlimit	75
+#define __NR_getrlimit	76
+#define __NR_getrusage	77
+#define __NR_gettimeofday	78
+#define __NR_settimeofday	79
+#define __NR_getgroups	80
+#define __NR_setgroups	81
+#define __NR_select	82
+#define __NR_symlink	83
+#define __NR_oldlstat	84
+#define __NR_readlink	85
+#define __NR_uselib	86
+#define __NR_swapon	87
+#define __NR_reboot	88
+#define __NR_readdir	89
+#define __NR_mmap	90
+#define __NR_munmap	91
+#define __NR_truncate	92
+#define __NR_ftruncate	93
+#define __NR_fchmod	94
+#define __NR_fchown	95
+#define __NR_getpriority	96
+#define __NR_setpriority	97
+#define __NR_profil	98
+#define __NR_statfs	99
+#define __NR_fstatfs	100
+#define __NR_ioperm	101
+#define __NR_socketcall	102
+#define __NR_syslog	103
+#define __NR_setitimer	104
+#define __NR_getitimer	105
+#define __NR_stat	106
+#define __NR_lstat	107
+#define __NR_fstat	108
+#define __NR_olduname	109
+#define __NR_iopl	110
+#define __NR_vhangup	111
+#define __NR_idle	112
+#define __NR_vm86	113
+#define __NR_wait4	114
+#define __NR_swapoff	115
+#define __NR_sysinfo	116
+#define __NR_ipc	117
+#define __NR_fsync	118
+#define __NR_sigreturn	119
+#define __NR_clone	120
+#define __NR_setdomainname	121
+#define __NR_uname	122
+#define __NR_modify_ldt	123
+#define __NR_adjtimex	124
+#define __NR_mprotect	125
+#define __NR_sigprocmask	126
+#define __NR_create_module	127
+#define __NR_init_module	128
+#define __NR_delete_module	129
+#define __NR_get_kernel_syms	130
+#define __NR_quotactl	131
+#define __NR_getpgid	132
+#define __NR_fchdir	133
+#define __NR_bdflush	134
+#define __NR_sysfs	135
+#define __NR_personality	136
+#define __NR_afs_syscall	137
+#define __NR_setfsuid	138
+#define __NR_setfsgid	139
+#define __NR__llseek	140
+#define __NR_getdents	141
+#define __NR__newselect	142
+#define __NR_flock	143
+#define __NR_msync	144
+#define __NR_readv	145
+#define __NR_writev	146
+#define __NR_getsid	147
+#define __NR_fdatasync	148
+#define __NR__sysctl	149
+#define __NR_mlock	150
+#define __NR_munlock	151
+#define __NR_mlockall	152
+#define __NR_munlockall	153
+#define __NR_sched_setparam	154
+#define __NR_sched_getparam	155
+#define __NR_sched_setscheduler	156
+#define __NR_sched_getscheduler	157
+#define __NR_sched_yield	158
+#define __NR_sched_get_priority_max	159
+#define __NR_sched_get_priority_min	160
+#define __NR_sched_rr_get_interval	161
+#define __NR_nanosleep	162
+#define __NR_mremap	163
+#define __NR_setresuid	164
+#define __NR_getresuid	165
+#define __NR_query_module	166
+#define __NR_poll	167
+#define __NR_nfsservctl	168
+#define __NR_setresgid	169
+#define __NR_getresgid	170
+#define __NR_prctl	171
+#define __NR_rt_sigreturn	172
+#define __NR_rt_sigaction	173
+#define __NR_rt_sigprocmask	174
+#define __NR_rt_sigpending	175
+#define __NR_rt_sigtimedwait	176
+#define __NR_rt_sigqueueinfo	177
+#define __NR_rt_sigsuspend	178
+#define __NR_pread64	179
+#define __NR_pwrite64	180
+#define __NR_chown	181
+#define __NR_getcwd	182
+#define __NR_capget	183
+#define __NR_capset	184
+#define __NR_sigaltstack	185
+#define __NR_sendfile	186
+#define __NR_getpmsg	187
+#define __NR_putpmsg	188
+#define __NR_vfork	189
+#define __NR_ugetrlimit	190
+#define __NR_readahead	191
+#define __NR_mmap2	192
+#define __NR_truncate64	193
+#define __NR_ftruncate64	194
+#define __NR_stat64	195
+#define __NR_lstat64	196
+#define __NR_fstat64	197
+#define __NR_pciconfig_read	198
+#define __NR_pciconfig_write	199
+#define __NR_pciconfig_iobase	200
+#define __NR_multiplexer	201
+#define __NR_getdents64	202
+#define __NR_pivot_root	203
+#define __NR_fcntl64	204
+#define __NR_madvise	205
+#define __NR_mincore	206
+#define __NR_gettid	207
+#define __NR_tkill	208
+#define __NR_setxattr	209
+#define __NR_lsetxattr	210
+#define __NR_fsetxattr	211
+#define __NR_getxattr	212
+#define __NR_lgetxattr	213
+#define __NR_fgetxattr	214
+#define __NR_listxattr	215
+#define __NR_llistxattr	216
+#define __NR_flistxattr	217
+#define __NR_removexattr	218
+#define __NR_lremovexattr	219
+#define __NR_fremovexattr	220
+#define __NR_futex	221
+#define __NR_sched_setaffinity	222
+#define __NR_sched_getaffinity	223
+#define __NR_tuxcall	225
+#define __NR_sendfile64	226
+#define __NR_io_setup	227
+#define __NR_io_destroy	228
+#define __NR_io_getevents	229
+#define __NR_io_submit	230
+#define __NR_io_cancel	231
+#define __NR_set_tid_address	232
+#define __NR_fadvise64	233
+#define __NR_exit_group	234
+#define __NR_lookup_dcookie	235
+#define __NR_epoll_create	236
+#define __NR_epoll_ctl	237
+#define __NR_epoll_wait	238
+#define __NR_remap_file_pages	239
+#define __NR_timer_create	240
+#define __NR_timer_settime	241
+#define __NR_timer_gettime	242
+#define __NR_timer_getoverrun	243
+#define __NR_timer_delete	244
+#define __NR_clock_settime	245
+#define __NR_clock_gettime	246
+#define __NR_clock_getres	247
+#define __NR_clock_nanosleep	248
+#define __NR_swapcontext	249
+#define __NR_tgkill	250
+#define __NR_utimes	251
+#define __NR_statfs64	252
+#define __NR_fstatfs64	253
+#define __NR_fadvise64_64	254
+#define __NR_rtas	255
+#define __NR_sys_debug_setcontext	256
+#define __NR_migrate_pages	258
+#define __NR_mbind	259
+#define __NR_get_mempolicy	260
+#define __NR_set_mempolicy	261
+#define __NR_mq_open	262
+#define __NR_mq_unlink	263
+#define __NR_mq_timedsend	264
+#define __NR_mq_timedreceive	265
+#define __NR_mq_notify	266
+#define __NR_mq_getsetattr	267
+#define __NR_kexec_load	268
+#define __NR_add_key	269
+#define __NR_request_key	270
+#define __NR_keyctl	271
+#define __NR_waitid	272
+#define __NR_ioprio_set	273
+#define __NR_ioprio_get	274
+#define __NR_inotify_init	275
+#define __NR_inotify_add_watch	276
+#define __NR_inotify_rm_watch	277
+#define __NR_spu_run	278
+#define __NR_spu_create	279
+#define __NR_pselect6	280
+#define __NR_ppoll	281
+#define __NR_unshare	282
+#define __NR_splice	283
+#define __NR_tee	284
+#define __NR_vmsplice	285
+#define __NR_openat	286
+#define __NR_mkdirat	287
+#define __NR_mknodat	288
+#define __NR_fchownat	289
+#define __NR_futimesat	290
+#define __NR_fstatat64	291
+#define __NR_unlinkat	292
+#define __NR_renameat	293
+#define __NR_linkat	294
+#define __NR_symlinkat	295
+#define __NR_readlinkat	296
+#define __NR_fchmodat	297
+#define __NR_faccessat	298
+#define __NR_get_robust_list	299
+#define __NR_set_robust_list	300
+#define __NR_move_pages	301
+#define __NR_getcpu	302
+#define __NR_epoll_pwait	303
+#define __NR_utimensat	304
+#define __NR_signalfd	305
+#define __NR_timerfd_create	306
+#define __NR_eventfd	307
+#define __NR_sync_file_range2	308
+#define __NR_fallocate	309
+#define __NR_subpage_prot	310
+#define __NR_timerfd_settime	311
+#define __NR_timerfd_gettime	312
+#define __NR_signalfd4	313
+#define __NR_eventfd2	314
+#define __NR_epoll_create1	315
+#define __NR_dup3	316
+#define __NR_pipe2	317
+#define __NR_inotify_init1	318
+#define __NR_perf_event_open	319
+#define __NR_preadv	320
+#define __NR_pwritev	321
+#define __NR_rt_tgsigqueueinfo	322
+#define __NR_fanotify_init	323
+#define __NR_fanotify_mark	324
+#define __NR_prlimit64	325
+#define __NR_socket	326
+#define __NR_bind	327
+#define __NR_connect	328
+#define __NR_listen	329
+#define __NR_accept	330
+#define __NR_getsockname	331
+#define __NR_getpeername	332
+#define __NR_socketpair	333
+#define __NR_send	334
+#define __NR_sendto	335
+#define __NR_recv	336
+#define __NR_recvfrom	337
+#define __NR_shutdown	338
+#define __NR_setsockopt	339
+#define __NR_getsockopt	340
+#define __NR_sendmsg	341
+#define __NR_recvmsg	342
+#define __NR_recvmmsg	343
+#define __NR_accept4	344
+#define __NR_name_to_handle_at	345
+#define __NR_open_by_handle_at	346
+#define __NR_clock_adjtime	347
+#define __NR_syncfs	348
+#define __NR_sendmmsg	349
+#define __NR_setns	350
+#define __NR_process_vm_readv	351
+#define __NR_process_vm_writev	352
+#define __NR_finit_module	353
+#define __NR_kcmp	354
+#define __NR_sched_setattr	355
+#define __NR_sched_getattr	356
+#define __NR_renameat2	357
+#define __NR_seccomp	358
+#define __NR_getrandom	359
+#define __NR_memfd_create	360
+#define __NR_bpf	361
+#define __NR_execveat	362
+#define __NR_switch_endian	363
+#define __NR_userfaultfd	364
+#define __NR_membarrier	365
+#define __NR_mlock2	378
+#define __NR_copy_file_range	379
+#define __NR_preadv2	380
+#define __NR_pwritev2	381
+#define __NR_kexec_file_load	382
+#define __NR_statx	383
+#define __NR_pkey_alloc	384
+#define __NR_pkey_free	385
+#define __NR_pkey_mprotect	386
+#define __NR_rseq	387
+#define __NR_io_pgetevents	388
+#define __NR_semget	393
+#define __NR_semctl	394
+#define __NR_shmget	395
+#define __NR_shmctl	396
+#define __NR_shmat	397
+#define __NR_shmdt	398
+#define __NR_msgget	399
+#define __NR_msgsnd	400
+#define __NR_msgrcv	401
+#define __NR_msgctl	402
+#define __NR_clock_gettime64	403
+#define __NR_clock_settime64	404
+#define __NR_clock_adjtime64	405
+#define __NR_clock_getres_time64	406
+#define __NR_clock_nanosleep_time64	407
+#define __NR_timer_gettime64	408
+#define __NR_timer_settime64	409
+#define __NR_timerfd_gettime64	410
+#define __NR_timerfd_settime64	411
+#define __NR_utimensat_time64	412
+#define __NR_pselect6_time64	413
+#define __NR_ppoll_time64	414
+#define __NR_io_pgetevents_time64	416
+#define __NR_recvmmsg_time64	417
+#define __NR_mq_timedsend_time64	418
+#define __NR_mq_timedreceive_time64	419
+#define __NR_semtimedop_time64	420
+#define __NR_rt_sigtimedwait_time64	421
+#define __NR_futex_time64	422
+#define __NR_sched_rr_get_interval_time64	423
+#define __NR_pidfd_send_signal	424
+#define __NR_io_uring_setup	425
+#define __NR_io_uring_enter	426
+#define __NR_io_uring_register	427
+#define __NR_open_tree	428
+#define __NR_move_mount	429
+#define __NR_fsopen	430
+#define __NR_fsconfig	431
+#define __NR_fsmount	432
+#define __NR_fspick	433
+#define __NR_pidfd_open	434
+#define __NR_clone3	435
+#define __NR_close_range	436
+#define __NR_openat2	437
+#define __NR_pidfd_getfd	438
+#define __NR_faccessat2	439
+#define __NR_process_madvise	440
+#define __NR_epoll_pwait2	441
 
 
-#endif /* _ASM_UNISTD_32_H */
+#endif /* _ASM_POWERPC_UNISTD_32_H */
diff --git a/linux-headers/asm-powerpc/unistd_64.h b/linux-headers/asm-powerpc/unistd_64.h
index 3cefa88932..7e851b30bb 100644
--- a/linux-headers/asm-powerpc/unistd_64.h
+++ b/linux-headers/asm-powerpc/unistd_64.h
@@ -1,405 +1,401 @@
-#ifndef _ASM_UNISTD_64_H
-#define _ASM_UNISTD_64_H
+#ifndef _ASM_POWERPC_UNISTD_64_H
+#define _ASM_POWERPC_UNISTD_64_H
 
-#define __NR_restart_syscall 0
-#define __NR_exit 1
-#define __NR_fork 2
-#define __NR_read 3
-#define __NR_write 4
-#define __NR_open 5
-#define __NR_close 6
-#define __NR_waitpid 7
-#define __NR_creat 8
-#define __NR_link 9
-#define __NR_unlink 10
-#define __NR_execve 11
-#define __NR_chdir 12
-#define __NR_time 13
-#define __NR_mknod 14
-#define __NR_chmod 15
-#define __NR_lchown 16
-#define __NR_break 17
-#define __NR_oldstat 18
-#define __NR_lseek 19
-#define __NR_getpid 20
-#define __NR_mount 21
-#define __NR_umount 22
-#define __NR_setuid 23
-#define __NR_getuid 24
-#define __NR_stime 25
-#define __NR_ptrace 26
-#define __NR_alarm 27
-#define __NR_oldfstat 28
-#define __NR_pause 29
-#define __NR_utime 30
-#define __NR_stty 31
-#define __NR_gtty 32
-#define __NR_access 33
-#define __NR_nice 34
-#define __NR_ftime 35
-#define __NR_sync 36
-#define __NR_kill 37
-#define __NR_rename 38
-#define __NR_mkdir 39
-#define __NR_rmdir 40
-#define __NR_dup 41
-#define __NR_pipe 42
-#define __NR_times 43
-#define __NR_prof 44
-#define __NR_brk 45
-#define __NR_setgid 46
-#define __NR_getgid 47
-#define __NR_signal 48
-#define __NR_geteuid 49
-#define __NR_getegid 50
-#define __NR_acct 51
-#define __NR_umount2 52
-#define __NR_lock 53
-#define __NR_ioctl 54
-#define __NR_fcntl 55
-#define __NR_mpx 56
-#define __NR_setpgid 57
-#define __NR_ulimit 58
-#define __NR_oldolduname 59
-#define __NR_umask 60
-#define __NR_chroot 61
-#define __NR_ustat 62
-#define __NR_dup2 63
-#define __NR_getppid 64
-#define __NR_getpgrp 65
-#define __NR_setsid 66
-#define __NR_sigaction 67
-#define __NR_sgetmask 68
-#define __NR_ssetmask 69
-#define __NR_setreuid 70
-#define __NR_setregid 71
-#define __NR_sigsuspend 72
-#define __NR_sigpending 73
-#define __NR_sethostname 74
-#define __NR_setrlimit 75
-#define __NR_getrlimit 76
-#define __NR_getrusage 77
-#define __NR_gettimeofday 78
-#define __NR_settimeofday 79
-#define __NR_getgroups 80
-#define __NR_setgroups 81
-#define __NR_select 82
-#define __NR_symlink 83
-#define __NR_oldlstat 84
-#define __NR_readlink 85
-#define __NR_uselib 86
-#define __NR_swapon 87
-#define __NR_reboot 88
-#define __NR_readdir 89
-#define __NR_mmap 90
-#define __NR_munmap 91
-#define __NR_truncate 92
-#define __NR_ftruncate 93
-#define __NR_fchmod 94
-#define __NR_fchown 95
-#define __NR_getpriority 96
-#define __NR_setpriority 97
-#define __NR_profil 98
-#define __NR_statfs 99
-#define __NR_fstatfs 100
-#define __NR_ioperm 101
-#define __NR_socketcall 102
-#define __NR_syslog 103
-#define __NR_setitimer 104
-#define __NR_getitimer 105
-#define __NR_stat 106
-#define __NR_lstat 107
-#define __NR_fstat 108
-#define __NR_olduname 109
-#define __NR_iopl 110
-#define __NR_vhangup 111
-#define __NR_idle 112
-#define __NR_vm86 113
-#define __NR_wait4 114
-#define __NR_swapoff 115
-#define __NR_sysinfo 116
-#define __NR_ipc 117
-#define __NR_fsync 118
-#define __NR_sigreturn 119
-#define __NR_clone 120
-#define __NR_setdomainname 121
-#define __NR_uname 122
-#define __NR_modify_ldt 123
-#define __NR_adjtimex 124
-#define __NR_mprotect 125
-#define __NR_sigprocmask 126
-#define __NR_create_module 127
-#define __NR_init_module 128
-#define __NR_delete_module 129
-#define __NR_get_kernel_syms 130
-#define __NR_quotactl 131
-#define __NR_getpgid 132
-#define __NR_fchdir 133
-#define __NR_bdflush 134
-#define __NR_sysfs 135
-#define __NR_personality 136
-#define __NR_afs_syscall 137
-#define __NR_setfsuid 138
-#define __NR_setfsgid 139
-#define __NR__llseek 140
-#define __NR_getdents 141
-#define __NR__newselect 142
-#define __NR_flock 143
-#define __NR_msync 144
-#define __NR_readv 145
-#define __NR_writev 146
-#define __NR_getsid 147
-#define __NR_fdatasync 148
-#define __NR__sysctl 149
-#define __NR_mlock 150
-#define __NR_munlock 151
-#define __NR_mlockall 152
-#define __NR_munlockall 153
-#define __NR_sched_setparam 154
-#define __NR_sched_getparam 155
-#define __NR_sched_setscheduler 156
-#define __NR_sched_getscheduler 157
-#define __NR_sched_yield 158
-#define __NR_sched_get_priority_max 159
-#define __NR_sched_get_priority_min 160
-#define __NR_sched_rr_get_interval 161
-#define __NR_nanosleep 162
-#define __NR_mremap 163
-#define __NR_setresuid 164
-#define __NR_getresuid 165
-#define __NR_query_module 166
-#define __NR_poll 167
-#define __NR_nfsservctl 168
-#define __NR_setresgid 169
-#define __NR_getresgid 170
-#define __NR_prctl 171
-#define __NR_rt_sigreturn 172
-#define __NR_rt_sigaction 173
-#define __NR_rt_sigprocmask 174
-#define __NR_rt_sigpending 175
-#define __NR_rt_sigtimedwait 176
-#define __NR_rt_sigqueueinfo 177
-#define __NR_rt_sigsuspend 178
-#define __NR_pread64 179
-#define __NR_pwrite64 180
-#define __NR_chown 181
-#define __NR_getcwd 182
-#define __NR_capget 183
-#define __NR_capset 184
-#define __NR_sigaltstack 185
-#define __NR_sendfile 186
-#define __NR_getpmsg 187
-#define __NR_putpmsg 188
-#define __NR_vfork 189
-#define __NR_ugetrlimit 190
-#define __NR_readahead 191
-#define __NR_pciconfig_read 198
-#define __NR_pciconfig_write 199
-#define __NR_pciconfig_iobase 200
-#define __NR_multiplexer 201
-#define __NR_getdents64 202
-#define __NR_pivot_root 203
-#define __NR_madvise 205
-#define __NR_mincore 206
-#define __NR_gettid 207
-#define __NR_tkill 208
-#define __NR_setxattr 209
-#define __NR_lsetxattr 210
-#define __NR_fsetxattr 211
-#define __NR_getxattr 212
-#define __NR_lgetxattr 213
-#define __NR_fgetxattr 214
-#define __NR_listxattr 215
-#define __NR_llistxattr 216
-#define __NR_flistxattr 217
-#define __NR_removexattr 218
-#define __NR_lremovexattr 219
-#define __NR_fremovexattr 220
-#define __NR_futex 221
-#define __NR_sched_setaffinity 222
-#define __NR_sched_getaffinity 223
-#define __NR_tuxcall 225
-#define __NR_io_setup 227
-#define __NR_io_destroy 228
-#define __NR_io_getevents 229
-#define __NR_io_submit 230
-#define __NR_io_cancel 231
-#define __NR_set_tid_address 232
-#define __NR_fadvise64 233
-#define __NR_exit_group 234
-#define __NR_lookup_dcookie 235
-#define __NR_epoll_create 236
-#define __NR_epoll_ctl 237
-#define __NR_epoll_wait 238
-#define __NR_remap_file_pages 239
-#define __NR_timer_create 240
-#define __NR_timer_settime 241
-#define __NR_timer_gettime 242
-#define __NR_timer_getoverrun 243
-#define __NR_timer_delete 244
-#define __NR_clock_settime 245
-#define __NR_clock_gettime 246
-#define __NR_clock_getres 247
-#define __NR_clock_nanosleep 248
-#define __NR_swapcontext 249
-#define __NR_tgkill 250
-#define __NR_utimes 251
-#define __NR_statfs64 252
-#define __NR_fstatfs64 253
-#define __NR_rtas 255
-#define __NR_sys_debug_setcontext 256
-#define __NR_migrate_pages 258
-#define __NR_mbind 259
-#define __NR_get_mempolicy 260
-#define __NR_set_mempolicy 261
-#define __NR_mq_open 262
-#define __NR_mq_unlink 263
-#define __NR_mq_timedsend 264
-#define __NR_mq_timedreceive 265
-#define __NR_mq_notify 266
-#define __NR_mq_getsetattr 267
-#define __NR_kexec_load 268
-#define __NR_add_key 269
-#define __NR_request_key 270
-#define __NR_keyctl 271
-#define __NR_waitid 272
-#define __NR_ioprio_set 273
-#define __NR_ioprio_get 274
-#define __NR_inotify_init 275
-#define __NR_inotify_add_watch 276
-#define __NR_inotify_rm_watch 277
-#define __NR_spu_run 278
-#define __NR_spu_create 279
-#define __NR_pselect6 280
-#define __NR_ppoll 281
-#define __NR_unshare 282
-#define __NR_splice 283
-#define __NR_tee 284
-#define __NR_vmsplice 285
-#define __NR_openat 286
-#define __NR_mkdirat 287
-#define __NR_mknodat 288
-#define __NR_fchownat 289
-#define __NR_futimesat 290
-#define __NR_newfstatat 291
-#define __NR_unlinkat 292
-#define __NR_renameat 293
-#define __NR_linkat 294
-#define __NR_symlinkat 295
-#define __NR_readlinkat 296
-#define __NR_fchmodat 297
-#define __NR_faccessat 298
-#define __NR_get_robust_list 299
-#define __NR_set_robust_list 300
-#define __NR_move_pages 301
-#define __NR_getcpu 302
-#define __NR_epoll_pwait 303
-#define __NR_utimensat 304
-#define __NR_signalfd 305
-#define __NR_timerfd_create 306
-#define __NR_eventfd 307
-#define __NR_sync_file_range2 308
-#define __NR_fallocate 309
-#define __NR_subpage_prot 310
-#define __NR_timerfd_settime 311
-#define __NR_timerfd_gettime 312
-#define __NR_signalfd4 313
-#define __NR_eventfd2 314
-#define __NR_epoll_create1 315
-#define __NR_dup3 316
-#define __NR_pipe2 317
-#define __NR_inotify_init1 318
-#define __NR_perf_event_open 319
-#define __NR_preadv 320
-#define __NR_pwritev 321
-#define __NR_rt_tgsigqueueinfo 322
-#define __NR_fanotify_init 323
-#define __NR_fanotify_mark 324
-#define __NR_prlimit64 325
-#define __NR_socket 326
-#define __NR_bind 327
-#define __NR_connect 328
-#define __NR_listen 329
-#define __NR_accept 330
-#define __NR_getsockname 331
-#define __NR_getpeername 332
-#define __NR_socketpair 333
-#define __NR_send 334
-#define __NR_sendto 335
-#define __NR_recv 336
-#define __NR_recvfrom 337
-#define __NR_shutdown 338
-#define __NR_setsockopt 339
-#define __NR_getsockopt 340
-#define __NR_sendmsg 341
-#define __NR_recvmsg 342
-#define __NR_recvmmsg 343
-#define __NR_accept4 344
-#define __NR_name_to_handle_at 345
-#define __NR_open_by_handle_at 346
-#define __NR_clock_adjtime 347
-#define __NR_syncfs 348
-#define __NR_sendmmsg 349
-#define __NR_setns 350
-#define __NR_process_vm_readv 351
-#define __NR_process_vm_writev 352
-#define __NR_finit_module 353
-#define __NR_kcmp 354
-#define __NR_sched_setattr 355
-#define __NR_sched_getattr 356
-#define __NR_renameat2 357
-#define __NR_seccomp 358
-#define __NR_getrandom 359
-#define __NR_memfd_create 360
-#define __NR_bpf 361
-#define __NR_execveat 362
-#define __NR_switch_endian 363
-#define __NR_userfaultfd 364
-#define __NR_membarrier 365
-#define __NR_mlock2 378
-#define __NR_copy_file_range 379
-#define __NR_preadv2 380
-#define __NR_pwritev2 381
-#define __NR_kexec_file_load 382
-#define __NR_statx 383
-#define __NR_pkey_alloc 384
-#define __NR_pkey_free 385
-#define __NR_pkey_mprotect 386
-#define __NR_rseq 387
-#define __NR_io_pgetevents 388
-#define __NR_semtimedop 392
-#define __NR_semget 393
-#define __NR_semctl 394
-#define __NR_shmget 395
-#define __NR_shmctl 396
-#define __NR_shmat 397
-#define __NR_shmdt 398
-#define __NR_msgget 399
-#define __NR_msgsnd 400
-#define __NR_msgrcv 401
-#define __NR_msgctl 402
-#define __NR_pidfd_send_signal 424
-#define __NR_io_uring_setup 425
-#define __NR_io_uring_enter 426
-#define __NR_io_uring_register 427
-#define __NR_open_tree 428
-#define __NR_move_mount 429
-#define __NR_fsopen 430
-#define __NR_fsconfig 431
-#define __NR_fsmount 432
-#define __NR_fspick 433
-#define __NR_pidfd_open 434
-#define __NR_clone3 435
-#define __NR_close_range 436
-#define __NR_openat2 437
-#define __NR_pidfd_getfd 438
-#define __NR_faccessat2 439
-#define __NR_process_madvise 440
-#define __NR_epoll_pwait2 441
-#define __NR_mount_setattr 442
-#define __NR_landlock_create_ruleset 444
-#define __NR_landlock_add_rule 445
-#define __NR_landlock_restrict_self 446
+#define __NR_restart_syscall	0
+#define __NR_exit	1
+#define __NR_fork	2
+#define __NR_read	3
+#define __NR_write	4
+#define __NR_open	5
+#define __NR_close	6
+#define __NR_waitpid	7
+#define __NR_creat	8
+#define __NR_link	9
+#define __NR_unlink	10
+#define __NR_execve	11
+#define __NR_chdir	12
+#define __NR_time	13
+#define __NR_mknod	14
+#define __NR_chmod	15
+#define __NR_lchown	16
+#define __NR_break	17
+#define __NR_oldstat	18
+#define __NR_lseek	19
+#define __NR_getpid	20
+#define __NR_mount	21
+#define __NR_umount	22
+#define __NR_setuid	23
+#define __NR_getuid	24
+#define __NR_stime	25
+#define __NR_ptrace	26
+#define __NR_alarm	27
+#define __NR_oldfstat	28
+#define __NR_pause	29
+#define __NR_utime	30
+#define __NR_stty	31
+#define __NR_gtty	32
+#define __NR_access	33
+#define __NR_nice	34
+#define __NR_ftime	35
+#define __NR_sync	36
+#define __NR_kill	37
+#define __NR_rename	38
+#define __NR_mkdir	39
+#define __NR_rmdir	40
+#define __NR_dup	41
+#define __NR_pipe	42
+#define __NR_times	43
+#define __NR_prof	44
+#define __NR_brk	45
+#define __NR_setgid	46
+#define __NR_getgid	47
+#define __NR_signal	48
+#define __NR_geteuid	49
+#define __NR_getegid	50
+#define __NR_acct	51
+#define __NR_umount2	52
+#define __NR_lock	53
+#define __NR_ioctl	54
+#define __NR_fcntl	55
+#define __NR_mpx	56
+#define __NR_setpgid	57
+#define __NR_ulimit	58
+#define __NR_oldolduname	59
+#define __NR_umask	60
+#define __NR_chroot	61
+#define __NR_ustat	62
+#define __NR_dup2	63
+#define __NR_getppid	64
+#define __NR_getpgrp	65
+#define __NR_setsid	66
+#define __NR_sigaction	67
+#define __NR_sgetmask	68
+#define __NR_ssetmask	69
+#define __NR_setreuid	70
+#define __NR_setregid	71
+#define __NR_sigsuspend	72
+#define __NR_sigpending	73
+#define __NR_sethostname	74
+#define __NR_setrlimit	75
+#define __NR_getrlimit	76
+#define __NR_getrusage	77
+#define __NR_gettimeofday	78
+#define __NR_settimeofday	79
+#define __NR_getgroups	80
+#define __NR_setgroups	81
+#define __NR_select	82
+#define __NR_symlink	83
+#define __NR_oldlstat	84
+#define __NR_readlink	85
+#define __NR_uselib	86
+#define __NR_swapon	87
+#define __NR_reboot	88
+#define __NR_readdir	89
+#define __NR_mmap	90
+#define __NR_munmap	91
+#define __NR_truncate	92
+#define __NR_ftruncate	93
+#define __NR_fchmod	94
+#define __NR_fchown	95
+#define __NR_getpriority	96
+#define __NR_setpriority	97
+#define __NR_profil	98
+#define __NR_statfs	99
+#define __NR_fstatfs	100
+#define __NR_ioperm	101
+#define __NR_socketcall	102
+#define __NR_syslog	103
+#define __NR_setitimer	104
+#define __NR_getitimer	105
+#define __NR_stat	106
+#define __NR_lstat	107
+#define __NR_fstat	108
+#define __NR_olduname	109
+#define __NR_iopl	110
+#define __NR_vhangup	111
+#define __NR_idle	112
+#define __NR_vm86	113
+#define __NR_wait4	114
+#define __NR_swapoff	115
+#define __NR_sysinfo	116
+#define __NR_ipc	117
+#define __NR_fsync	118
+#define __NR_sigreturn	119
+#define __NR_clone	120
+#define __NR_setdomainname	121
+#define __NR_uname	122
+#define __NR_modify_ldt	123
+#define __NR_adjtimex	124
+#define __NR_mprotect	125
+#define __NR_sigprocmask	126
+#define __NR_create_module	127
+#define __NR_init_module	128
+#define __NR_delete_module	129
+#define __NR_get_kernel_syms	130
+#define __NR_quotactl	131
+#define __NR_getpgid	132
+#define __NR_fchdir	133
+#define __NR_bdflush	134
+#define __NR_sysfs	135
+#define __NR_personality	136
+#define __NR_afs_syscall	137
+#define __NR_setfsuid	138
+#define __NR_setfsgid	139
+#define __NR__llseek	140
+#define __NR_getdents	141
+#define __NR__newselect	142
+#define __NR_flock	143
+#define __NR_msync	144
+#define __NR_readv	145
+#define __NR_writev	146
+#define __NR_getsid	147
+#define __NR_fdatasync	148
+#define __NR__sysctl	149
+#define __NR_mlock	150
+#define __NR_munlock	151
+#define __NR_mlockall	152
+#define __NR_munlockall	153
+#define __NR_sched_setparam	154
+#define __NR_sched_getparam	155
+#define __NR_sched_setscheduler	156
+#define __NR_sched_getscheduler	157
+#define __NR_sched_yield	158
+#define __NR_sched_get_priority_max	159
+#define __NR_sched_get_priority_min	160
+#define __NR_sched_rr_get_interval	161
+#define __NR_nanosleep	162
+#define __NR_mremap	163
+#define __NR_setresuid	164
+#define __NR_getresuid	165
+#define __NR_query_module	166
+#define __NR_poll	167
+#define __NR_nfsservctl	168
+#define __NR_setresgid	169
+#define __NR_getresgid	170
+#define __NR_prctl	171
+#define __NR_rt_sigreturn	172
+#define __NR_rt_sigaction	173
+#define __NR_rt_sigprocmask	174
+#define __NR_rt_sigpending	175
+#define __NR_rt_sigtimedwait	176
+#define __NR_rt_sigqueueinfo	177
+#define __NR_rt_sigsuspend	178
+#define __NR_pread64	179
+#define __NR_pwrite64	180
+#define __NR_chown	181
+#define __NR_getcwd	182
+#define __NR_capget	183
+#define __NR_capset	184
+#define __NR_sigaltstack	185
+#define __NR_sendfile	186
+#define __NR_getpmsg	187
+#define __NR_putpmsg	188
+#define __NR_vfork	189
+#define __NR_ugetrlimit	190
+#define __NR_readahead	191
+#define __NR_pciconfig_read	198
+#define __NR_pciconfig_write	199
+#define __NR_pciconfig_iobase	200
+#define __NR_multiplexer	201
+#define __NR_getdents64	202
+#define __NR_pivot_root	203
+#define __NR_madvise	205
+#define __NR_mincore	206
+#define __NR_gettid	207
+#define __NR_tkill	208
+#define __NR_setxattr	209
+#define __NR_lsetxattr	210
+#define __NR_fsetxattr	211
+#define __NR_getxattr	212
+#define __NR_lgetxattr	213
+#define __NR_fgetxattr	214
+#define __NR_listxattr	215
+#define __NR_llistxattr	216
+#define __NR_flistxattr	217
+#define __NR_removexattr	218
+#define __NR_lremovexattr	219
+#define __NR_fremovexattr	220
+#define __NR_futex	221
+#define __NR_sched_setaffinity	222
+#define __NR_sched_getaffinity	223
+#define __NR_tuxcall	225
+#define __NR_io_setup	227
+#define __NR_io_destroy	228
+#define __NR_io_getevents	229
+#define __NR_io_submit	230
+#define __NR_io_cancel	231
+#define __NR_set_tid_address	232
+#define __NR_fadvise64	233
+#define __NR_exit_group	234
+#define __NR_lookup_dcookie	235
+#define __NR_epoll_create	236
+#define __NR_epoll_ctl	237
+#define __NR_epoll_wait	238
+#define __NR_remap_file_pages	239
+#define __NR_timer_create	240
+#define __NR_timer_settime	241
+#define __NR_timer_gettime	242
+#define __NR_timer_getoverrun	243
+#define __NR_timer_delete	244
+#define __NR_clock_settime	245
+#define __NR_clock_gettime	246
+#define __NR_clock_getres	247
+#define __NR_clock_nanosleep	248
+#define __NR_swapcontext	249
+#define __NR_tgkill	250
+#define __NR_utimes	251
+#define __NR_statfs64	252
+#define __NR_fstatfs64	253
+#define __NR_rtas	255
+#define __NR_sys_debug_setcontext	256
+#define __NR_migrate_pages	258
+#define __NR_mbind	259
+#define __NR_get_mempolicy	260
+#define __NR_set_mempolicy	261
+#define __NR_mq_open	262
+#define __NR_mq_unlink	263
+#define __NR_mq_timedsend	264
+#define __NR_mq_timedreceive	265
+#define __NR_mq_notify	266
+#define __NR_mq_getsetattr	267
+#define __NR_kexec_load	268
+#define __NR_add_key	269
+#define __NR_request_key	270
+#define __NR_keyctl	271
+#define __NR_waitid	272
+#define __NR_ioprio_set	273
+#define __NR_ioprio_get	274
+#define __NR_inotify_init	275
+#define __NR_inotify_add_watch	276
+#define __NR_inotify_rm_watch	277
+#define __NR_spu_run	278
+#define __NR_spu_create	279
+#define __NR_pselect6	280
+#define __NR_ppoll	281
+#define __NR_unshare	282
+#define __NR_splice	283
+#define __NR_tee	284
+#define __NR_vmsplice	285
+#define __NR_openat	286
+#define __NR_mkdirat	287
+#define __NR_mknodat	288
+#define __NR_fchownat	289
+#define __NR_futimesat	290
+#define __NR_newfstatat	291
+#define __NR_unlinkat	292
+#define __NR_renameat	293
+#define __NR_linkat	294
+#define __NR_symlinkat	295
+#define __NR_readlinkat	296
+#define __NR_fchmodat	297
+#define __NR_faccessat	298
+#define __NR_get_robust_list	299
+#define __NR_set_robust_list	300
+#define __NR_move_pages	301
+#define __NR_getcpu	302
+#define __NR_epoll_pwait	303
+#define __NR_utimensat	304
+#define __NR_signalfd	305
+#define __NR_timerfd_create	306
+#define __NR_eventfd	307
+#define __NR_sync_file_range2	308
+#define __NR_fallocate	309
+#define __NR_subpage_prot	310
+#define __NR_timerfd_settime	311
+#define __NR_timerfd_gettime	312
+#define __NR_signalfd4	313
+#define __NR_eventfd2	314
+#define __NR_epoll_create1	315
+#define __NR_dup3	316
+#define __NR_pipe2	317
+#define __NR_inotify_init1	318
+#define __NR_perf_event_open	319
+#define __NR_preadv	320
+#define __NR_pwritev	321
+#define __NR_rt_tgsigqueueinfo	322
+#define __NR_fanotify_init	323
+#define __NR_fanotify_mark	324
+#define __NR_prlimit64	325
+#define __NR_socket	326
+#define __NR_bind	327
+#define __NR_connect	328
+#define __NR_listen	329
+#define __NR_accept	330
+#define __NR_getsockname	331
+#define __NR_getpeername	332
+#define __NR_socketpair	333
+#define __NR_send	334
+#define __NR_sendto	335
+#define __NR_recv	336
+#define __NR_recvfrom	337
+#define __NR_shutdown	338
+#define __NR_setsockopt	339
+#define __NR_getsockopt	340
+#define __NR_sendmsg	341
+#define __NR_recvmsg	342
+#define __NR_recvmmsg	343
+#define __NR_accept4	344
+#define __NR_name_to_handle_at	345
+#define __NR_open_by_handle_at	346
+#define __NR_clock_adjtime	347
+#define __NR_syncfs	348
+#define __NR_sendmmsg	349
+#define __NR_setns	350
+#define __NR_process_vm_readv	351
+#define __NR_process_vm_writev	352
+#define __NR_finit_module	353
+#define __NR_kcmp	354
+#define __NR_sched_setattr	355
+#define __NR_sched_getattr	356
+#define __NR_renameat2	357
+#define __NR_seccomp	358
+#define __NR_getrandom	359
+#define __NR_memfd_create	360
+#define __NR_bpf	361
+#define __NR_execveat	362
+#define __NR_switch_endian	363
+#define __NR_userfaultfd	364
+#define __NR_membarrier	365
+#define __NR_mlock2	378
+#define __NR_copy_file_range	379
+#define __NR_preadv2	380
+#define __NR_pwritev2	381
+#define __NR_kexec_file_load	382
+#define __NR_statx	383
+#define __NR_pkey_alloc	384
+#define __NR_pkey_free	385
+#define __NR_pkey_mprotect	386
+#define __NR_rseq	387
+#define __NR_io_pgetevents	388
+#define __NR_semtimedop	392
+#define __NR_semget	393
+#define __NR_semctl	394
+#define __NR_shmget	395
+#define __NR_shmctl	396
+#define __NR_shmat	397
+#define __NR_shmdt	398
+#define __NR_msgget	399
+#define __NR_msgsnd	400
+#define __NR_msgrcv	401
+#define __NR_msgctl	402
+#define __NR_pidfd_send_signal	424
+#define __NR_io_uring_setup	425
+#define __NR_io_uring_enter	426
+#define __NR_io_uring_register	427
+#define __NR_open_tree	428
+#define __NR_move_mount	429
+#define __NR_fsopen	430
+#define __NR_fsconfig	431
+#define __NR_fsmount	432
+#define __NR_fspick	433
+#define __NR_pidfd_open	434
+#define __NR_clone3	435
+#define __NR_close_range	436
+#define __NR_openat2	437
+#define __NR_pidfd_getfd	438
+#define __NR_faccessat2	439
+#define __NR_process_madvise	440
+#define __NR_epoll_pwait2	441
 
 
-#endif /* _ASM_UNISTD_64_H */
+#endif /* _ASM_POWERPC_UNISTD_64_H */
diff --git a/linux-headers/asm-s390/unistd_32.h b/linux-headers/asm-s390/unistd_32.h
index e8cd34334f..c94d2c3a22 100644
--- a/linux-headers/asm-s390/unistd_32.h
+++ b/linux-headers/asm-s390/unistd_32.h
@@ -414,9 +414,5 @@
 #define __NR_faccessat2 439
 #define __NR_process_madvise 440
 #define __NR_epoll_pwait2 441
-#define __NR_mount_setattr 442
-#define __NR_landlock_create_ruleset 444
-#define __NR_landlock_add_rule 445
-#define __NR_landlock_restrict_self 446
 
 #endif /* _ASM_S390_UNISTD_32_H */
diff --git a/linux-headers/asm-s390/unistd_64.h b/linux-headers/asm-s390/unistd_64.h
index 86830e1e83..984a06b7eb 100644
--- a/linux-headers/asm-s390/unistd_64.h
+++ b/linux-headers/asm-s390/unistd_64.h
@@ -362,9 +362,5 @@
 #define __NR_faccessat2 439
 #define __NR_process_madvise 440
 #define __NR_epoll_pwait2 441
-#define __NR_mount_setattr 442
-#define __NR_landlock_create_ruleset 444
-#define __NR_landlock_add_rule 445
-#define __NR_landlock_restrict_self 446
 
 #endif /* _ASM_S390_UNISTD_64_H */
diff --git a/linux-headers/asm-x86/kvm.h b/linux-headers/asm-x86/kvm.h
index 0662f644aa..8e76d3701d 100644
--- a/linux-headers/asm-x86/kvm.h
+++ b/linux-headers/asm-x86/kvm.h
@@ -112,7 +112,6 @@ struct kvm_ioapic_state {
 #define KVM_NR_IRQCHIPS          3
 
 #define KVM_RUN_X86_SMM		 (1 << 0)
-#define KVM_RUN_X86_BUS_LOCK     (1 << 1)
 
 /* for KVM_GET_REGS and KVM_SET_REGS */
 struct kvm_regs {
@@ -437,8 +436,6 @@ struct kvm_vmx_nested_state_hdr {
 		__u16 flags;
 	} smm;
 
-	__u16 pad;
-
 	__u32 flags;
 	__u64 preemption_timer_deadline;
 };
diff --git a/linux-headers/asm-x86/unistd_32.h b/linux-headers/asm-x86/unistd_32.h
index 8f6ac8c19f..18fb99dfa2 100644
--- a/linux-headers/asm-x86/unistd_32.h
+++ b/linux-headers/asm-x86/unistd_32.h
@@ -432,10 +432,6 @@
 #define __NR_faccessat2 439
 #define __NR_process_madvise 440
 #define __NR_epoll_pwait2 441
-#define __NR_mount_setattr 442
-#define __NR_landlock_create_ruleset 444
-#define __NR_landlock_add_rule 445
-#define __NR_landlock_restrict_self 446
 
 
 #endif /* _ASM_X86_UNISTD_32_H */
diff --git a/linux-headers/asm-x86/unistd_64.h b/linux-headers/asm-x86/unistd_64.h
index bb187a9268..bde959328d 100644
--- a/linux-headers/asm-x86/unistd_64.h
+++ b/linux-headers/asm-x86/unistd_64.h
@@ -354,10 +354,6 @@
 #define __NR_faccessat2 439
 #define __NR_process_madvise 440
 #define __NR_epoll_pwait2 441
-#define __NR_mount_setattr 442
-#define __NR_landlock_create_ruleset 444
-#define __NR_landlock_add_rule 445
-#define __NR_landlock_restrict_self 446
 
 
 #endif /* _ASM_X86_UNISTD_64_H */
diff --git a/linux-headers/asm-x86/unistd_x32.h b/linux-headers/asm-x86/unistd_x32.h
index 4edd0103ac..4ff6b17d3b 100644
--- a/linux-headers/asm-x86/unistd_x32.h
+++ b/linux-headers/asm-x86/unistd_x32.h
@@ -307,10 +307,6 @@
 #define __NR_faccessat2 (__X32_SYSCALL_BIT + 439)
 #define __NR_process_madvise (__X32_SYSCALL_BIT + 440)
 #define __NR_epoll_pwait2 (__X32_SYSCALL_BIT + 441)
-#define __NR_mount_setattr (__X32_SYSCALL_BIT + 442)
-#define __NR_landlock_create_ruleset (__X32_SYSCALL_BIT + 444)
-#define __NR_landlock_add_rule (__X32_SYSCALL_BIT + 445)
-#define __NR_landlock_restrict_self (__X32_SYSCALL_BIT + 446)
 #define __NR_rt_sigaction (__X32_SYSCALL_BIT + 512)
 #define __NR_rt_sigreturn (__X32_SYSCALL_BIT + 513)
 #define __NR_ioctl (__X32_SYSCALL_BIT + 514)
diff --git a/linux-headers/linux/kvm.h b/linux-headers/linux/kvm.h
index 20d6a263bb..897f831374 100644
--- a/linux-headers/linux/kvm.h
+++ b/linux-headers/linux/kvm.h
@@ -8,7 +8,6 @@
  * Note: you must update KVM_API_VERSION if you change this interface.
  */
 
-#include <linux/const.h>
 #include <linux/types.h>
 
 #include <linux/ioctl.h>
@@ -217,20 +216,6 @@ struct kvm_hyperv_exit {
 	} u;
 };
 
-struct kvm_xen_exit {
-#define KVM_EXIT_XEN_HCALL          1
-	__u32 type;
-	union {
-		struct {
-			__u32 longmode;
-			__u32 cpl;
-			__u64 input;
-			__u64 result;
-			__u64 params[6];
-		} hcall;
-	} u;
-};
-
 #define KVM_S390_GET_SKEYS_NONE   1
 #define KVM_S390_SKEYS_MAX        1048576
 
@@ -266,9 +251,6 @@ struct kvm_xen_exit {
 #define KVM_EXIT_X86_RDMSR        29
 #define KVM_EXIT_X86_WRMSR        30
 #define KVM_EXIT_DIRTY_RING_FULL  31
-#define KVM_EXIT_AP_RESET_HOLD    32
-#define KVM_EXIT_X86_BUS_LOCK     33
-#define KVM_EXIT_XEN              34
 
 /* For KVM_EXIT_INTERNAL_ERROR */
 /* Emulate instruction failed. */
@@ -445,8 +427,6 @@ struct kvm_run {
 			__u32 index; /* kernel -> user */
 			__u64 data; /* kernel <-> user */
 		} msr;
-		/* KVM_EXIT_XEN */
-		struct kvm_xen_exit xen;
 		/* Fix the size of the union. */
 		char padding[256];
 	};
@@ -593,7 +573,6 @@ struct kvm_vapic_addr {
 #define KVM_MP_STATE_CHECK_STOP        6
 #define KVM_MP_STATE_OPERATING         7
 #define KVM_MP_STATE_LOAD              8
-#define KVM_MP_STATE_AP_RESET_HOLD     9
 
 struct kvm_mp_state {
 	__u32 mp_state;
@@ -1077,12 +1056,6 @@ struct kvm_ppc_resize_hpt {
 #define KVM_CAP_ENFORCE_PV_FEATURE_CPUID 190
 #define KVM_CAP_SYS_HYPERV_CPUID 191
 #define KVM_CAP_DIRTY_LOG_RING 192
-#define KVM_CAP_X86_BUS_LOCK_EXIT 193
-#define KVM_CAP_PPC_DAWR1 194
-#define KVM_CAP_SET_GUEST_DEBUG2 195
-#define KVM_CAP_SGX_ATTRIBUTE 196
-#define KVM_CAP_VM_COPY_ENC_CONTEXT_FROM 197
-#define KVM_CAP_PTP_KVM 198
 
 #ifdef KVM_CAP_IRQ_ROUTING
 
@@ -1156,11 +1129,6 @@ struct kvm_x86_mce {
 #endif
 
 #ifdef KVM_CAP_XEN_HVM
-#define KVM_XEN_HVM_CONFIG_HYPERCALL_MSR	(1 << 0)
-#define KVM_XEN_HVM_CONFIG_INTERCEPT_HCALL	(1 << 1)
-#define KVM_XEN_HVM_CONFIG_SHARED_INFO		(1 << 2)
-#define KVM_XEN_HVM_CONFIG_RUNSTATE		(1 << 3)
-
 struct kvm_xen_hvm_config {
 	__u32 flags;
 	__u32 msr;
@@ -1595,57 +1563,6 @@ struct kvm_pv_cmd {
 /* Available with KVM_CAP_DIRTY_LOG_RING */
 #define KVM_RESET_DIRTY_RINGS		_IO(KVMIO, 0xc7)
 
-/* Per-VM Xen attributes */
-#define KVM_XEN_HVM_GET_ATTR	_IOWR(KVMIO, 0xc8, struct kvm_xen_hvm_attr)
-#define KVM_XEN_HVM_SET_ATTR	_IOW(KVMIO,  0xc9, struct kvm_xen_hvm_attr)
-
-struct kvm_xen_hvm_attr {
-	__u16 type;
-	__u16 pad[3];
-	union {
-		__u8 long_mode;
-		__u8 vector;
-		struct {
-			__u64 gfn;
-		} shared_info;
-		__u64 pad[8];
-	} u;
-};
-
-/* Available with KVM_CAP_XEN_HVM / KVM_XEN_HVM_CONFIG_SHARED_INFO */
-#define KVM_XEN_ATTR_TYPE_LONG_MODE		0x0
-#define KVM_XEN_ATTR_TYPE_SHARED_INFO		0x1
-#define KVM_XEN_ATTR_TYPE_UPCALL_VECTOR		0x2
-
-/* Per-vCPU Xen attributes */
-#define KVM_XEN_VCPU_GET_ATTR	_IOWR(KVMIO, 0xca, struct kvm_xen_vcpu_attr)
-#define KVM_XEN_VCPU_SET_ATTR	_IOW(KVMIO,  0xcb, struct kvm_xen_vcpu_attr)
-
-struct kvm_xen_vcpu_attr {
-	__u16 type;
-	__u16 pad[3];
-	union {
-		__u64 gpa;
-		__u64 pad[8];
-		struct {
-			__u64 state;
-			__u64 state_entry_time;
-			__u64 time_running;
-			__u64 time_runnable;
-			__u64 time_blocked;
-			__u64 time_offline;
-		} runstate;
-	} u;
-};
-
-/* Available with KVM_CAP_XEN_HVM / KVM_XEN_HVM_CONFIG_SHARED_INFO */
-#define KVM_XEN_VCPU_ATTR_TYPE_VCPU_INFO	0x0
-#define KVM_XEN_VCPU_ATTR_TYPE_VCPU_TIME_INFO	0x1
-#define KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADDR	0x2
-#define KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_CURRENT	0x3
-#define KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_DATA	0x4
-#define KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADJUST	0x5
-
 /* Secure Encrypted Virtualization command */
 enum sev_cmd_id {
 	/* Guest initialization commands */
@@ -1676,8 +1593,6 @@ enum sev_cmd_id {
 	KVM_SEV_CERT_EXPORT,
 	/* Attestation report */
 	KVM_SEV_GET_ATTESTATION_REPORT,
-	/* Guest Migration Extension */
-	KVM_SEV_SEND_CANCEL,
 
 	KVM_SEV_NR_MAX,
 };
@@ -1736,45 +1651,6 @@ struct kvm_sev_attestation_report {
 	__u32 len;
 };
 
-struct kvm_sev_send_start {
-	__u32 policy;
-	__u64 pdh_cert_uaddr;
-	__u32 pdh_cert_len;
-	__u64 plat_certs_uaddr;
-	__u32 plat_certs_len;
-	__u64 amd_certs_uaddr;
-	__u32 amd_certs_len;
-	__u64 session_uaddr;
-	__u32 session_len;
-};
-
-struct kvm_sev_send_update_data {
-	__u64 hdr_uaddr;
-	__u32 hdr_len;
-	__u64 guest_uaddr;
-	__u32 guest_len;
-	__u64 trans_uaddr;
-	__u32 trans_len;
-};
-
-struct kvm_sev_receive_start {
-	__u32 handle;
-	__u32 policy;
-	__u64 pdh_uaddr;
-	__u32 pdh_len;
-	__u64 session_uaddr;
-	__u32 session_len;
-};
-
-struct kvm_sev_receive_update_data {
-	__u64 hdr_uaddr;
-	__u32 hdr_len;
-	__u64 guest_uaddr;
-	__u32 guest_len;
-	__u64 trans_uaddr;
-	__u32 trans_len;
-};
-
 #define KVM_DEV_ASSIGN_ENABLE_IOMMU	(1 << 0)
 #define KVM_DEV_ASSIGN_PCI_2_3		(1 << 1)
 #define KVM_DEV_ASSIGN_MASK_INTX	(1 << 2)
@@ -1880,8 +1756,8 @@ struct kvm_hyperv_eventfd {
  * conversion after harvesting an entry.  Also, it must not skip any
  * dirty bits, so that dirty bits are always harvested in sequence.
  */
-#define KVM_DIRTY_GFN_F_DIRTY           _BITUL(0)
-#define KVM_DIRTY_GFN_F_RESET           _BITUL(1)
+#define KVM_DIRTY_GFN_F_DIRTY           BIT(0)
+#define KVM_DIRTY_GFN_F_RESET           BIT(1)
 #define KVM_DIRTY_GFN_F_MASK            0x3
 
 /*
@@ -1896,7 +1772,4 @@ struct kvm_dirty_gfn {
 	__u64 offset;
 };
 
-#define KVM_BUS_LOCK_DETECTION_OFF             (1 << 0)
-#define KVM_BUS_LOCK_DETECTION_EXIT            (1 << 1)
-
 #endif /* __LINUX_KVM_H */
diff --git a/linux-headers/linux/userfaultfd.h b/linux-headers/linux/userfaultfd.h
index b9ac97b70f..1ba9a9feeb 100644
--- a/linux-headers/linux/userfaultfd.h
+++ b/linux-headers/linux/userfaultfd.h
@@ -19,19 +19,15 @@
  * means the userland is reading).
  */
 #define UFFD_API ((__u64)0xAA)
-#define UFFD_API_REGISTER_MODES (UFFDIO_REGISTER_MODE_MISSING |	\
-				 UFFDIO_REGISTER_MODE_WP |	\
-				 UFFDIO_REGISTER_MODE_MINOR)
 #define UFFD_API_FEATURES (UFFD_FEATURE_PAGEFAULT_FLAG_WP |	\
 			   UFFD_FEATURE_EVENT_FORK |		\
 			   UFFD_FEATURE_EVENT_REMAP |		\
-			   UFFD_FEATURE_EVENT_REMOVE |		\
+			   UFFD_FEATURE_EVENT_REMOVE |	\
 			   UFFD_FEATURE_EVENT_UNMAP |		\
 			   UFFD_FEATURE_MISSING_HUGETLBFS |	\
 			   UFFD_FEATURE_MISSING_SHMEM |		\
 			   UFFD_FEATURE_SIGBUS |		\
-			   UFFD_FEATURE_THREAD_ID |		\
-			   UFFD_FEATURE_MINOR_HUGETLBFS)
+			   UFFD_FEATURE_THREAD_ID)
 #define UFFD_API_IOCTLS				\
 	((__u64)1 << _UFFDIO_REGISTER |		\
 	 (__u64)1 << _UFFDIO_UNREGISTER |	\
@@ -40,12 +36,10 @@
 	((__u64)1 << _UFFDIO_WAKE |		\
 	 (__u64)1 << _UFFDIO_COPY |		\
 	 (__u64)1 << _UFFDIO_ZEROPAGE |		\
-	 (__u64)1 << _UFFDIO_WRITEPROTECT |	\
-	 (__u64)1 << _UFFDIO_CONTINUE)
+	 (__u64)1 << _UFFDIO_WRITEPROTECT)
 #define UFFD_API_RANGE_IOCTLS_BASIC		\
 	((__u64)1 << _UFFDIO_WAKE |		\
-	 (__u64)1 << _UFFDIO_COPY |		\
-	 (__u64)1 << _UFFDIO_CONTINUE)
+	 (__u64)1 << _UFFDIO_COPY)
 
 /*
  * Valid ioctl command number range with this API is from 0x00 to
@@ -61,7 +55,6 @@
 #define _UFFDIO_COPY			(0x03)
 #define _UFFDIO_ZEROPAGE		(0x04)
 #define _UFFDIO_WRITEPROTECT		(0x06)
-#define _UFFDIO_CONTINUE		(0x07)
 #define _UFFDIO_API			(0x3F)
 
 /* userfaultfd ioctl ids */
@@ -80,8 +73,6 @@
 				      struct uffdio_zeropage)
 #define UFFDIO_WRITEPROTECT	_IOWR(UFFDIO, _UFFDIO_WRITEPROTECT, \
 				      struct uffdio_writeprotect)
-#define UFFDIO_CONTINUE		_IOR(UFFDIO, _UFFDIO_CONTINUE,	\
-				     struct uffdio_continue)
 
 /* read() structure */
 struct uffd_msg {
@@ -136,7 +127,6 @@ struct uffd_msg {
 /* flags for UFFD_EVENT_PAGEFAULT */
 #define UFFD_PAGEFAULT_FLAG_WRITE	(1<<0)	/* If this was a write fault */
 #define UFFD_PAGEFAULT_FLAG_WP		(1<<1)	/* If reason is VM_UFFD_WP */
-#define UFFD_PAGEFAULT_FLAG_MINOR	(1<<2)	/* If reason is VM_UFFD_MINOR */
 
 struct uffdio_api {
 	/* userland asks for an API number and the features to enable */
@@ -181,10 +171,6 @@ struct uffdio_api {
 	 *
 	 * UFFD_FEATURE_THREAD_ID pid of the page faulted task_struct will
 	 * be returned, if feature is not requested 0 will be returned.
-	 *
-	 * UFFD_FEATURE_MINOR_HUGETLBFS indicates that minor faults
-	 * can be intercepted (via REGISTER_MODE_MINOR) for
-	 * hugetlbfs-backed pages.
 	 */
 #define UFFD_FEATURE_PAGEFAULT_FLAG_WP		(1<<0)
 #define UFFD_FEATURE_EVENT_FORK			(1<<1)
@@ -195,7 +181,6 @@ struct uffdio_api {
 #define UFFD_FEATURE_EVENT_UNMAP		(1<<6)
 #define UFFD_FEATURE_SIGBUS			(1<<7)
 #define UFFD_FEATURE_THREAD_ID			(1<<8)
-#define UFFD_FEATURE_MINOR_HUGETLBFS		(1<<9)
 	__u64 features;
 
 	__u64 ioctls;
@@ -210,7 +195,6 @@ struct uffdio_register {
 	struct uffdio_range range;
 #define UFFDIO_REGISTER_MODE_MISSING	((__u64)1<<0)
 #define UFFDIO_REGISTER_MODE_WP		((__u64)1<<1)
-#define UFFDIO_REGISTER_MODE_MINOR	((__u64)1<<2)
 	__u64 mode;
 
 	/*
@@ -273,18 +257,6 @@ struct uffdio_writeprotect {
 	__u64 mode;
 };
 
-struct uffdio_continue {
-	struct uffdio_range range;
-#define UFFDIO_CONTINUE_MODE_DONTWAKE		((__u64)1<<0)
-	__u64 mode;
-
-	/*
-	 * Fields below here are written by the ioctl and must be at the end:
-	 * the copy_from_user will not read past here.
-	 */
-	__s64 mapped;
-};
-
 /*
  * Flags for the userfaultfd(2) system call itself.
  */
diff --git a/linux-headers/linux/vfio.h b/linux-headers/linux/vfio.h
index e680594f27..609099e455 100644
--- a/linux-headers/linux/vfio.h
+++ b/linux-headers/linux/vfio.h
@@ -46,12 +46,6 @@
  */
 #define VFIO_NOIOMMU_IOMMU		8
 
-/* Supports VFIO_DMA_UNMAP_FLAG_ALL */
-#define VFIO_UNMAP_ALL			9
-
-/* Supports the vaddr flag for DMA map and unmap */
-#define VFIO_UPDATE_VADDR		10
-
 /*
  * The IOCTL interface is designed for extensibility by embedding the
  * structure length (argsz) and flags into structures passed between
@@ -335,8 +329,6 @@ struct vfio_region_info_cap_type {
 /* 10de vendor PCI sub-types */
 /*
  * NVIDIA GPU NVlink2 RAM is coherent RAM mapped onto the host address space.
- *
- * Deprecated, region no longer provided
  */
 #define VFIO_REGION_SUBTYPE_NVIDIA_NVLINK2_RAM	(1)
 
@@ -344,8 +336,6 @@ struct vfio_region_info_cap_type {
 /*
  * IBM NPU NVlink2 ATSD (Address Translation Shootdown) register of NPU
  * to do TLB invalidation on a GPU.
- *
- * Deprecated, region no longer provided
  */
 #define VFIO_REGION_SUBTYPE_IBM_NVLINK2_ATSD	(1)
 
@@ -645,8 +635,6 @@ struct vfio_device_migration_info {
  * Capability with compressed real address (aka SSA - small system address)
  * where GPU RAM is mapped on a system bus. Used by a GPU for DMA routing
  * and by the userspace to associate a NVLink bridge with a GPU.
- *
- * Deprecated, capability no longer provided
  */
 #define VFIO_REGION_INFO_CAP_NVLINK2_SSATGT	4
 
@@ -661,8 +649,6 @@ struct vfio_region_info_cap_nvlink2_ssatgt {
  * property in the device tree. The value is fixed in the hardware
  * and failing to provide the correct value results in the link
  * not working with no indication from the driver why.
- *
- * Deprecated, capability no longer provided
  */
 #define VFIO_REGION_INFO_CAP_NVLINK2_LNKSPD	5
 
@@ -1088,22 +1074,12 @@ struct vfio_iommu_type1_info_dma_avail {
  *
  * Map process virtual addresses to IO virtual addresses using the
  * provided struct vfio_dma_map. Caller sets argsz. READ &/ WRITE required.
- *
- * If flags & VFIO_DMA_MAP_FLAG_VADDR, update the base vaddr for iova, and
- * unblock translation of host virtual addresses in the iova range.  The vaddr
- * must have previously been invalidated with VFIO_DMA_UNMAP_FLAG_VADDR.  To
- * maintain memory consistency within the user application, the updated vaddr
- * must address the same memory object as originally mapped.  Failure to do so
- * will result in user memory corruption and/or device misbehavior.  iova and
- * size must match those in the original MAP_DMA call.  Protection is not
- * changed, and the READ & WRITE flags must be 0.
  */
 struct vfio_iommu_type1_dma_map {
 	__u32	argsz;
 	__u32	flags;
 #define VFIO_DMA_MAP_FLAG_READ (1 << 0)		/* readable from device */
 #define VFIO_DMA_MAP_FLAG_WRITE (1 << 1)	/* writable from device */
-#define VFIO_DMA_MAP_FLAG_VADDR (1 << 2)
 	__u64	vaddr;				/* Process virtual address */
 	__u64	iova;				/* IO virtual address */
 	__u64	size;				/* Size of mapping (bytes) */
@@ -1126,7 +1102,6 @@ struct vfio_bitmap {
  * field.  No guarantee is made to the user that arbitrary unmaps of iova
  * or size different from those used in the original mapping call will
  * succeed.
- *
  * VFIO_DMA_UNMAP_FLAG_GET_DIRTY_BITMAP should be set to get the dirty bitmap
  * before unmapping IO virtual addresses. When this flag is set, the user must
  * provide a struct vfio_bitmap in data[]. User must provide zero-allocated
@@ -1136,21 +1111,11 @@ struct vfio_bitmap {
  * indicates that the page at that offset from iova is dirty. A Bitmap of the
  * pages in the range of unmapped size is returned in the user-provided
  * vfio_bitmap.data.
- *
- * If flags & VFIO_DMA_UNMAP_FLAG_ALL, unmap all addresses.  iova and size
- * must be 0.  This cannot be combined with the get-dirty-bitmap flag.
- *
- * If flags & VFIO_DMA_UNMAP_FLAG_VADDR, do not unmap, but invalidate host
- * virtual addresses in the iova range.  Tasks that attempt to translate an
- * iova's vaddr will block.  DMA to already-mapped pages continues.  This
- * cannot be combined with the get-dirty-bitmap flag.
  */
 struct vfio_iommu_type1_dma_unmap {
 	__u32	argsz;
 	__u32	flags;
 #define VFIO_DMA_UNMAP_FLAG_GET_DIRTY_BITMAP (1 << 0)
-#define VFIO_DMA_UNMAP_FLAG_ALL		     (1 << 1)
-#define VFIO_DMA_UNMAP_FLAG_VADDR	     (1 << 2)
 	__u64	iova;				/* IO virtual address */
 	__u64	size;				/* Size of mapping (bytes) */
 	__u8    data[];
diff --git a/nbd/client-connection.c b/nbd/client-connection.c
deleted file mode 100644
index 7123b1e189..0000000000
--- a/nbd/client-connection.c
+++ /dev/null
@@ -1,388 +0,0 @@
-/*
- * QEMU Block driver for  NBD
- *
- * Copyright (c) 2021 Virtuozzo International GmbH.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-
-#include "qemu/osdep.h"
-
-#include "block/nbd.h"
-
-#include "qapi/qapi-visit-sockets.h"
-#include "qapi/clone-visitor.h"
-
-struct NBDClientConnection {
-    /* Initialization constants, never change */
-    SocketAddress *saddr; /* address to connect to */
-    QCryptoTLSCreds *tlscreds;
-    NBDExportInfo initial_info;
-    bool do_negotiation;
-    bool do_retry;
-
-    QemuMutex mutex;
-
-    /*
-     * @sioc and @err represent a connection attempt.  While running
-     * is true, they are only used by the connection thread, and mutex
-     * locking is not needed.  Once the thread finishes,
-     * nbd_co_establish_connection then steals these pointers while
-     * under the mutex.
-     */
-    NBDExportInfo updated_info;
-    QIOChannelSocket *sioc;
-    QIOChannel *ioc;
-    Error *err;
-
-    /* All further fields are accessed only under mutex */
-    bool running; /* thread is running now */
-    bool detached; /* thread is detached and should cleanup the state */
-
-    /*
-     * wait_co: if non-NULL, which coroutine to wake in
-     * nbd_co_establish_connection() after yield()
-     */
-    Coroutine *wait_co;
-};
-
-/*
- * The function isn't protected by any mutex, only call it when the client
- * connection attempt has not yet started.
- */
-void nbd_client_connection_enable_retry(NBDClientConnection *conn)
-{
-    conn->do_retry = true;
-}
-
-NBDClientConnection *nbd_client_connection_new(const SocketAddress *saddr,
-                                               bool do_negotiation,
-                                               const char *export_name,
-                                               const char *x_dirty_bitmap,
-                                               QCryptoTLSCreds *tlscreds)
-{
-    NBDClientConnection *conn = g_new(NBDClientConnection, 1);
-
-    object_ref(OBJECT(tlscreds));
-    *conn = (NBDClientConnection) {
-        .saddr = QAPI_CLONE(SocketAddress, saddr),
-        .tlscreds = tlscreds,
-        .do_negotiation = do_negotiation,
-
-        .initial_info.request_sizes = true,
-        .initial_info.structured_reply = true,
-        .initial_info.base_allocation = true,
-        .initial_info.x_dirty_bitmap = g_strdup(x_dirty_bitmap),
-        .initial_info.name = g_strdup(export_name ?: "")
-    };
-
-    qemu_mutex_init(&conn->mutex);
-
-    return conn;
-}
-
-static void nbd_client_connection_do_free(NBDClientConnection *conn)
-{
-    if (conn->sioc) {
-        qio_channel_close(QIO_CHANNEL(conn->sioc), NULL);
-        object_unref(OBJECT(conn->sioc));
-    }
-    error_free(conn->err);
-    qapi_free_SocketAddress(conn->saddr);
-    object_unref(OBJECT(conn->tlscreds));
-    g_free(conn->initial_info.x_dirty_bitmap);
-    g_free(conn->initial_info.name);
-    g_free(conn);
-}
-
-/*
- * Connect to @addr and do NBD negotiation if @info is not null. If @tlscreds
- * are given @outioc is returned. @outioc is provided only on success.  The call
- * may be cancelled from other thread by simply qio_channel_shutdown(sioc).
- */
-static int nbd_connect(QIOChannelSocket *sioc, SocketAddress *addr,
-                       NBDExportInfo *info, QCryptoTLSCreds *tlscreds,
-                       QIOChannel **outioc, Error **errp)
-{
-    int ret;
-
-    if (outioc) {
-        *outioc = NULL;
-    }
-
-    ret = qio_channel_socket_connect_sync(sioc, addr, errp);
-    if (ret < 0) {
-        return ret;
-    }
-
-    qio_channel_set_delay(QIO_CHANNEL(sioc), false);
-
-    if (!info) {
-        return 0;
-    }
-
-    ret = nbd_receive_negotiate(NULL, QIO_CHANNEL(sioc), tlscreds,
-                                tlscreds ? addr->u.inet.host : NULL,
-                                outioc, info, errp);
-    if (ret < 0) {
-        /*
-         * nbd_receive_negotiate() may setup tls ioc and return it even on
-         * failure path. In this case we should use it instead of original
-         * channel.
-         */
-        if (outioc && *outioc) {
-            qio_channel_close(QIO_CHANNEL(*outioc), NULL);
-            object_unref(OBJECT(*outioc));
-            *outioc = NULL;
-        } else {
-            qio_channel_close(QIO_CHANNEL(sioc), NULL);
-        }
-
-        return ret;
-    }
-
-    return 0;
-}
-
-static void *connect_thread_func(void *opaque)
-{
-    NBDClientConnection *conn = opaque;
-    int ret;
-    bool do_free;
-    uint64_t timeout = 1;
-    uint64_t max_timeout = 16;
-
-    qemu_mutex_lock(&conn->mutex);
-    while (!conn->detached) {
-        assert(!conn->sioc);
-        conn->sioc = qio_channel_socket_new();
-
-        qemu_mutex_unlock(&conn->mutex);
-
-        error_free(conn->err);
-        conn->err = NULL;
-        conn->updated_info = conn->initial_info;
-
-        ret = nbd_connect(conn->sioc, conn->saddr,
-                          conn->do_negotiation ? &conn->updated_info : NULL,
-                          conn->tlscreds, &conn->ioc, &conn->err);
-
-        /*
-         * conn->updated_info will finally be returned to the user. Clear the
-         * pointers to our internally allocated strings, which are IN parameters
-         * of nbd_receive_negotiate() and therefore nbd_connect(). Caller
-         * shoudn't be interested in these fields.
-         */
-        conn->updated_info.x_dirty_bitmap = NULL;
-        conn->updated_info.name = NULL;
-
-        qemu_mutex_lock(&conn->mutex);
-
-        if (ret < 0) {
-            object_unref(OBJECT(conn->sioc));
-            conn->sioc = NULL;
-            if (conn->do_retry && !conn->detached) {
-                qemu_mutex_unlock(&conn->mutex);
-
-                sleep(timeout);
-                if (timeout < max_timeout) {
-                    timeout *= 2;
-                }
-
-                qemu_mutex_lock(&conn->mutex);
-                continue;
-            }
-        }
-
-        break;
-    }
-
-    /* mutex is locked */
-
-    assert(conn->running);
-    conn->running = false;
-    if (conn->wait_co) {
-        aio_co_wake(conn->wait_co);
-        conn->wait_co = NULL;
-    }
-    do_free = conn->detached;
-
-    qemu_mutex_unlock(&conn->mutex);
-
-    if (do_free) {
-        nbd_client_connection_do_free(conn);
-    }
-
-    return NULL;
-}
-
-void nbd_client_connection_release(NBDClientConnection *conn)
-{
-    bool do_free = false;
-
-    if (!conn) {
-        return;
-    }
-
-    WITH_QEMU_LOCK_GUARD(&conn->mutex) {
-        assert(!conn->detached);
-        if (conn->running) {
-            conn->detached = true;
-        } else {
-            do_free = true;
-        }
-        if (conn->sioc) {
-            qio_channel_shutdown(QIO_CHANNEL(conn->sioc),
-                                 QIO_CHANNEL_SHUTDOWN_BOTH, NULL);
-        }
-    }
-
-    if (do_free) {
-        nbd_client_connection_do_free(conn);
-    }
-}
-
-/*
- * Get a new connection in context of @conn:
- *   if the thread is running, wait for completion
- *   if the thread already succeeded in the background, and user didn't get the
- *     result, just return it now
- *   otherwise the thread is not running, so start a thread and wait for
- *     completion
- *
- * If @blocking is false, don't wait for the thread, return immediately.
- *
- * If @info is not NULL, also do nbd-negotiation after successful connection.
- * In this case info is used only as out parameter, and is fully initialized by
- * nbd_co_establish_connection(). "IN" fields of info as well as related only to
- * nbd_receive_export_list() would be zero (see description of NBDExportInfo in
- * include/block/nbd.h).
- */
-QIOChannel *coroutine_fn
-nbd_co_establish_connection(NBDClientConnection *conn, NBDExportInfo *info,
-                            bool blocking, Error **errp)
-{
-    QemuThread thread;
-
-    if (conn->do_negotiation) {
-        assert(info);
-    }
-
-    WITH_QEMU_LOCK_GUARD(&conn->mutex) {
-        /*
-         * Don't call nbd_co_establish_connection() in several coroutines in
-         * parallel. Only one call at once is supported.
-         */
-        assert(!conn->wait_co);
-
-        if (!conn->running) {
-            if (conn->sioc) {
-                /* Previous attempt finally succeeded in background */
-                if (conn->do_negotiation) {
-                    memcpy(info, &conn->updated_info, sizeof(*info));
-                    if (conn->ioc) {
-                        /* TLS channel now has own reference to parent */
-                        object_unref(OBJECT(conn->sioc));
-                        conn->sioc = NULL;
-
-                        return g_steal_pointer(&conn->ioc);
-                    }
-                }
-
-                assert(!conn->ioc);
-
-                return QIO_CHANNEL(g_steal_pointer(&conn->sioc));
-            }
-
-            conn->running = true;
-            error_free(conn->err);
-            conn->err = NULL;
-            qemu_thread_create(&thread, "nbd-connect",
-                               connect_thread_func, conn, QEMU_THREAD_DETACHED);
-        }
-
-        if (!blocking) {
-            return NULL;
-        }
-
-        conn->wait_co = qemu_coroutine_self();
-    }
-
-    /*
-     * We are going to wait for connect-thread finish, but
-     * nbd_co_establish_connection_cancel() can interrupt.
-     */
-    qemu_coroutine_yield();
-
-    WITH_QEMU_LOCK_GUARD(&conn->mutex) {
-        if (conn->running) {
-            /*
-             * The connection attempt was canceled and the coroutine resumed
-             * before the connection thread finished its job.  Report the
-             * attempt as failed, but leave the connection thread running,
-             * to reuse it for the next connection attempt.
-             */
-            error_setg(errp, "Connection attempt cancelled by other operation");
-            return NULL;
-        } else {
-            error_propagate(errp, conn->err);
-            conn->err = NULL;
-            if (!conn->sioc) {
-                return NULL;
-            }
-            if (conn->do_negotiation) {
-                memcpy(info, &conn->updated_info, sizeof(*info));
-                if (conn->ioc) {
-                    /* TLS channel now has own reference to parent */
-                    object_unref(OBJECT(conn->sioc));
-                    conn->sioc = NULL;
-
-                    return g_steal_pointer(&conn->ioc);
-                }
-            }
-
-            assert(!conn->ioc);
-
-            return QIO_CHANNEL(g_steal_pointer(&conn->sioc));
-        }
-    }
-
-    abort(); /* unreachable */
-}
-
-/*
- * nbd_co_establish_connection_cancel
- * Cancel nbd_co_establish_connection() asynchronously.
- *
- * Note that this function neither directly stops the thread nor closes the
- * socket, but rather safely wakes nbd_co_establish_connection() which is
- * sleeping in yield()
- */
-void nbd_co_establish_connection_cancel(NBDClientConnection *conn)
-{
-    Coroutine *wait_co;
-
-    WITH_QEMU_LOCK_GUARD(&conn->mutex) {
-        wait_co = g_steal_pointer(&conn->wait_co);
-    }
-
-    if (wait_co) {
-        aio_co_wake(wait_co);
-    }
-}
diff --git a/nbd/meson.build b/nbd/meson.build
index b26d70565e..2baaa36948 100644
--- a/nbd/meson.build
+++ b/nbd/meson.build
@@ -1,6 +1,5 @@
 block_ss.add(files(
   'client.c',
-  'client-connection.c',
   'common.c',
 ))
 blockdev_ss.add(files(
diff --git a/plugins/plugin.h b/plugins/plugin.h
index 55017e3581..b13677d0dc 100644
--- a/plugins/plugin.h
+++ b/plugins/plugin.h
@@ -9,8 +9,8 @@
  * SPDX-License-Identifier: GPL-2.0-or-later
  */
 
-#ifndef _PLUGIN_INTERNAL_H_
-#define _PLUGIN_INTERNAL_H_
+#ifndef PLUGIN_INTERNAL_H
+#define PLUGIN_INTERNAL_H
 
 #include <gmodule.h>
 #include "qemu/qht.h"
diff --git a/scripts/block-coroutine-wrapper.py b/scripts/block-coroutine-wrapper.py
index 85dbeb9ecf..0461fd1c45 100644
--- a/scripts/block-coroutine-wrapper.py
+++ b/scripts/block-coroutine-wrapper.py
@@ -98,13 +98,12 @@ def snake_to_camel(func_name: str) -> str:
 
 
 def gen_wrapper(func: FuncDecl) -> str:
-    assert not '_co_' in func.name
+    assert func.name.startswith('bdrv_')
+    assert not func.name.startswith('bdrv_co_')
     assert func.return_type == 'int'
     assert func.args[0].type in ['BlockDriverState *', 'BdrvChild *']
 
-    subsystem, subname = func.name.split('_', 1)
-
-    name = f'{subsystem}_co_{subname}'
+    name = 'bdrv_co_' + func.name[5:]
     bs = 'bs' if func.args[0].type == 'BlockDriverState *' else 'child->bs'
     struct_name = snake_to_camel(name)
 
diff --git a/scripts/cpu-x86-uarch-abi.py b/scripts/cpu-x86-uarch-abi.py
deleted file mode 100644
index 08acc52a81..0000000000
--- a/scripts/cpu-x86-uarch-abi.py
+++ /dev/null
@@ -1,194 +0,0 @@
-#!/usr/bin/python3
-#
-# SPDX-License-Identifier: GPL-2.0-or-later
-#
-# A script to generate a CSV file showing the x86_64 ABI
-# compatibility levels for each CPU model.
-#
-
-from qemu import qmp
-import sys
-
-if len(sys.argv) != 1:
-    print("syntax: %s QMP-SOCK\n\n" % __file__ +
-          "Where QMP-SOCK points to a QEMU process such as\n\n" +
-          " # qemu-system-x86_64 -qmp unix:/tmp/qmp,server,nowait " +
-          "-display none -accel kvm", file=sys.stderr)
-    sys.exit(1)
-
-# Mandatory CPUID features for each microarch ABI level
-levels = [
-    [ # x86-64 baseline
-        "cmov",
-        "cx8",
-        "fpu",
-        "fxsr",
-        "mmx",
-        "syscall",
-        "sse",
-        "sse2",
-    ],
-    [ # x86-64-v2
-        "cx16",
-        "lahf-lm",
-        "popcnt",
-        "pni",
-        "sse4.1",
-        "sse4.2",
-        "ssse3",
-    ],
-    [ # x86-64-v3
-        "avx",
-        "avx2",
-        "bmi1",
-        "bmi2",
-        "f16c",
-        "fma",
-        "abm",
-        "movbe",
-    ],
-    [ # x86-64-v4
-        "avx512f",
-        "avx512bw",
-        "avx512cd",
-        "avx512dq",
-        "avx512vl",
-    ],
-]
-
-# Assumes externally launched process such as
-#
-#   qemu-system-x86_64 -qmp unix:/tmp/qmp,server,nowait -display none -accel kvm
-#
-# Note different results will be obtained with TCG, as
-# TCG masks out certain features otherwise present in
-# the CPU model definitions, as does KVM.
-
-
-sock = sys.argv[1]
-cmd = sys.argv[2]
-shell = qmp.QEMUMonitorProtocol(sock)
-shell.connect()
-
-models = shell.cmd("query-cpu-definitions")
-
-# These QMP props don't correspond to CPUID fatures
-# so ignore them
-skip = [
-    "family",
-    "min-level",
-    "min-xlevel",
-    "vendor",
-    "model",
-    "model-id",
-    "stepping",
-]
-
-names = []
-
-for model in models["return"]:
-    if "alias-of" in model:
-        continue
-    names.append(model["name"])
-
-models = {}
-
-for name in sorted(names):
-    cpu = shell.cmd("query-cpu-model-expansion",
-                     { "type": "static",
-                       "model": { "name": name }})
-
-    got = {}
-    for (feature, present) in cpu["return"]["model"]["props"].items():
-        if present and feature not in skip:
-            got[feature] = True
-
-    if name in ["host", "max", "base"]:
-        continue
-
-    models[name] = {
-        # Dict of all present features in this CPU model
-        "features": got,
-
-        # Whether each x86-64 ABI level is satisfied
-        "levels": [False, False, False, False],
-
-        # Number of extra CPUID features compared to the x86-64 ABI level
-        "distance":[-1, -1, -1, -1],
-
-        # CPUID features present in model, but not in ABI level
-        "delta":[[], [], [], []],
-
-        # CPUID features in ABI level but not present in model
-        "missing": [[], [], [], []],
-    }
-
-
-# Calculate whether the CPU models satisfy each ABI level
-for name in models.keys():
-    for level in range(len(levels)):
-        got = set(models[name]["features"])
-        want = set(levels[level])
-        missing = want - got
-        match = True
-        if len(missing) > 0:
-            match = False
-        models[name]["levels"][level] = match
-        models[name]["missing"][level] = missing
-
-# Cache list of CPU models satisfying each ABI level
-abi_models = [
-    [],
-    [],
-    [],
-    [],
-]
-
-for name in models.keys():
-    for level in range(len(levels)):
-        if models[name]["levels"][level]:
-            abi_models[level].append(name)
-
-
-for level in range(len(abi_models)):
-    # Find the union of features in all CPU models satisfying this ABI
-    allfeatures = {}
-    for name in abi_models[level]:
-        for feat in models[name]["features"]:
-            allfeatures[feat] = True
-
-    # Find the intersection of features in all CPU models satisfying this ABI
-    commonfeatures = []
-    for feat in allfeatures:
-        present = True
-        for name in models.keys():
-            if not models[name]["levels"][level]:
-                continue
-            if feat not in models[name]["features"]:
-                present = False
-        if present:
-            commonfeatures.append(feat)
-
-    # Determine how many extra features are present compared to the lowest
-    # common denominator
-    for name in models.keys():
-        if not models[name]["levels"][level]:
-            continue
-
-        delta = set(models[name]["features"].keys()) - set(commonfeatures)
-        models[name]["distance"][level] = len(delta)
-        models[name]["delta"][level] = delta
-
-def print_uarch_abi_csv():
-    print("# Automatically generated from '%s'" % __file__)
-    print("Model,baseline,v2,v3,v4")
-    for name in models.keys():
-        print(name, end="")
-        for level in range(len(levels)):
-            if models[name]["levels"][level]:
-                print(",✅", end="")
-            else:
-                print(",", end="")
-        print()
-
-print_uarch_abi_csv()
diff --git a/stubs/iothread-lock.c b/stubs/iothread-lock.c
index 5b45b7fc8b..2a6efad64a 100644
--- a/stubs/iothread-lock.c
+++ b/stubs/iothread-lock.c
@@ -3,7 +3,7 @@
 
 bool qemu_mutex_iothread_locked(void)
 {
-    return false;
+    return true;
 }
 
 void qemu_mutex_lock_iothread_impl(const char *file, int line)
diff --git a/stubs/iothread.c b/stubs/iothread.c
new file mode 100644
index 0000000000..8cc9e28c55
--- /dev/null
+++ b/stubs/iothread.c
@@ -0,0 +1,8 @@
+#include "qemu/osdep.h"
+#include "block/aio.h"
+#include "qemu/main-loop.h"
+
+AioContext *qemu_get_current_aio_context(void)
+{
+    return qemu_get_aio_context();
+}
diff --git a/stubs/meson.build b/stubs/meson.build
index 2e79ff9f4d..d4e9549dc9 100644
--- a/stubs/meson.build
+++ b/stubs/meson.build
@@ -16,6 +16,7 @@ stub_ss.add(files('fw_cfg.c'))
 stub_ss.add(files('gdbstub.c'))
 stub_ss.add(files('get-vm-name.c'))
 stub_ss.add(when: 'CONFIG_LINUX_IO_URING', if_true: files('io_uring.c'))
+stub_ss.add(files('iothread.c'))
 stub_ss.add(files('iothread-lock.c'))
 stub_ss.add(files('isa-bus.c'))
 stub_ss.add(files('is-daemonized.c'))
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index ad950c3c27..c676ee8b38 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -132,9 +132,6 @@ static struct kvm_cpuid2 *cpuid_cache;
 static struct kvm_cpuid2 *hv_cpuid_cache;
 static struct kvm_msr_list *kvm_feature_msrs;
 
-#define BUS_LOCK_SLICE_TIME 1000000000ULL /* ns */
-static RateLimit bus_lock_ratelimit_ctrl;
-
 int kvm_has_pit_state2(void)
 {
     return has_pit_state2;
@@ -2315,28 +2312,6 @@ int kvm_arch_init(MachineState *ms, KVMState *s)
         }
     }
 
-    if (object_dynamic_cast(OBJECT(ms), TYPE_X86_MACHINE)) {
-        X86MachineState *x86ms = X86_MACHINE(ms);
-
-        if (x86ms->bus_lock_ratelimit > 0) {
-            ret = kvm_check_extension(s, KVM_CAP_X86_BUS_LOCK_EXIT);
-            if (!(ret & KVM_BUS_LOCK_DETECTION_EXIT)) {
-                error_report("kvm: bus lock detection unsupported");
-                return -ENOTSUP;
-            }
-            ret = kvm_vm_enable_cap(s, KVM_CAP_X86_BUS_LOCK_EXIT, 0,
-                                    KVM_BUS_LOCK_DETECTION_EXIT);
-            if (ret < 0) {
-                error_report("kvm: Failed to enable bus lock detection cap: %s",
-                             strerror(-ret));
-                return ret;
-            }
-            ratelimit_init(&bus_lock_ratelimit_ctrl);
-            ratelimit_set_speed(&bus_lock_ratelimit_ctrl,
-                                x86ms->bus_lock_ratelimit, BUS_LOCK_SLICE_TIME);
-        }
-    }
-
     return 0;
 }
 
@@ -4291,15 +4266,6 @@ void kvm_arch_pre_run(CPUState *cpu, struct kvm_run *run)
     }
 }
 
-static void kvm_rate_limit_on_bus_lock(void)
-{
-    uint64_t delay_ns = ratelimit_calculate_delay(&bus_lock_ratelimit_ctrl, 1);
-
-    if (delay_ns) {
-        g_usleep(delay_ns / SCALE_US);
-    }
-}
-
 MemTxAttrs kvm_arch_post_run(CPUState *cpu, struct kvm_run *run)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
@@ -4315,9 +4281,6 @@ MemTxAttrs kvm_arch_post_run(CPUState *cpu, struct kvm_run *run)
     } else {
         env->eflags &= ~IF_MASK;
     }
-    if (run->flags & KVM_RUN_X86_BUS_LOCK) {
-        kvm_rate_limit_on_bus_lock();
-    }
 
     /* We need to protect the apic state against concurrent accesses from
      * different threads in case the userspace irqchip is used. */
@@ -4676,10 +4639,6 @@ int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)
         ioapic_eoi_broadcast(run->eoi.vector);
         ret = 0;
         break;
-    case KVM_EXIT_X86_BUS_LOCK:
-        /* already handled in kvm_arch_post_run */
-        ret = 0;
-        break;
     default:
         fprintf(stderr, "KVM: unknown exit reason %d\n", run->exit_reason);
         ret = -1;
diff --git a/tests/qtest/fuzz/generic_fuzz.c b/tests/qtest/fuzz/generic_fuzz.c
index cea7d4058e..6c67522717 100644
--- a/tests/qtest/fuzz/generic_fuzz.c
+++ b/tests/qtest/fuzz/generic_fuzz.c
@@ -841,9 +841,9 @@ static void generic_pre_fuzz(QTestState *s)
 
     g_hash_table_iter_init(&iter, fuzzable_memoryregions);
     while (g_hash_table_iter_next(&iter, (gpointer)&mr, NULL)) {
-        printf("  * %s (size %lx)\n",
+        printf("  * %s (size 0x%" PRIx64 ")\n",
                object_get_canonical_path_component(&(mr->parent_obj)),
-               (uint64_t)mr->size);
+               memory_region_size(mr));
     }
 
     if (!g_hash_table_size(fuzzable_memoryregions)) {
diff --git a/tests/qtest/fuzz/qos_fuzz.h b/tests/qtest/fuzz/qos_fuzz.h
index 477f11b02b..63d8459b71 100644
--- a/tests/qtest/fuzz/qos_fuzz.h
+++ b/tests/qtest/fuzz/qos_fuzz.h
@@ -10,8 +10,8 @@
  * See the COPYING file in the top-level directory.
  */
 
-#ifndef _QOS_FUZZ_H_
-#define _QOS_FUZZ_H_
+#ifndef QOS_FUZZ_H
+#define QOS_FUZZ_H
 
 #include "tests/qtest/fuzz/fuzz.h"
 #include "tests/qtest/libqos/qgraph.h"
diff --git a/tests/tcg/minilib/minilib.h b/tests/tcg/minilib/minilib.h
index e23361380a..17d0f2f314 100644
--- a/tests/tcg/minilib/minilib.h
+++ b/tests/tcg/minilib/minilib.h
@@ -9,8 +9,8 @@
  * SPDX-License-Identifier: GPL-2.0-only
  */
 
-#ifndef _MINILIB_H_
-#define _MINILIB_H_
+#ifndef MINILIB_H
+#define MINILIB_H
 
 /*
  * Provided by the individual arch
diff --git a/tests/unit/iothread.c b/tests/unit/iothread.c
index f9b0791084..afde12b4ef 100644
--- a/tests/unit/iothread.c
+++ b/tests/unit/iothread.c
@@ -30,6 +30,13 @@ struct IOThread {
     bool stopping;
 };
 
+static __thread IOThread *my_iothread;
+
+AioContext *qemu_get_current_aio_context(void)
+{
+    return my_iothread ? my_iothread->ctx : qemu_get_aio_context();
+}
+
 static void iothread_init_gcontext(IOThread *iothread)
 {
     GSource *source;
@@ -47,9 +54,9 @@ static void *iothread_run(void *opaque)
 
     rcu_register_thread();
 
+    my_iothread = iothread;
     qemu_mutex_lock(&iothread->init_done_lock);
     iothread->ctx = aio_context_new(&error_abort);
-    qemu_set_current_aio_context(iothread->ctx);
 
     /*
      * We must connect the ctx to a GMainContext, because in older versions
diff --git a/tests/unit/test-aio.c b/tests/unit/test-aio.c
index 6feeb9a4a9..8a46078463 100644
--- a/tests/unit/test-aio.c
+++ b/tests/unit/test-aio.c
@@ -877,42 +877,6 @@ static void test_queue_chaining(void)
     g_assert_cmpint(data_b.i, ==, data_b.max);
 }
 
-static void co_check_current_thread(void *opaque)
-{
-    QemuThread *main_thread = opaque;
-    assert(qemu_thread_is_self(main_thread));
-}
-
-static void *test_aio_co_enter(void *co)
-{
-    /*
-     * qemu_get_current_aio_context() should not to be the main thread
-     * AioContext, because this is a worker thread that has not taken
-     * the BQL.  So aio_co_enter will schedule the coroutine in the
-     * main thread AioContext.
-     */
-    aio_co_enter(qemu_get_aio_context(), co);
-    return NULL;
-}
-
-static void test_worker_thread_co_enter(void)
-{
-    QemuThread this_thread, worker_thread;
-    Coroutine *co;
-
-    qemu_thread_get_self(&this_thread);
-    co = qemu_coroutine_create(co_check_current_thread, &this_thread);
-
-    qemu_thread_create(&worker_thread, "test_acquire_thread",
-                       test_aio_co_enter,
-                       co, QEMU_THREAD_JOINABLE);
-
-    /* Test aio_co_enter from a worker thread.  */
-    qemu_thread_join(&worker_thread);
-    g_assert(aio_poll(ctx, true));
-    g_assert(!aio_poll(ctx, false));
-}
-
 /* End of tests.  */
 
 int main(int argc, char **argv)
@@ -939,7 +903,6 @@ int main(int argc, char **argv)
     g_test_add_func("/aio/timer/schedule",          test_timer_schedule);
 
     g_test_add_func("/aio/coroutine/queue-chaining", test_queue_chaining);
-    g_test_add_func("/aio/coroutine/worker-thread-co-enter", test_worker_thread_co_enter);
 
     g_test_add_func("/aio-gsource/flush",                   test_source_flush);
     g_test_add_func("/aio-gsource/bh/schedule",             test_source_bh_schedule);
diff --git a/util/async.c b/util/async.c
index 5d9b7cc1eb..674dbefb7c 100644
--- a/util/async.c
+++ b/util/async.c
@@ -649,23 +649,3 @@ void aio_context_release(AioContext *ctx)
 {
     qemu_rec_mutex_unlock(&ctx->lock);
 }
-
-static __thread AioContext *my_aiocontext;
-
-AioContext *qemu_get_current_aio_context(void)
-{
-    if (my_aiocontext) {
-        return my_aiocontext;
-    }
-    if (qemu_mutex_iothread_locked()) {
-        /* Possibly in a vCPU thread.  */
-        return qemu_get_aio_context();
-    }
-    return NULL;
-}
-
-void qemu_set_current_aio_context(AioContext *ctx)
-{
-    assert(!my_aiocontext);
-    my_aiocontext = ctx;
-}
diff --git a/util/main-loop.c b/util/main-loop.c
index 4ae5b23e99..d9c55df6f5 100644
--- a/util/main-loop.c
+++ b/util/main-loop.c
@@ -170,7 +170,6 @@ int qemu_init_main_loop(Error **errp)
     if (!qemu_aio_context) {
         return -EMFILE;
     }
-    qemu_set_current_aio_context(qemu_aio_context);
     qemu_notify_bh = qemu_bh_new(notify_event_cb, NULL);
     gpollfds = g_array_new(FALSE, FALSE, sizeof(GPollFD));
     src = aio_get_g_source(qemu_aio_context);
diff --git a/util/qemu-sockets.c b/util/qemu-sockets.c
index 080a240b74..c415c342c1 100644
--- a/util/qemu-sockets.c
+++ b/util/qemu-sockets.c
@@ -1164,25 +1164,6 @@ static int socket_get_fd(const char *fdstr, Error **errp)
     return fd;
 }
 
-int socket_address_parse_named_fd(SocketAddress *addr, Error **errp)
-{
-    int fd;
-
-    if (addr->type != SOCKET_ADDRESS_TYPE_FD) {
-        return 0;
-    }
-
-    fd = socket_get_fd(addr->u.fd.str, errp);
-    if (fd < 0) {
-        return fd;
-    }
-
-    g_free(addr->u.fd.str);
-    addr->u.fd.str = g_strdup_printf("%d", fd);
-
-    return 0;
-}
-
 int socket_connect(SocketAddress *addr, Error **errp)
 {
     int fd;