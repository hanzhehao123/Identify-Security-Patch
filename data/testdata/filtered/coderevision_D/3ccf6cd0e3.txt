diff --git a/MAINTAINERS b/MAINTAINERS
index 4842cc26e5..ccdb81c9f6 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -328,7 +328,7 @@ F: tests/tcg/i386/
 F: tests/tcg/x86_64/
 F: hw/i386/
 F: disas/i386.c
-F: docs/system/cpu-models-x86.rst.inc
+F: docs/system/cpu-models-x86*
 T: git https://gitlab.com/ehabkost/qemu.git x86-next
 
 Xtensa TCG CPUs
@@ -2221,7 +2221,6 @@ F: qapi/audio.json
 F: tests/qtest/ac97-test.c
 F: tests/qtest/es1370-test.c
 F: tests/qtest/intel-hda-test.c
-F: tests/qtest/fuzz-sb16-test.c
 
 Block layer core
 M: Kevin Wolf <kwolf@redhat.com>
diff --git a/audio/alsaaudio.c b/audio/alsaaudio.c
index 2b9789e647..fcc2f62864 100644
--- a/audio/alsaaudio.c
+++ b/audio/alsaaudio.c
@@ -34,8 +34,6 @@
 #define AUDIO_CAP "alsa"
 #include "audio_int.h"
 
-#define DEBUG_ALSA 0
-
 struct pollhlp {
     snd_pcm_t *handle;
     struct pollfd *pfds;
@@ -589,12 +587,16 @@ static int alsa_open(bool in, struct alsa_params_req *req,
 
     *handlep = handle;
 
-    if (DEBUG_ALSA || obtfmt != req->fmt ||
-        obt->nchannels != req->nchannels || obt->freq != req->freq) {
+    if (obtfmt != req->fmt ||
+         obt->nchannels != req->nchannels ||
+         obt->freq != req->freq) {
         dolog ("Audio parameters for %s\n", typ);
         alsa_dump_info(req, obt, obtfmt, apdo);
     }
 
+#ifdef DEBUG
+    alsa_dump_info(req, obt, obtfmt, apdo);
+#endif
     return 0;
 
  err:
diff --git a/audio/audio.c b/audio/audio.c
index 59453ef856..534278edfe 100644
--- a/audio/audio.c
+++ b/audio/audio.c
@@ -32,7 +32,6 @@
 #include "qapi/qapi-visit-audio.h"
 #include "qemu/cutils.h"
 #include "qemu/module.h"
-#include "qemu-common.h"
 #include "sysemu/replay.h"
 #include "sysemu/runstate.h"
 #include "ui/qemu-spice.h"
@@ -705,7 +704,7 @@ static size_t audio_pcm_sw_write(SWVoiceOut *sw, void *buf, size_t size)
 
     if (live == hwsamples) {
 #ifdef DEBUG_OUT
-        dolog ("%s is full %zu\n", sw->name, live);
+        dolog ("%s is full %d\n", sw->name, live);
 #endif
         return 0;
     }
@@ -995,7 +994,7 @@ static size_t audio_get_avail (SWVoiceIn *sw)
     }
 
     ldebug (
-        "%s: get_avail live %zu ret %" PRId64 "\n",
+        "%s: get_avail live %d ret %" PRId64 "\n",
         SW_NAME (sw),
         live, (((int64_t) live << 32) / sw->ratio) * sw->info.bytes_per_frame
         );
@@ -1022,7 +1021,7 @@ static size_t audio_get_free(SWVoiceOut *sw)
     dead = sw->hw->mix_buf->size - live;
 
 #ifdef DEBUG_OUT
-    dolog ("%s: get_free live %zu dead %zu ret %" PRId64 "\n",
+    dolog ("%s: get_free live %d dead %d ret %" PRId64 "\n",
            SW_NAME (sw),
            live, dead, (((int64_t) dead << 32) / sw->ratio) *
            sw->info.bytes_per_frame);
@@ -2173,14 +2172,6 @@ const char *audio_get_id(QEMUSoundCard *card)
     }
 }
 
-const char *audio_application_name(void)
-{
-    const char *vm_name;
-
-    vm_name = qemu_get_vm_name();
-    return vm_name ? vm_name : "qemu";
-}
-
 void audio_rate_start(RateCtl *rate)
 {
     memset(rate, 0, sizeof(RateCtl));
diff --git a/audio/audio_int.h b/audio/audio_int.h
index 6d685e24a3..06f0913835 100644
--- a/audio/audio_int.h
+++ b/audio/audio_int.h
@@ -243,8 +243,6 @@ void *audio_calloc (const char *funcname, int nmemb, size_t size);
 
 void audio_run(AudioState *s, const char *msg);
 
-const char *audio_application_name(void);
-
 typedef struct RateCtl {
     int64_t start_ticks;
     int64_t bytes_sent;
diff --git a/audio/coreaudio.c b/audio/coreaudio.c
index f570e1ee60..578ec9b8b2 100644
--- a/audio/coreaudio.c
+++ b/audio/coreaudio.c
@@ -39,6 +39,7 @@ typedef struct coreaudioVoiceOut {
     int frameSizeSetting;
     uint32_t bufferCount;
     UInt32 audioDevicePropertyBufferFrameSize;
+    AudioStreamBasicDescription outputStreamBasicDescription;
     AudioDeviceIOProcID ioprocid;
     bool enabled;
 } coreaudioVoiceOut;
@@ -113,6 +114,24 @@ static OSStatus coreaudio_set_framesize(AudioDeviceID id, UInt32 *framesize)
                                       framesize);
 }
 
+static OSStatus coreaudio_get_streamformat(AudioDeviceID id,
+                                           AudioStreamBasicDescription *d)
+{
+    UInt32 size = sizeof(*d);
+    AudioObjectPropertyAddress addr = {
+        kAudioDevicePropertyStreamFormat,
+        kAudioDevicePropertyScopeOutput,
+        kAudioObjectPropertyElementMaster
+    };
+
+    return AudioObjectGetPropertyData(id,
+                                      &addr,
+                                      0,
+                                      NULL,
+                                      &size,
+                                      d);
+}
+
 static OSStatus coreaudio_set_streamformat(AudioDeviceID id,
                                            AudioStreamBasicDescription *d)
 {
@@ -354,17 +373,6 @@ static OSStatus init_out_device(coreaudioVoiceOut *core)
     OSStatus status;
     AudioValueRange frameRange;
 
-    AudioStreamBasicDescription streamBasicDescription = {
-        .mBitsPerChannel = core->hw.info.bits,
-        .mBytesPerFrame = core->hw.info.bytes_per_frame,
-        .mBytesPerPacket = core->hw.info.bytes_per_frame,
-        .mChannelsPerFrame = core->hw.info.nchannels,
-        .mFormatFlags = kLinearPCMFormatFlagIsFloat,
-        .mFormatID = kAudioFormatLinearPCM,
-        .mFramesPerPacket = 1,
-        .mSampleRate = core->hw.info.freq
-    };
-
     status = coreaudio_get_voice(&core->outputDeviceID);
     if (status != kAudioHardwareNoError) {
         coreaudio_playback_logerr (status,
@@ -424,16 +432,29 @@ static OSStatus init_out_device(coreaudioVoiceOut *core)
     }
     core->hw.samples = core->bufferCount * core->audioDevicePropertyBufferFrameSize;
 
+    /* get StreamFormat */
+    status = coreaudio_get_streamformat(core->outputDeviceID,
+                                        &core->outputStreamBasicDescription);
+    if (status == kAudioHardwareBadObjectError) {
+        return 0;
+    }
+    if (status != kAudioHardwareNoError) {
+        coreaudio_playback_logerr (status,
+                                    "Could not get Device Stream properties\n");
+        core->outputDeviceID = kAudioDeviceUnknown;
+        return status;
+    }
+
     /* set Samplerate */
     status = coreaudio_set_streamformat(core->outputDeviceID,
-                                        &streamBasicDescription);
+                                        &core->outputStreamBasicDescription);
     if (status == kAudioHardwareBadObjectError) {
         return 0;
     }
     if (status != kAudioHardwareNoError) {
         coreaudio_playback_logerr (status,
                                    "Could not set samplerate %lf\n",
-                                   streamBasicDescription.mSampleRate);
+                                   core->outputStreamBasicDescription.mSampleRate);
         core->outputDeviceID = kAudioDeviceUnknown;
         return status;
     }
@@ -577,6 +598,7 @@ static int coreaudio_init_out(HWVoiceOut *hw, struct audsettings *as,
         qapi_AudiodevCoreaudioPerDirectionOptions_base(cpdo), as, 11610);
 
     core->bufferCount = cpdo->has_buffer_count ? cpdo->buffer_count : 4;
+    core->outputStreamBasicDescription.mSampleRate = (Float64) as->freq;
 
     status = AudioObjectAddPropertyListener(kAudioObjectSystemObject,
                                             &voice_addr, handle_voice_change,
diff --git a/audio/jackaudio.c b/audio/jackaudio.c
index e7de6d5433..3031c4e29b 100644
--- a/audio/jackaudio.c
+++ b/audio/jackaudio.c
@@ -26,6 +26,7 @@
 #include "qemu/module.h"
 #include "qemu/atomic.h"
 #include "qemu/main-loop.h"
+#include "qemu-common.h"
 #include "audio.h"
 
 #define AUDIO_CAP "jack"
@@ -411,7 +412,7 @@ static int qjack_client_init(QJackClient *c)
 
     snprintf(client_name, sizeof(client_name), "%s-%s",
         c->out ? "out" : "in",
-        c->opt->client_name ? c->opt->client_name : audio_application_name());
+        c->opt->client_name ? c->opt->client_name : qemu_get_vm_name());
 
     if (c->opt->exact_name) {
         options |= JackUseExactName;
diff --git a/audio/paaudio.c b/audio/paaudio.c
index 75401d5391..c97b22e970 100644
--- a/audio/paaudio.c
+++ b/audio/paaudio.c
@@ -2,6 +2,7 @@
 
 #include "qemu/osdep.h"
 #include "qemu/module.h"
+#include "qemu-common.h"
 #include "audio.h"
 #include "qapi/opts-visitor.h"
 
@@ -462,7 +463,10 @@ static pa_stream *qpa_simple_new (
 
     pa_stream_set_state_callback(stream, stream_state_cb, c);
 
-    flags = PA_STREAM_EARLY_REQUESTS;
+    flags =
+        PA_STREAM_INTERPOLATE_TIMING
+        | PA_STREAM_AUTO_TIMING_UPDATE
+        | PA_STREAM_EARLY_REQUESTS;
 
     if (dev) {
         /* don't move the stream if the user specified a sink/source */
@@ -752,6 +756,7 @@ static int qpa_validate_per_direction_opts(Audiodev *dev,
 /* common */
 static void *qpa_conn_init(const char *server)
 {
+    const char *vm_name;
     PAConnection *c = g_malloc0(sizeof(PAConnection));
     QTAILQ_INSERT_TAIL(&pa_conns, c, list);
 
@@ -760,8 +765,9 @@ static void *qpa_conn_init(const char *server)
         goto fail;
     }
 
+    vm_name = qemu_get_vm_name();
     c->context = pa_context_new(pa_threaded_mainloop_get_api(c->mainloop),
-                                audio_application_name());
+                                vm_name ? vm_name : "qemu");
     if (!c->context) {
         goto fail;
     }
diff --git a/backends/hostmem-file.c b/backends/hostmem-file.c
index cd038024fa..9b1b9f0a56 100644
--- a/backends/hostmem-file.c
+++ b/backends/hostmem-file.c
@@ -39,7 +39,6 @@ file_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
                object_get_typename(OBJECT(backend)));
 #else
     HostMemoryBackendFile *fb = MEMORY_BACKEND_FILE(backend);
-    uint32_t ram_flags;
     gchar *name;
 
     if (!backend->size) {
@@ -52,11 +51,11 @@ file_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
     }
 
     name = host_memory_backend_get_name(backend);
-    ram_flags = backend->share ? RAM_SHARED : 0;
-    ram_flags |= backend->reserve ? 0 : RAM_NORESERVE;
-    ram_flags |= fb->is_pmem ? RAM_PMEM : 0;
-    memory_region_init_ram_from_file(&backend->mr, OBJECT(backend), name,
-                                     backend->size, fb->align, ram_flags,
+    memory_region_init_ram_from_file(&backend->mr, OBJECT(backend),
+                                     name,
+                                     backend->size, fb->align,
+                                     (backend->share ? RAM_SHARED : 0) |
+                                     (fb->is_pmem ? RAM_PMEM : 0),
                                      fb->mem_path, fb->readonly, errp);
     g_free(name);
 #endif
diff --git a/backends/hostmem-memfd.c b/backends/hostmem-memfd.c
index 3fc85c3db8..da75e27057 100644
--- a/backends/hostmem-memfd.c
+++ b/backends/hostmem-memfd.c
@@ -35,7 +35,6 @@ static void
 memfd_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
 {
     HostMemoryBackendMemfd *m = MEMORY_BACKEND_MEMFD(backend);
-    uint32_t ram_flags;
     char *name;
     int fd;
 
@@ -53,10 +52,9 @@ memfd_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
     }
 
     name = host_memory_backend_get_name(backend);
-    ram_flags = backend->share ? RAM_SHARED : 0;
-    ram_flags |= backend->reserve ? 0 : RAM_NORESERVE;
-    memory_region_init_ram_from_fd(&backend->mr, OBJECT(backend), name,
-                                   backend->size, ram_flags, fd, 0, errp);
+    memory_region_init_ram_from_fd(&backend->mr, OBJECT(backend),
+                                   name, backend->size,
+                                   backend->share, fd, 0, errp);
     g_free(name);
 }
 
diff --git a/backends/hostmem-ram.c b/backends/hostmem-ram.c
index b8e55cdbd0..5cc53e76c9 100644
--- a/backends/hostmem-ram.c
+++ b/backends/hostmem-ram.c
@@ -19,7 +19,6 @@
 static void
 ram_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
 {
-    uint32_t ram_flags;
     char *name;
 
     if (!backend->size) {
@@ -28,10 +27,8 @@ ram_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
     }
 
     name = host_memory_backend_get_name(backend);
-    ram_flags = backend->share ? RAM_SHARED : 0;
-    ram_flags |= backend->reserve ? 0 : RAM_NORESERVE;
-    memory_region_init_ram_flags_nomigrate(&backend->mr, OBJECT(backend), name,
-                                           backend->size, ram_flags, errp);
+    memory_region_init_ram_shared_nomigrate(&backend->mr, OBJECT(backend), name,
+                           backend->size, backend->share, errp);
     g_free(name);
 }
 
diff --git a/backends/hostmem.c b/backends/hostmem.c
index 4c05862ed5..aab3de8408 100644
--- a/backends/hostmem.c
+++ b/backends/hostmem.c
@@ -216,11 +216,6 @@ static void host_memory_backend_set_prealloc(Object *obj, bool value,
     Error *local_err = NULL;
     HostMemoryBackend *backend = MEMORY_BACKEND(obj);
 
-    if (!backend->reserve && value) {
-        error_setg(errp, "'prealloc=on' and 'reserve=off' are incompatible");
-        return;
-    }
-
     if (!host_memory_backend_mr_inited(backend)) {
         backend->prealloc = value;
         return;
@@ -272,7 +267,6 @@ static void host_memory_backend_init(Object *obj)
     /* TODO: convert access to globals to compat properties */
     backend->merge = machine_mem_merge(machine);
     backend->dump = machine_dump_guest_core(machine);
-    backend->reserve = true;
     backend->prealloc_threads = 1;
 }
 
@@ -431,30 +425,6 @@ static void host_memory_backend_set_share(Object *o, bool value, Error **errp)
     backend->share = value;
 }
 
-#ifdef CONFIG_LINUX
-static bool host_memory_backend_get_reserve(Object *o, Error **errp)
-{
-    HostMemoryBackend *backend = MEMORY_BACKEND(o);
-
-    return backend->reserve;
-}
-
-static void host_memory_backend_set_reserve(Object *o, bool value, Error **errp)
-{
-    HostMemoryBackend *backend = MEMORY_BACKEND(o);
-
-    if (host_memory_backend_mr_inited(backend)) {
-        error_setg(errp, "cannot change property value");
-        return;
-    }
-    if (backend->prealloc && !value) {
-        error_setg(errp, "'prealloc=on' and 'reserve=off' are incompatible");
-        return;
-    }
-    backend->reserve = value;
-}
-#endif /* CONFIG_LINUX */
-
 static bool
 host_memory_backend_get_use_canonical_path(Object *obj, Error **errp)
 {
@@ -523,12 +493,6 @@ host_memory_backend_class_init(ObjectClass *oc, void *data)
         host_memory_backend_get_share, host_memory_backend_set_share);
     object_class_property_set_description(oc, "share",
         "Mark the memory as private to QEMU or shared");
-#ifdef CONFIG_LINUX
-    object_class_property_add_bool(oc, "reserve",
-        host_memory_backend_get_reserve, host_memory_backend_set_reserve);
-    object_class_property_set_description(oc, "reserve",
-        "Reserve swap space (or huge pages) if applicable");
-#endif /* CONFIG_LINUX */
     /*
      * Do not delete/rename option. This option must be considered stable
      * (as if it didn't have the 'x-' prefix including deprecation period) as
diff --git a/configure b/configure
index 262ab71802..debd50c085 100755
--- a/configure
+++ b/configure
@@ -6366,7 +6366,7 @@ if test "$skip_meson" = no; then
         i386)
             echo "cpu_family = 'x86'" >> $cross
             ;;
-        x86_64|x32)
+        x86_64)
             echo "cpu_family = 'x86_64'" >> $cross
             ;;
         ppc64le)
diff --git a/docs/amd-memory-encryption.txt b/docs/amd-memory-encryption.txt
index 145896aec7..ffca382b5f 100644
--- a/docs/amd-memory-encryption.txt
+++ b/docs/amd-memory-encryption.txt
@@ -1,38 +1,48 @@
 Secure Encrypted Virtualization (SEV) is a feature found on AMD processors.
 
 SEV is an extension to the AMD-V architecture which supports running encrypted
-virtual machine (VMs) under the control of KVM. Encrypted VMs have their pages
+virtual machines (VMs) under the control of KVM. Encrypted VMs have their pages
 (code and data) secured such that only the guest itself has access to the
 unencrypted version. Each encrypted VM is associated with a unique encryption
-key; if its data is accessed to a different entity using a different key the
+key; if its data is accessed by a different entity using a different key the
 encrypted guests data will be incorrectly decrypted, leading to unintelligible
 data.
 
-The key management of this feature is handled by separate processor known as
-AMD secure processor (AMD-SP) which is present in AMD SOCs. Firmware running
-inside the AMD-SP provide commands to support common VM lifecycle. This
+Key management for this feature is handled by a separate processor known as the
+AMD secure processor (AMD-SP), which is present in AMD SOCs. Firmware running
+inside the AMD-SP provides commands to support a common VM lifecycle. This
 includes commands for launching, snapshotting, migrating and debugging the
-encrypted guest. Those SEV command can be issued via KVM_MEMORY_ENCRYPT_OP
+encrypted guest. These SEV commands can be issued via KVM_MEMORY_ENCRYPT_OP
 ioctls.
 
+Secure Encrypted Virtualization - Encrypted State (SEV-ES) builds on the SEV
+support to additionally protect the guest register state. In order to allow a
+hypervisor to perform functions on behalf of a guest, there is architectural
+support for notifying a guest's operating system when certain types of VMEXITs
+are about to occur. This allows the guest to selectively share information with
+the hypervisor to satisfy the requested function.
+
 Launching
 ---------
-Boot images (such as bios) must be encrypted before guest can be booted.
-MEMORY_ENCRYPT_OP ioctl provides commands to encrypt the images :LAUNCH_START,
+Boot images (such as bios) must be encrypted before a guest can be booted. The
+MEMORY_ENCRYPT_OP ioctl provides commands to encrypt the images: LAUNCH_START,
 LAUNCH_UPDATE_DATA, LAUNCH_MEASURE and LAUNCH_FINISH. These four commands
 together generate a fresh memory encryption key for the VM, encrypt the boot
-images and provide a measurement than can be used as an attestation of the
+images and provide a measurement than can be used as an attestation of a
 successful launch.
 
+For a SEV-ES guest, the LAUNCH_UPDATE_VMSA command is also used to encrypt the
+guest register state, or VM save area (VMSA), for all of the guest vCPUs.
+
 LAUNCH_START is called first to create a cryptographic launch context within
-the firmware. To create this context, guest owner must provides guest policy,
+the firmware. To create this context, guest owner must provide a guest policy,
 its public Diffie-Hellman key (PDH) and session parameters. These inputs
-should be treated as binary blob and must be passed as-is to the SEV firmware.
+should be treated as a binary blob and must be passed as-is to the SEV firmware.
 
-The guest policy is passed as plaintext and hypervisor may able to read it
+The guest policy is passed as plaintext. A hypervisor may choose to read it,
 but should not modify it (any modification of the policy bits will result
 in bad measurement). The guest policy is a 4-byte data structure containing
-several flags that restricts what can be done on running SEV guest.
+several flags that restricts what can be done on a running SEV guest.
 See KM Spec section 3 and 6.2 for more details.
 
 The guest policy can be provided via the 'policy' property (see below)
@@ -40,31 +50,42 @@ The guest policy can be provided via the 'policy' property (see below)
 # ${QEMU} \
    sev-guest,id=sev0,policy=0x1...\
 
-Guest owners provided DH certificate and session parameters will be used to
+Setting the "SEV-ES required" policy bit (bit 2) will launch the guest as a
+SEV-ES guest (see below)
+
+# ${QEMU} \
+   sev-guest,id=sev0,policy=0x5...\
+
+The guest owner provided DH certificate and session parameters will be used to
 establish a cryptographic session with the guest owner to negotiate keys used
 for the attestation.
 
-The DH certificate and session blob can be provided via 'dh-cert-file' and
-'session-file' property (see below
+The DH certificate and session blob can be provided via the 'dh-cert-file' and
+'session-file' properties (see below)
 
 # ${QEMU} \
      sev-guest,id=sev0,dh-cert-file=<file1>,session-file=<file2>
 
 LAUNCH_UPDATE_DATA encrypts the memory region using the cryptographic context
-created via LAUNCH_START command. If required, this command can be called
+created via the LAUNCH_START command. If required, this command can be called
 multiple times to encrypt different memory regions. The command also calculates
 the measurement of the memory contents as it encrypts.
 
-LAUNCH_MEASURE command can be used to retrieve the measurement of encrypted
-memory. This measurement is a signature of the memory contents that can be
-sent to the guest owner as an attestation that the memory was encrypted
+LAUNCH_UPDATE_VMSA encrypts all the vCPU VMSAs for a SEV-ES guest using the
+cryptographic context created via the LAUNCH_START command. The command also
+calculates the measurement of the VMSAs as it encrypts them.
+
+LAUNCH_MEASURE can be used to retrieve the measurement of encrypted memory and,
+for a SEV-ES guest, encrypted VMSAs. This measurement is a signature of the
+memory contents and, for a SEV-ES guest, the VMSA contents, that can be sent
+to the guest owner as an attestation that the memory and VMSAs were encrypted
 correctly by the firmware. The guest owner may wait to provide the guest
 confidential information until it can verify the attestation measurement.
 Since the guest owner knows the initial contents of the guest at boot, the
 attestation measurement can be verified by comparing it to what the guest owner
 expects.
 
-LAUNCH_FINISH command finalizes the guest launch and destroy's the cryptographic
+LAUNCH_FINISH finalizes the guest launch and destroys the cryptographic
 context.
 
 See SEV KM API Spec [1] 'Launching a guest' usage flow (Appendix A) for the
@@ -76,12 +97,28 @@ To launch a SEV guest
     -machine ...,confidential-guest-support=sev0 \
     -object sev-guest,id=sev0,cbitpos=47,reduced-phys-bits=1
 
+To launch a SEV-ES guest
+
+# ${QEMU} \
+    -machine ...,confidential-guest-support=sev0 \
+    -object sev-guest,id=sev0,cbitpos=47,reduced-phys-bits=1,policy=0x5
+
+An SEV-ES guest has some restrictions as compared to a SEV guest. Because the
+guest register state is encrypted and cannot be updated by the VMM/hypervisor,
+a SEV-ES guest:
+ - Does not support SMM - SMM support requires updating the guest register
+   state.
+ - Does not support reboot - a system reset requires updating the guest register
+   state.
+ - Requires in-kernel irqchip - the burden is placed on the hypervisor to
+   manage booting APs.
+
 Debugging
 -----------
-Since memory contents of SEV guest is encrypted hence hypervisor access to the
-guest memory will get a cipher text. If guest policy allows debugging, then
-hypervisor can use DEBUG_DECRYPT and DEBUG_ENCRYPT commands access the guest
-memory region for debug purposes.  This is not supported in QEMU yet.
+Since the memory contents of a SEV guest are encrypted, hypervisor access to
+the guest memory will return cipher text. If the guest policy allows debugging,
+then a hypervisor can use the DEBUG_DECRYPT and DEBUG_ENCRYPT commands to access
+the guest memory region for debug purposes.  This is not supported in QEMU yet.
 
 Snapshot/Restore
 -----------------
@@ -102,8 +139,10 @@ Secure Encrypted Virtualization Key Management:
 
 KVM Forum slides:
 http://www.linux-kvm.org/images/7/74/02x08A-Thomas_Lendacky-AMDs_Virtualizatoin_Memory_Encryption_Technology.pdf
+https://www.linux-kvm.org/images/9/94/Extending-Secure-Encrypted-Virtualization-with-SEV-ES-Thomas-Lendacky-AMD.pdf
 
 AMD64 Architecture Programmer's Manual:
    http://support.amd.com/TechDocs/24593.pdf
    SME is section 7.10
    SEV is section 15.34
+   SEV-ES is section 15.35
diff --git a/docs/interop/firmware.json b/docs/interop/firmware.json
index 9d94ccafa9..8d8b0be030 100644
--- a/docs/interop/firmware.json
+++ b/docs/interop/firmware.json
@@ -115,6 +115,12 @@
 #           this feature are documented in
 #           "docs/amd-memory-encryption.txt".
 #
+# @amd-sev-es: The firmware supports running under AMD Secure Encrypted
+#              Virtualization - Encrypted State, as specified in the AMD64
+#              Architecture Programmer's Manual. QEMU command line options
+#              related to this feature are documented in
+#              "docs/amd-memory-encryption.txt".
+#
 # @enrolled-keys: The variable store (NVRAM) template associated with
 #                 the firmware binary has the UEFI Secure Boot
 #                 operational mode turned on, with certificates
@@ -179,7 +185,7 @@
 # Since: 3.0
 ##
 { 'enum' : 'FirmwareFeature',
-  'data' : [ 'acpi-s3', 'acpi-s4', 'amd-sev', 'enrolled-keys',
+  'data' : [ 'acpi-s3', 'acpi-s4', 'amd-sev', 'amd-sev-es', 'enrolled-keys',
              'requires-smm', 'secure-boot', 'verbose-dynamic',
              'verbose-static' ] }
 
@@ -504,6 +510,45 @@
 # }
 #
 # {
+#     "description": "OVMF with SEV-ES support",
+#     "interface-types": [
+#         "uefi"
+#     ],
+#     "mapping": {
+#         "device": "flash",
+#         "executable": {
+#             "filename": "/usr/share/OVMF/OVMF_CODE.fd",
+#             "format": "raw"
+#         },
+#         "nvram-template": {
+#             "filename": "/usr/share/OVMF/OVMF_VARS.fd",
+#             "format": "raw"
+#         }
+#     },
+#     "targets": [
+#         {
+#             "architecture": "x86_64",
+#             "machines": [
+#                 "pc-q35-*"
+#             ]
+#         }
+#     ],
+#     "features": [
+#         "acpi-s3",
+#         "amd-sev",
+#         "amd-sev-es",
+#         "verbose-dynamic"
+#     ],
+#     "tags": [
+#         "-a X64",
+#         "-p OvmfPkg/OvmfPkgX64.dsc",
+#         "-t GCC48",
+#         "-b DEBUG",
+#         "-D FD_SIZE_4MB"
+#     ]
+# }
+#
+# {
 #     "description": "UEFI firmware for ARM64 virtual machines",
 #     "interface-types": [
 #         "uefi"
diff --git a/docs/system/cpu-models-x86-abi.csv b/docs/system/cpu-models-x86-abi.csv
new file mode 100644
index 0000000000..f3f3b60be1
--- /dev/null
+++ b/docs/system/cpu-models-x86-abi.csv
@@ -0,0 +1,67 @@
+Model,baseline,v2,v3,v4
+486-v1,,,,
+Broadwell-v1,✅,✅,✅,
+Broadwell-v2,✅,✅,✅,
+Broadwell-v3,✅,✅,✅,
+Broadwell-v4,✅,✅,✅,
+Cascadelake-Server-v1,✅,✅,✅,✅
+Cascadelake-Server-v2,✅,✅,✅,✅
+Cascadelake-Server-v3,✅,✅,✅,✅
+Cascadelake-Server-v4,✅,✅,✅,✅
+Conroe-v1,✅,,,
+Cooperlake-v1,✅,✅,✅,✅
+Denverton-v1,✅,✅,,
+Denverton-v2,✅,✅,,
+Dhyana-v1,✅,✅,✅,
+EPYC-Milan-v1,✅,✅,✅,
+EPYC-Rome-v1,✅,✅,✅,
+EPYC-Rome-v2,✅,✅,✅,
+EPYC-v1,✅,✅,✅,
+EPYC-v2,✅,✅,✅,
+EPYC-v3,✅,✅,✅,
+Haswell-v1,✅,✅,✅,
+Haswell-v2,✅,✅,✅,
+Haswell-v3,✅,✅,✅,
+Haswell-v4,✅,✅,✅,
+Icelake-Client-v1,✅,✅,✅,
+Icelake-Client-v2,✅,✅,✅,
+Icelake-Server-v1,✅,✅,✅,✅
+Icelake-Server-v2,✅,✅,✅,✅
+Icelake-Server-v3,✅,✅,✅,✅
+Icelake-Server-v4,✅,✅,✅,✅
+IvyBridge-v1,✅,✅,,
+IvyBridge-v2,✅,✅,,
+KnightsMill-v1,✅,✅,✅,
+Nehalem-v1,✅,✅,,
+Nehalem-v2,✅,✅,,
+Opteron_G1-v1,✅,,,
+Opteron_G2-v1,✅,,,
+Opteron_G3-v1,✅,,,
+Opteron_G4-v1,✅,✅,,
+Opteron_G5-v1,✅,✅,,
+Penryn-v1,✅,,,
+SandyBridge-v1,✅,✅,,
+SandyBridge-v2,✅,✅,,
+Skylake-Client-v1,✅,✅,✅,
+Skylake-Client-v2,✅,✅,✅,
+Skylake-Client-v3,✅,✅,✅,
+Skylake-Server-v1,✅,✅,✅,✅
+Skylake-Server-v2,✅,✅,✅,✅
+Skylake-Server-v3,✅,✅,✅,✅
+Skylake-Server-v4,✅,✅,✅,✅
+Snowridge-v1,✅,✅,,
+Snowridge-v2,✅,✅,,
+Westmere-v1,✅,✅,,
+Westmere-v2,✅,✅,,
+athlon-v1,,,,
+core2duo-v1,✅,,,
+coreduo-v1,,,,
+kvm32-v1,,,,
+kvm64-v1,✅,,,
+n270-v1,,,,
+pentium-v1,,,,
+pentium2-v1,,,,
+pentium3-v1,,,,
+phenom-v1,✅,,,
+qemu32-v1,,,,
+qemu64-v1,✅,,,
diff --git a/docs/system/cpu-models-x86.rst.inc b/docs/system/cpu-models-x86.rst.inc
index 867c8216b5..f40ee03ecc 100644
--- a/docs/system/cpu-models-x86.rst.inc
+++ b/docs/system/cpu-models-x86.rst.inc
@@ -39,6 +39,28 @@ CPU, as they would with "Host passthrough", but gives much of the
 benefit of passthrough, while making live migration safe.
 
 
+ABI compatibility levels for CPU models
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+The x86_64 architecture has a number of `ABI compatibility levels`_
+defined. Traditionally most operating systems and toolchains would
+only target the original baseline ABI. It is expected that in
+future OS and toolchains are likely to target newer ABIs. The
+table that follows illustrates which ABI compatibility levels
+can be satisfied by the QEMU CPU models. Note that the table only
+lists the long term stable CPU model versions (eg Haswell-v4).
+In addition to whats listed, there are also many CPU model
+aliases which resolve to a different CPU model version,
+depending on the machine type is in use.
+
+.. _ABI compatibility levels: https://gitlab.com/x86-psABIs/x86-64-ABI/
+
+.. csv-table:: x86-64 ABI compatibility levels
+   :file: cpu-models-x86-abi.csv
+   :widths: 40,15,15,15,15
+   :header-rows: 2
+
+
 Preferred CPU models for Intel x86 hosts
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
diff --git a/hw/audio/sb16.c b/hw/audio/sb16.c
index 5cf121fe36..8b20700410 100644
--- a/hw/audio/sb16.c
+++ b/hw/audio/sb16.c
@@ -115,9 +115,6 @@ struct SB16State {
     PortioList portio_list;
 };
 
-#define SAMPLE_RATE_MIN 5000
-#define SAMPLE_RATE_MAX 45000
-
 static void SB_audio_callback (void *opaque, int free);
 
 static int magic_of_irq (int irq)
@@ -244,17 +241,6 @@ static void dma_cmd8 (SB16State *s, int mask, int dma_len)
         int tmp = (256 - s->time_const);
         s->freq = (1000000 + (tmp / 2)) / tmp;
     }
-    if (s->freq < SAMPLE_RATE_MIN) {
-        qemu_log_mask(LOG_GUEST_ERROR,
-                      "sampling range too low: %d, increasing to %u\n",
-                      s->freq, SAMPLE_RATE_MIN);
-        s->freq = SAMPLE_RATE_MIN;
-    } else if (s->freq > SAMPLE_RATE_MAX) {
-        qemu_log_mask(LOG_GUEST_ERROR,
-                      "sampling range too high: %d, decreasing to %u\n",
-                      s->freq, SAMPLE_RATE_MAX);
-        s->freq = SAMPLE_RATE_MAX;
-    }
 
     if (dma_len != -1) {
         s->block_size = dma_len << s->fmt_stereo;
diff --git a/hw/core/machine-hmp-cmds.c b/hw/core/machine-hmp-cmds.c
index 76b22b00d6..58248cffa3 100644
--- a/hw/core/machine-hmp-cmds.c
+++ b/hw/core/machine-hmp-cmds.c
@@ -110,12 +110,6 @@ void hmp_info_memdev(Monitor *mon, const QDict *qdict)
                        m->value->dump ? "true" : "false");
         monitor_printf(mon, "  prealloc: %s\n",
                        m->value->prealloc ? "true" : "false");
-        monitor_printf(mon, "  share: %s\n",
-                       m->value->share ? "true" : "false");
-        if (m->value->has_reserve) {
-            monitor_printf(mon, "  reserve: %s\n",
-                           m->value->reserve ? "true" : "false");
-        }
         monitor_printf(mon, "  policy: %s\n",
                        HostMemPolicy_str(m->value->policy));
         visit_complete(v, &str);
diff --git a/hw/core/machine-qmp-cmds.c b/hw/core/machine-qmp-cmds.c
index 216fdfaf3a..a36c96608f 100644
--- a/hw/core/machine-qmp-cmds.c
+++ b/hw/core/machine-qmp-cmds.c
@@ -157,7 +157,6 @@ void qmp_set_numa_node(NumaOptions *cmd, Error **errp)
 
 static int query_memdev(Object *obj, void *opaque)
 {
-    Error *err = NULL;
     MemdevList **list = opaque;
     Memdev *m;
     QObject *host_nodes;
@@ -173,13 +172,6 @@ static int query_memdev(Object *obj, void *opaque)
         m->merge = object_property_get_bool(obj, "merge", &error_abort);
         m->dump = object_property_get_bool(obj, "dump", &error_abort);
         m->prealloc = object_property_get_bool(obj, "prealloc", &error_abort);
-        m->share = object_property_get_bool(obj, "share", &error_abort);
-        m->reserve = object_property_get_bool(obj, "reserve", &err);
-        if (err) {
-            error_free_or_abort(&err);
-        } else {
-            m->has_reserve = true;
-        }
         m->policy = object_property_get_enum(obj, "policy", "HostMemPolicy",
                                              &error_abort);
         host_nodes = object_property_get_qobject(obj,
diff --git a/hw/i386/x86.c b/hw/i386/x86.c
index ed796fe6ba..d30cf27e29 100644
--- a/hw/i386/x86.c
+++ b/hw/i386/x86.c
@@ -1246,6 +1246,23 @@ static void x86_machine_set_oem_table_id(Object *obj, const char *value,
     strncpy(x86ms->oem_table_id, value, 8);
 }
 
+static void x86_machine_get_bus_lock_ratelimit(Object *obj, Visitor *v,
+                                const char *name, void *opaque, Error **errp)
+{
+    X86MachineState *x86ms = X86_MACHINE(obj);
+    uint64_t bus_lock_ratelimit = x86ms->bus_lock_ratelimit;
+
+    visit_type_uint64(v, name, &bus_lock_ratelimit, errp);
+}
+
+static void x86_machine_set_bus_lock_ratelimit(Object *obj, Visitor *v,
+                               const char *name, void *opaque, Error **errp)
+{
+    X86MachineState *x86ms = X86_MACHINE(obj);
+
+    visit_type_uint64(v, name, &x86ms->bus_lock_ratelimit, errp);
+}
+
 static void x86_machine_initfn(Object *obj)
 {
     X86MachineState *x86ms = X86_MACHINE(obj);
@@ -1256,6 +1273,7 @@ static void x86_machine_initfn(Object *obj)
     x86ms->pci_irq_mask = ACPI_BUILD_PCI_IRQS;
     x86ms->oem_id = g_strndup(ACPI_BUILD_APPNAME6, 6);
     x86ms->oem_table_id = g_strndup(ACPI_BUILD_APPNAME8, 8);
+    x86ms->bus_lock_ratelimit = 0;
 }
 
 static void x86_machine_class_init(ObjectClass *oc, void *data)
@@ -1299,6 +1317,12 @@ static void x86_machine_class_init(ObjectClass *oc, void *data)
                                           "Override the default value of field OEM Table ID "
                                           "in ACPI table header."
                                           "The string may be up to 8 bytes in size");
+
+    object_class_property_add(oc, X86_MACHINE_BUS_LOCK_RATELIMIT, "uint64_t",
+                                x86_machine_get_bus_lock_ratelimit,
+                                x86_machine_set_bus_lock_ratelimit, NULL, NULL);
+    object_class_property_set_description(oc, X86_MACHINE_BUS_LOCK_RATELIMIT,
+            "Set the ratelimit for the bus locks acquired in VMs");
 }
 
 static const TypeInfo x86_machine_info = {
diff --git a/hw/m68k/next-cube.c b/hw/m68k/next-cube.c
index e0d4a94f9d..de951ffe5d 100644
--- a/hw/m68k/next-cube.c
+++ b/hw/m68k/next-cube.c
@@ -984,8 +984,8 @@ static void next_cube_init(MachineState *machine)
     sysbus_mmio_map(SYS_BUS_DEVICE(pcdev), 1, 0x02100000);
 
     /* BMAP memory */
-    memory_region_init_ram_flags_nomigrate(bmapm1, NULL, "next.bmapmem", 64,
-                                           RAM_SHARED, &error_fatal);
+    memory_region_init_ram_shared_nomigrate(bmapm1, NULL, "next.bmapmem", 64,
+                                            true, &error_fatal);
     memory_region_add_subregion(sysmem, 0x020c0000, bmapm1);
     /* The Rev_2.5_v66.bin firmware accesses it at 0x820c0020, too */
     memory_region_init_alias(bmapm2, NULL, "next.bmapmem2", bmapm1, 0x0, 64);
diff --git a/hw/misc/ivshmem.c b/hw/misc/ivshmem.c
index 1ba4a98377..a1fa4878be 100644
--- a/hw/misc/ivshmem.c
+++ b/hw/misc/ivshmem.c
@@ -493,8 +493,9 @@ static void process_msg_shmem(IVShmemState *s, int fd, Error **errp)
     size = buf.st_size;
 
     /* mmap the region and map into the BAR2 */
-    memory_region_init_ram_from_fd(&s->server_bar2, OBJECT(s), "ivshmem.bar2",
-                                   size, RAM_SHARED, fd, 0, &local_err);
+    memory_region_init_ram_from_fd(&s->server_bar2, OBJECT(s),
+                                   "ivshmem.bar2", size, true, fd, 0,
+                                   &local_err);
     if (local_err) {
         error_propagate(errp, local_err);
         return;
diff --git a/hw/scsi/esp.c b/hw/scsi/esp.c
index 4ac2114788..b668acef82 100644
--- a/hw/scsi/esp.c
+++ b/hw/scsi/esp.c
@@ -213,7 +213,7 @@ static int esp_select(ESPState *s)
     if (!s->current_dev) {
         /* No such drive */
         s->rregs[ESP_RSTAT] = 0;
-        s->rregs[ESP_RINTR] = INTR_DC;
+        s->rregs[ESP_RINTR] |= INTR_DC;
         s->rregs[ESP_RSEQ] = SEQ_0;
         esp_raise_irq(s);
         return -1;
@@ -221,7 +221,7 @@ static int esp_select(ESPState *s)
 
     /*
      * Note that we deliberately don't raise the IRQ here: this will be done
-     * either in do_command_phase() for DATA OUT transfers or by the deferred
+     * either in do_busid_cmd() for DATA OUT transfers or by the deferred
      * IRQ mechanism in esp_transfer_data() for DATA IN transfers
      */
     s->rregs[ESP_RINTR] |= INTR_FC;
@@ -260,6 +260,9 @@ static uint32_t get_cmd(ESPState *s, uint32_t maxlen)
             return 0;
         }
         n = esp_fifo_pop_buf(&s->fifo, buf, dmalen);
+        if (n >= 3) {
+            buf[0] = buf[2] >> 5;
+        }
         n = MIN(fifo8_num_free(&s->cmdfifo), n);
         fifo8_push_all(&s->cmdfifo, buf, n);
     }
@@ -272,22 +275,24 @@ static uint32_t get_cmd(ESPState *s, uint32_t maxlen)
     return dmalen;
 }
 
-static void do_command_phase(ESPState *s)
+static void do_busid_cmd(ESPState *s, uint8_t busid)
 {
     uint32_t cmdlen;
     int32_t datalen;
+    int lun;
     SCSIDevice *current_lun;
     uint8_t buf[ESP_CMDFIFO_SZ];
 
-    trace_esp_do_command_phase(s->lun);
+    trace_esp_do_busid_cmd(busid);
+    lun = busid & 7;
     cmdlen = fifo8_num_used(&s->cmdfifo);
     if (!cmdlen || !s->current_dev) {
         return;
     }
     esp_fifo_pop_buf(&s->cmdfifo, buf, cmdlen);
 
-    current_lun = scsi_device_find(&s->bus, 0, s->current_dev->id, s->lun);
-    s->current_req = scsi_req_new(current_lun, 0, s->lun, buf, s);
+    current_lun = scsi_device_find(&s->bus, 0, s->current_dev->id, lun);
+    s->current_req = scsi_req_new(current_lun, 0, lun, buf, s);
     datalen = scsi_req_enqueue(s->current_req);
     s->ti_size = datalen;
     fifo8_reset(&s->cmdfifo);
@@ -314,36 +319,28 @@ static void do_command_phase(ESPState *s)
     }
 }
 
-static void do_message_phase(ESPState *s)
+static void do_cmd(ESPState *s)
 {
-    if (s->cmdfifo_cdb_offset) {
-        uint8_t message = esp_fifo_pop(&s->cmdfifo);
+    uint8_t busid = esp_fifo_pop(&s->cmdfifo);
+    int len;
 
-        trace_esp_do_identify(message);
-        s->lun = message & 7;
-        s->cmdfifo_cdb_offset--;
-    }
+    s->cmdfifo_cdb_offset--;
 
     /* Ignore extended messages for now */
     if (s->cmdfifo_cdb_offset) {
-        int len = MIN(s->cmdfifo_cdb_offset, fifo8_num_used(&s->cmdfifo));
+        len = MIN(s->cmdfifo_cdb_offset, fifo8_num_used(&s->cmdfifo));
         esp_fifo_pop_buf(&s->cmdfifo, NULL, len);
         s->cmdfifo_cdb_offset = 0;
     }
-}
 
-static void do_cmd(ESPState *s)
-{
-    do_message_phase(s);
-    assert(s->cmdfifo_cdb_offset == 0);
-    do_command_phase(s);
+    do_busid_cmd(s, busid);
 }
 
 static void satn_pdma_cb(ESPState *s)
 {
-    if (!esp_get_tc(s) && !fifo8_is_empty(&s->cmdfifo)) {
+    s->do_cmd = 0;
+    if (!fifo8_is_empty(&s->cmdfifo)) {
         s->cmdfifo_cdb_offset = 1;
-        s->do_cmd = 0;
         do_cmd(s);
     }
 }
@@ -372,10 +369,13 @@ static void handle_satn(ESPState *s)
 
 static void s_without_satn_pdma_cb(ESPState *s)
 {
-    if (!esp_get_tc(s) && !fifo8_is_empty(&s->cmdfifo)) {
+    uint32_t len;
+
+    s->do_cmd = 0;
+    len = fifo8_num_used(&s->cmdfifo);
+    if (len) {
         s->cmdfifo_cdb_offset = 0;
-        s->do_cmd = 0;
-        do_cmd(s);
+        do_busid_cmd(s, 0);
     }
 }
 
@@ -392,7 +392,7 @@ static void handle_s_without_atn(ESPState *s)
     if (cmdlen > 0) {
         s->cmdfifo_cdb_offset = 0;
         s->do_cmd = 0;
-        do_cmd(s);
+        do_busid_cmd(s, 0);
     } else if (cmdlen == 0) {
         s->do_cmd = 1;
         /* Target present, but no cmd yet - switch to command phase */
@@ -403,7 +403,8 @@ static void handle_s_without_atn(ESPState *s)
 
 static void satn_stop_pdma_cb(ESPState *s)
 {
-    if (!esp_get_tc(s) && !fifo8_is_empty(&s->cmdfifo)) {
+    s->do_cmd = 0;
+    if (!fifo8_is_empty(&s->cmdfifo)) {
         trace_esp_handle_satn_stop(fifo8_num_used(&s->cmdfifo));
         s->do_cmd = 1;
         s->cmdfifo_cdb_offset = 1;
@@ -480,6 +481,7 @@ static void esp_dma_done(ESPState *s)
 {
     s->rregs[ESP_RSTAT] |= STAT_TC;
     s->rregs[ESP_RINTR] |= INTR_BS;
+    s->rregs[ESP_RSEQ] = 0;
     s->rregs[ESP_RFLAGS] = 0;
     esp_set_tc(s, 0);
     esp_raise_irq(s);
@@ -492,32 +494,10 @@ static void do_dma_pdma_cb(ESPState *s)
     uint32_t n;
 
     if (s->do_cmd) {
-        /* Ensure we have received complete command after SATN and stop */
-        if (esp_get_tc(s) || fifo8_is_empty(&s->cmdfifo)) {
-            return;
-        }
-
         s->ti_size = 0;
-        if ((s->rregs[ESP_RSTAT] & 7) == STAT_CD) {
-            /* No command received */
-            if (s->cmdfifo_cdb_offset == fifo8_num_used(&s->cmdfifo)) {
-                return;
-            }
-
-            /* Command has been received */
-            s->do_cmd = 0;
-            do_cmd(s);
-        } else {
-            /*
-             * Extra message out bytes received: update cmdfifo_cdb_offset
-             * and then switch to commmand phase
-             */
-            s->cmdfifo_cdb_offset = fifo8_num_used(&s->cmdfifo);
-            s->rregs[ESP_RSTAT] = STAT_TC | STAT_CD;
-            s->rregs[ESP_RSEQ] = SEQ_CD;
-            s->rregs[ESP_RINTR] |= INTR_BS;
-            esp_raise_irq(s);
-        }
+        s->do_cmd = 0;
+        do_cmd(s);
+        esp_lower_drq(s);
         return;
     }
 
@@ -760,17 +740,20 @@ static void esp_do_nodma(ESPState *s)
         s->async_len -= len;
         s->ti_size += len;
     } else {
-        if (fifo8_is_empty(&s->fifo)) {
-            fifo8_push(&s->fifo, s->async_buf[0]);
-            s->async_buf++;
-            s->async_len--;
-            s->ti_size--;
-        }
+        len = MIN(s->ti_size, s->async_len);
+        len = MIN(len, fifo8_num_free(&s->fifo));
+        fifo8_push_all(&s->fifo, s->async_buf, len);
+        s->async_buf += len;
+        s->async_len -= len;
+        s->ti_size -= len;
     }
 
     if (s->async_len == 0) {
         scsi_req_continue(s->current_req);
-        return;
+
+        if (to_device || s->ti_size == 0) {
+            return;
+        }
     }
 
     s->rregs[ESP_RINTR] |= INTR_BS;
@@ -780,37 +763,20 @@ static void esp_do_nodma(ESPState *s)
 void esp_command_complete(SCSIRequest *req, size_t resid)
 {
     ESPState *s = req->hba_private;
-    int to_device = ((s->rregs[ESP_RSTAT] & 7) == STAT_DO);
 
     trace_esp_command_complete();
-
-    /*
-     * Non-DMA transfers from the target will leave the last byte in
-     * the FIFO so don't reset ti_size in this case
-     */
-    if (s->dma || to_device) {
-        if (s->ti_size != 0) {
-            trace_esp_command_complete_unexpected();
-        }
-        s->ti_size = 0;
+    if (s->ti_size != 0) {
+        trace_esp_command_complete_unexpected();
     }
-
+    s->ti_size = 0;
     s->async_len = 0;
     if (req->status) {
         trace_esp_command_complete_fail();
     }
     s->status = req->status;
-
-    /*
-     * If the transfer is finished, switch to status phase. For non-DMA
-     * transfers from the target the last byte is still in the FIFO
-     */
-    if (s->ti_size == 0) {
-        s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;
-        esp_dma_done(s);
-        esp_lower_drq(s);
-    }
-
+    s->rregs[ESP_RSTAT] = STAT_ST;
+    esp_dma_done(s);
+    esp_lower_drq(s);
     if (s->current_req) {
         scsi_req_unref(s->current_req);
         s->current_req = NULL;
@@ -838,6 +804,16 @@ void esp_transfer_data(SCSIRequest *req, uint32_t len)
         s->rregs[ESP_RSTAT] |= STAT_TC;
         s->rregs[ESP_RINTR] |= INTR_BS;
         esp_raise_irq(s);
+
+        /*
+         * If data is ready to transfer and the TI command has already
+         * been executed, start DMA immediately. Otherwise DMA will start
+         * when host sends the TI command
+         */
+        if (s->ti_size && (s->rregs[ESP_CMD] == (CMD_TI | CMD_DMA))) {
+            esp_do_dma(s);
+        }
+        return;
     }
 
     if (s->ti_cmd == 0) {
@@ -851,7 +827,7 @@ void esp_transfer_data(SCSIRequest *req, uint32_t len)
         return;
     }
 
-    if (s->ti_cmd == (CMD_TI | CMD_DMA)) {
+    if (s->ti_cmd & CMD_DMA) {
         if (dmalen) {
             esp_do_dma(s);
         } else if (s->ti_size <= 0) {
@@ -862,7 +838,7 @@ void esp_transfer_data(SCSIRequest *req, uint32_t len)
             esp_dma_done(s);
             esp_lower_drq(s);
         }
-    } else if (s->ti_cmd == CMD_TI) {
+    } else {
         esp_do_nodma(s);
     }
 }
@@ -929,17 +905,6 @@ uint64_t esp_reg_read(ESPState *s, uint32_t saddr)
             qemu_log_mask(LOG_UNIMP, "esp: PIO data read not implemented\n");
             s->rregs[ESP_FIFO] = 0;
         } else {
-            if ((s->rregs[ESP_RSTAT] & 0x7) == STAT_DI) {
-                if (s->ti_size) {
-                    esp_do_nodma(s);
-                } else {
-                    /*
-                     * The last byte of a non-DMA transfer has been read out
-                     * of the FIFO so switch to status phase
-                     */
-                    s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;
-                }
-            }
             s->rregs[ESP_FIFO] = esp_fifo_pop(&s->fifo);
         }
         val = s->rregs[ESP_FIFO];
@@ -952,15 +917,7 @@ uint64_t esp_reg_read(ESPState *s, uint32_t saddr)
         val = s->rregs[ESP_RINTR];
         s->rregs[ESP_RINTR] = 0;
         s->rregs[ESP_RSTAT] &= ~STAT_TC;
-        /*
-         * According to the datasheet ESP_RSEQ should be cleared, but as the
-         * emulation currently defers information transfers to the next TI
-         * command leave it for now so that pedantic guests such as the old
-         * Linux 2.6 driver see the correct flags before the next SCSI phase
-         * transition.
-         *
-         * s->rregs[ESP_RSEQ] = SEQ_0;
-         */
+        s->rregs[ESP_RSEQ] = SEQ_0;
         esp_lower_irq(s);
         break;
     case ESP_TCHI:
@@ -998,18 +955,15 @@ void esp_reg_write(ESPState *s, uint32_t saddr, uint64_t val)
     case ESP_FIFO:
         if (s->do_cmd) {
             esp_fifo_push(&s->cmdfifo, val);
-
-            /*
-             * If any unexpected message out/command phase data is
-             * transferred using non-DMA, raise the interrupt
-             */
-            if (s->rregs[ESP_CMD] == CMD_TI) {
-                s->rregs[ESP_RINTR] |= INTR_BS;
-                esp_raise_irq(s);
-            }
         } else {
             esp_fifo_push(&s->fifo, val);
         }
+
+        /* Non-DMA transfers raise an interrupt after every byte */
+        if (s->rregs[ESP_CMD] == CMD_TI) {
+            s->rregs[ESP_RINTR] |= INTR_FC | INTR_BS;
+            esp_raise_irq(s);
+        }
         break;
     case ESP_CMD:
         s->rregs[saddr] = val;
@@ -1134,15 +1088,7 @@ static bool esp_is_version_5(void *opaque, int version_id)
     ESPState *s = ESP(opaque);
 
     version_id = MIN(version_id, s->mig_version_id);
-    return version_id >= 5;
-}
-
-static bool esp_is_version_6(void *opaque, int version_id)
-{
-    ESPState *s = ESP(opaque);
-
-    version_id = MIN(version_id, s->mig_version_id);
-    return version_id >= 6;
+    return version_id == 5;
 }
 
 int esp_pre_save(void *opaque)
@@ -1182,7 +1128,7 @@ static int esp_post_load(void *opaque, int version_id)
 
 const VMStateDescription vmstate_esp = {
     .name = "esp",
-    .version_id = 6,
+    .version_id = 5,
     .minimum_version_id = 3,
     .post_load = esp_post_load,
     .fields = (VMStateField[]) {
@@ -1211,7 +1157,6 @@ const VMStateDescription vmstate_esp = {
         VMSTATE_FIFO8_TEST(fifo, ESPState, esp_is_version_5),
         VMSTATE_FIFO8_TEST(cmdfifo, ESPState, esp_is_version_5),
         VMSTATE_UINT8_TEST(ti_cmd, ESPState, esp_is_version_5),
-        VMSTATE_UINT8_TEST(lun, ESPState, esp_is_version_6),
         VMSTATE_END_OF_LIST()
     },
 };
@@ -1250,6 +1195,7 @@ static void sysbus_esp_pdma_write(void *opaque, hwaddr addr,
 {
     SysBusESPState *sysbus = opaque;
     ESPState *s = ESP(&sysbus->esp);
+    uint32_t dmalen;
 
     trace_esp_pdma_write(size);
 
@@ -1262,7 +1208,10 @@ static void sysbus_esp_pdma_write(void *opaque, hwaddr addr,
         esp_pdma_write(s, val);
         break;
     }
-    s->pdma_cb(s);
+    dmalen = esp_get_tc(s);
+    if (dmalen == 0 || fifo8_num_free(&s->fifo) < 2) {
+        s->pdma_cb(s);
+    }
 }
 
 static uint64_t sysbus_esp_pdma_read(void *opaque, hwaddr addr,
diff --git a/hw/scsi/scsi-generic.c b/hw/scsi/scsi-generic.c
index 40e039864f..98c30c5d5c 100644
--- a/hw/scsi/scsi-generic.c
+++ b/hw/scsi/scsi-generic.c
@@ -147,7 +147,7 @@ static int execute_command(BlockBackend *blk,
     return 0;
 }
 
-static int scsi_handle_inquiry_reply(SCSIGenericReq *r, SCSIDevice *s, int len)
+static void scsi_handle_inquiry_reply(SCSIGenericReq *r, SCSIDevice *s)
 {
     uint8_t page, page_idx;
 
@@ -213,13 +213,8 @@ static int scsi_handle_inquiry_reply(SCSIGenericReq *r, SCSIDevice *s, int len)
                 r->buf[page_idx] = 0xb0;
             }
             stw_be_p(r->buf + 2, lduw_be_p(r->buf + 2) + 1);
-
-            if (len < r->buflen) {
-                len++;
-            }
         }
     }
-    return len;
 }
 
 static int scsi_generic_emulate_block_limits(SCSIGenericReq *r, SCSIDevice *s)
@@ -337,7 +332,7 @@ static void scsi_read_complete(void * opaque, int ret)
         }
     }
     if (r->req.cmd.buf[0] == INQUIRY) {
-        len = scsi_handle_inquiry_reply(r, s, len);
+        scsi_handle_inquiry_reply(r, s);
     }
 
 req_complete:
diff --git a/hw/scsi/trace-events b/hw/scsi/trace-events
index 92d5b40f89..1a27e141ae 100644
--- a/hw/scsi/trace-events
+++ b/hw/scsi/trace-events
@@ -166,8 +166,7 @@ esp_dma_disable(void) "Lower enable"
 esp_pdma_read(int size) "pDMA read %u bytes"
 esp_pdma_write(int size) "pDMA write %u bytes"
 esp_get_cmd(uint32_t dmalen, int target) "len %d target %d"
-esp_do_command_phase(uint8_t busid) "busid 0x%x"
-esp_do_identify(uint8_t byte) "0x%x"
+esp_do_busid_cmd(uint8_t busid) "busid 0x%x"
 esp_handle_satn_stop(uint32_t cmdlen) "cmdlen %d"
 esp_write_response(uint32_t status) "Transfer status (status=%d)"
 esp_do_dma(uint32_t cmdlen, uint32_t len) "command len %d + %d"
diff --git a/include/exec/cpu-common.h b/include/exec/cpu-common.h
index 039d422bf4..ccabed4003 100644
--- a/include/exec/cpu-common.h
+++ b/include/exec/cpu-common.h
@@ -59,7 +59,6 @@ ram_addr_t qemu_ram_get_offset(RAMBlock *rb);
 ram_addr_t qemu_ram_get_used_length(RAMBlock *rb);
 ram_addr_t qemu_ram_get_max_length(RAMBlock *rb);
 bool qemu_ram_is_shared(RAMBlock *rb);
-bool qemu_ram_is_noreserve(RAMBlock *rb);
 bool qemu_ram_is_uf_zeroable(RAMBlock *rb);
 void qemu_ram_set_uf_zeroable(RAMBlock *rb);
 bool qemu_ram_is_migratable(RAMBlock *rb);
diff --git a/include/exec/memory.h b/include/exec/memory.h
index b116f7c64e..b114f5454b 100644
--- a/include/exec/memory.h
+++ b/include/exec/memory.h
@@ -155,13 +155,6 @@ typedef struct IOMMUTLBEvent {
  */
 #define RAM_UF_WRITEPROTECT (1 << 6)
 
-/*
- * RAM is mmap-ed with MAP_NORESERVE. When set, reserving swap space (or huge
- * pages if applicable) is skipped: will bail out if not supported. When not
- * set, the OS will do the reservation, if supported for the memory type.
- */
-#define RAM_NORESERVE (1 << 7)
-
 static inline void iommu_notifier_init(IOMMUNotifier *n, IOMMUNotify fn,
                                        IOMMUNotifierFlag flags,
                                        hwaddr start, hwaddr end,
@@ -947,27 +940,27 @@ void memory_region_init_ram_nomigrate(MemoryRegion *mr,
                                       Error **errp);
 
 /**
- * memory_region_init_ram_flags_nomigrate:  Initialize RAM memory region.
- *                                          Accesses into the region will
- *                                          modify memory directly.
+ * memory_region_init_ram_shared_nomigrate:  Initialize RAM memory region.
+ *                                           Accesses into the region will
+ *                                           modify memory directly.
  *
  * @mr: the #MemoryRegion to be initialized.
  * @owner: the object that tracks the region's reference count
  * @name: Region name, becomes part of RAMBlock name used in migration stream
  *        must be unique within any device
  * @size: size of the region.
- * @ram_flags: RamBlock flags. Supported flags: RAM_SHARED, RAM_NORESERVE.
+ * @share: allow remapping RAM to different addresses
  * @errp: pointer to Error*, to store an error if it happens.
  *
- * Note that this function does not do anything to cause the data in the
- * RAM memory region to be migrated; that is the responsibility of the caller.
+ * Note that this function is similar to memory_region_init_ram_nomigrate.
+ * The only difference is part of the RAM region can be remapped.
  */
-void memory_region_init_ram_flags_nomigrate(MemoryRegion *mr,
-                                            Object *owner,
-                                            const char *name,
-                                            uint64_t size,
-                                            uint32_t ram_flags,
-                                            Error **errp);
+void memory_region_init_ram_shared_nomigrate(MemoryRegion *mr,
+                                             Object *owner,
+                                             const char *name,
+                                             uint64_t size,
+                                             bool share,
+                                             Error **errp);
 
 /**
  * memory_region_init_resizeable_ram:  Initialize memory region with resizeable
@@ -1012,8 +1005,10 @@ void memory_region_init_resizeable_ram(MemoryRegion *mr,
  * @size: size of the region.
  * @align: alignment of the region base address; if 0, the default alignment
  *         (getpagesize()) will be used.
- * @ram_flags: RamBlock flags. Supported flags: RAM_SHARED, RAM_PMEM,
- *             RAM_NORESERVE,
+ * @ram_flags: Memory region features:
+ *             - RAM_SHARED: memory must be mmaped with the MAP_SHARED flag
+ *             - RAM_PMEM: the memory is persistent memory
+ *             Other bits are ignored now.
  * @path: the path in which to allocate the RAM.
  * @readonly: true to open @path for reading, false for read/write.
  * @errp: pointer to Error*, to store an error if it happens.
@@ -1039,8 +1034,7 @@ void memory_region_init_ram_from_file(MemoryRegion *mr,
  * @owner: the object that tracks the region's reference count
  * @name: the name of the region.
  * @size: size of the region.
- * @ram_flags: RamBlock flags. Supported flags: RAM_SHARED, RAM_PMEM,
- *             RAM_NORESERVE.
+ * @share: %true if memory must be mmaped with the MAP_SHARED flag
  * @fd: the fd to mmap.
  * @offset: offset within the file referenced by fd
  * @errp: pointer to Error*, to store an error if it happens.
@@ -1052,7 +1046,7 @@ void memory_region_init_ram_from_fd(MemoryRegion *mr,
                                     Object *owner,
                                     const char *name,
                                     uint64_t size,
-                                    uint32_t ram_flags,
+                                    bool share,
                                     int fd,
                                     ram_addr_t offset,
                                     Error **errp);
diff --git a/include/exec/ram_addr.h b/include/exec/ram_addr.h
index 551876bed0..3cb9791df3 100644
--- a/include/exec/ram_addr.h
+++ b/include/exec/ram_addr.h
@@ -104,8 +104,11 @@ long qemu_maxrampagesize(void);
  * Parameters:
  *  @size: the size in bytes of the ram block
  *  @mr: the memory region where the ram block is
- *  @ram_flags: RamBlock flags. Supported flags: RAM_SHARED, RAM_PMEM,
- *              RAM_NORESERVE.
+ *  @ram_flags: specify the properties of the ram block, which can be one
+ *              or bit-or of following values
+ *              - RAM_SHARED: mmap the backing file or device with MAP_SHARED
+ *              - RAM_PMEM: the backend @mem_path or @fd is persistent memory
+ *              Other bits are ignored.
  *  @mem_path or @fd: specify the backing file or device
  *  @readonly: true to open @path for reading, false for read/write.
  *  @errp: pointer to Error*, to store an error if it happens
@@ -123,7 +126,7 @@ RAMBlock *qemu_ram_alloc_from_fd(ram_addr_t size, MemoryRegion *mr,
 
 RAMBlock *qemu_ram_alloc_from_ptr(ram_addr_t size, void *host,
                                   MemoryRegion *mr, Error **errp);
-RAMBlock *qemu_ram_alloc(ram_addr_t size, uint32_t ram_flags, MemoryRegion *mr,
+RAMBlock *qemu_ram_alloc(ram_addr_t size, bool share, MemoryRegion *mr,
                          Error **errp);
 RAMBlock *qemu_ram_alloc_resizeable(ram_addr_t size, ram_addr_t max_size,
                                     void (*resized)(const char*,
diff --git a/include/hw/i386/x86.h b/include/hw/i386/x86.h
index c09b648dff..25a1f16f01 100644
--- a/include/hw/i386/x86.h
+++ b/include/hw/i386/x86.h
@@ -74,12 +74,20 @@ struct X86MachineState {
      * will be translated to MSI messages in the address space.
      */
     AddressSpace *ioapic_as;
+
+    /*
+     * Ratelimit enforced on detected bus locks in guest.
+     * The default value of the bus_lock_ratelimit is 0 per second,
+     * which means no limitation on the guest's bus locks.
+     */
+    uint64_t bus_lock_ratelimit;
 };
 
 #define X86_MACHINE_SMM              "smm"
 #define X86_MACHINE_ACPI             "acpi"
 #define X86_MACHINE_OEM_ID           "x-oem-id"
 #define X86_MACHINE_OEM_TABLE_ID     "x-oem-table-id"
+#define X86_MACHINE_BUS_LOCK_RATELIMIT  "bus-lock-ratelimit"
 
 #define TYPE_X86_MACHINE   MACHINE_TYPE_NAME("x86")
 OBJECT_DECLARE_TYPE(X86MachineState, X86MachineClass, X86_MACHINE)
diff --git a/include/hw/scsi/esp.h b/include/hw/scsi/esp.h
index b1ec27612f..aada3680b7 100644
--- a/include/hw/scsi/esp.h
+++ b/include/hw/scsi/esp.h
@@ -37,7 +37,6 @@ struct ESPState {
     SCSIRequest *current_req;
     Fifo8 cmdfifo;
     uint8_t cmdfifo_cdb_offset;
-    uint8_t lun;
     uint32_t do_cmd;
 
     bool data_in_ready;
diff --git a/include/qemu/mmap-alloc.h b/include/qemu/mmap-alloc.h
index 90d0eee705..456ff87df1 100644
--- a/include/qemu/mmap-alloc.h
+++ b/include/qemu/mmap-alloc.h
@@ -7,22 +7,18 @@ size_t qemu_fd_getpagesize(int fd);
 size_t qemu_mempath_getpagesize(const char *mem_path);
 
 /**
- * qemu_ram_mmap: mmap anonymous memory, the specified file or device.
- *
- * mmap() abstraction to map guest RAM, simplifying flag handling, taking
- * care of alignment requirements and installing guard pages.
+ * qemu_ram_mmap: mmap the specified file or device.
  *
  * Parameters:
  *  @fd: the file or the device to mmap
  *  @size: the number of bytes to be mmaped
  *  @align: if not zero, specify the alignment of the starting mapping address;
  *          otherwise, the alignment in use will be determined by QEMU.
- *  @qemu_map_flags: QEMU_MAP_* flags
+ *  @readonly: true for a read-only mapping, false for read/write.
+ *  @shared: map has RAM_SHARED flag.
+ *  @is_pmem: map has RAM_PMEM flag.
  *  @map_offset: map starts at offset of map_offset from the start of fd
  *
- * Internally, MAP_PRIVATE, MAP_ANONYMOUS and MAP_SHARED_VALIDATE are set
- * implicitly based on other parameters.
- *
  * Return:
  *  On success, return a pointer to the mapped area.
  *  On failure, return MAP_FAILED.
@@ -30,7 +26,9 @@ size_t qemu_mempath_getpagesize(const char *mem_path);
 void *qemu_ram_mmap(int fd,
                     size_t size,
                     size_t align,
-                    uint32_t qemu_map_flags,
+                    bool readonly,
+                    bool shared,
+                    bool is_pmem,
                     off_t map_offset);
 
 void qemu_ram_munmap(int fd, void *ptr, size_t size);
diff --git a/include/qemu/osdep.h b/include/qemu/osdep.h
index 0a54bf7be8..236a045671 100644
--- a/include/qemu/osdep.h
+++ b/include/qemu/osdep.h
@@ -195,9 +195,6 @@ extern "C" {
 #ifndef MAP_FIXED_NOREPLACE
 #define MAP_FIXED_NOREPLACE 0
 #endif
-#ifndef MAP_NORESERVE
-#define MAP_NORESERVE 0
-#endif
 #ifndef ENOMEDIUM
 #define ENOMEDIUM ENODEV
 #endif
@@ -365,35 +362,10 @@ extern "C" {
 int qemu_daemon(int nochdir, int noclose);
 void *qemu_try_memalign(size_t alignment, size_t size);
 void *qemu_memalign(size_t alignment, size_t size);
-void *qemu_anon_ram_alloc(size_t size, uint64_t *align, bool shared,
-                          bool noreserve);
+void *qemu_anon_ram_alloc(size_t size, uint64_t *align, bool shared);
 void qemu_vfree(void *ptr);
 void qemu_anon_ram_free(void *ptr, size_t size);
 
-/*
- * Abstraction of PROT_ and MAP_ flags as passed to mmap(), for example,
- * consumed by qemu_ram_mmap().
- */
-
-/* Map PROT_READ instead of PROT_READ | PROT_WRITE. */
-#define QEMU_MAP_READONLY   (1 << 0)
-
-/* Use MAP_SHARED instead of MAP_PRIVATE. */
-#define QEMU_MAP_SHARED     (1 << 1)
-
-/*
- * Use MAP_SYNC | MAP_SHARED_VALIDATE if supported. Ignored without
- * QEMU_MAP_SHARED. If mapping fails, warn and fallback to !QEMU_MAP_SYNC.
- */
-#define QEMU_MAP_SYNC       (1 << 2)
-
-/*
- * Use MAP_NORESERVE to skip reservation of swap space (or huge pages if
- * applicable). Bail out if not supported/effective.
- */
-#define QEMU_MAP_NORESERVE  (1 << 3)
-
-
 #define QEMU_MADV_INVALID -1
 
 #if defined(CONFIG_MADVISE)
@@ -438,7 +410,7 @@ void qemu_anon_ram_free(void *ptr, size_t size);
 #ifdef MADV_REMOVE
 #define QEMU_MADV_REMOVE MADV_REMOVE
 #else
-#define QEMU_MADV_REMOVE QEMU_MADV_DONTNEED
+#define QEMU_MADV_REMOVE QEMU_MADV_INVALID
 #endif
 
 #elif defined(CONFIG_POSIX_MADVISE)
@@ -452,7 +424,7 @@ void qemu_anon_ram_free(void *ptr, size_t size);
 #define QEMU_MADV_DONTDUMP QEMU_MADV_INVALID
 #define QEMU_MADV_HUGEPAGE  QEMU_MADV_INVALID
 #define QEMU_MADV_NOHUGEPAGE  QEMU_MADV_INVALID
-#define QEMU_MADV_REMOVE QEMU_MADV_DONTNEED
+#define QEMU_MADV_REMOVE QEMU_MADV_INVALID
 
 #else /* no-op */
 
diff --git a/include/standard-headers/drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.h b/include/standard-headers/drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.h
index 1677208a41..94d41b202c 100644
--- a/include/standard-headers/drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.h
+++ b/include/standard-headers/drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.h
@@ -70,30 +70,6 @@ enum pvrdma_mtu {
 	PVRDMA_MTU_4096 = 5,
 };
 
-static inline int pvrdma_mtu_enum_to_int(enum pvrdma_mtu mtu)
-{
-	switch (mtu) {
-	case PVRDMA_MTU_256:	return  256;
-	case PVRDMA_MTU_512:	return  512;
-	case PVRDMA_MTU_1024:	return 1024;
-	case PVRDMA_MTU_2048:	return 2048;
-	case PVRDMA_MTU_4096:	return 4096;
-	default:		return   -1;
-	}
-}
-
-static inline enum pvrdma_mtu pvrdma_mtu_int_to_enum(int mtu)
-{
-	switch (mtu) {
-	case 256:	return PVRDMA_MTU_256;
-	case 512:	return PVRDMA_MTU_512;
-	case 1024:	return PVRDMA_MTU_1024;
-	case 2048:	return PVRDMA_MTU_2048;
-	case 4096:
-	default:	return PVRDMA_MTU_4096;
-	}
-}
-
 enum pvrdma_port_state {
 	PVRDMA_PORT_NOP			= 0,
 	PVRDMA_PORT_DOWN		= 1,
@@ -138,17 +114,6 @@ enum pvrdma_port_width {
 	PVRDMA_WIDTH_12X	= 8,
 };
 
-static inline int pvrdma_width_enum_to_int(enum pvrdma_port_width width)
-{
-	switch (width) {
-	case PVRDMA_WIDTH_1X:	return  1;
-	case PVRDMA_WIDTH_4X:	return  4;
-	case PVRDMA_WIDTH_8X:	return  8;
-	case PVRDMA_WIDTH_12X:	return 12;
-	default:		return -1;
-	}
-}
-
 enum pvrdma_port_speed {
 	PVRDMA_SPEED_SDR	= 1,
 	PVRDMA_SPEED_DDR	= 2,
diff --git a/include/standard-headers/drm/drm_fourcc.h b/include/standard-headers/drm/drm_fourcc.h
index c47e19810c..a61ae520c2 100644
--- a/include/standard-headers/drm/drm_fourcc.h
+++ b/include/standard-headers/drm/drm_fourcc.h
@@ -526,6 +526,25 @@ extern "C" {
  */
 #define I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS fourcc_mod_code(INTEL, 7)
 
+/*
+ * Intel Color Control Surface with Clear Color (CCS) for Gen-12 render
+ * compression.
+ *
+ * The main surface is Y-tiled and is at plane index 0 whereas CCS is linear
+ * and at index 1. The clear color is stored at index 2, and the pitch should
+ * be ignored. The clear color structure is 256 bits. The first 128 bits
+ * represents Raw Clear Color Red, Green, Blue and Alpha color each represented
+ * by 32 bits. The raw clear color is consumed by the 3d engine and generates
+ * the converted clear color of size 64 bits. The first 32 bits store the Lower
+ * Converted Clear Color value and the next 32 bits store the Higher Converted
+ * Clear Color value when applicable. The Converted Clear Color values are
+ * consumed by the DE. The last 64 bits are used to store Color Discard Enable
+ * and Depth Clear Value Valid which are ignored by the DE. A CCS cache line
+ * corresponds to an area of 4x1 tiles in the main surface. The main surface
+ * pitch is required to be a multiple of 4 tile widths.
+ */
+#define I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS_CC fourcc_mod_code(INTEL, 8)
+
 /*
  * Tiled, NV12MT, grouped in 64 (pixels) x 32 (lines) -sized macroblocks
  *
@@ -1035,9 +1054,9 @@ drm_fourcc_canonicalize_nvidia_format_mod(uint64_t modifier)
  * Not all combinations are valid, and different SoCs may support different
  * combinations of layout and options.
  */
-#define __fourcc_mod_amlogic_layout_mask 0xf
+#define __fourcc_mod_amlogic_layout_mask 0xff
 #define __fourcc_mod_amlogic_options_shift 8
-#define __fourcc_mod_amlogic_options_mask 0xf
+#define __fourcc_mod_amlogic_options_mask 0xff
 
 #define DRM_FORMAT_MOD_AMLOGIC_FBC(__layout, __options) \
 	fourcc_mod_code(AMLOGIC, \
diff --git a/include/standard-headers/linux/ethtool.h b/include/standard-headers/linux/ethtool.h
index 8bfd01d230..218d944a17 100644
--- a/include/standard-headers/linux/ethtool.h
+++ b/include/standard-headers/linux/ethtool.h
@@ -26,6 +26,14 @@
  * have the same layout for 32-bit and 64-bit userland.
  */
 
+/* Note on reserved space.
+ * Reserved fields must not be accessed directly by user space because
+ * they may be replaced by a different field in the future. They must
+ * be initialized to zero before making the request, e.g. via memset
+ * of the entire structure or implicitly by not being set in a structure
+ * initializer.
+ */
+
 /**
  * struct ethtool_cmd - DEPRECATED, link control and status
  * This structure is DEPRECATED, please use struct ethtool_link_settings.
@@ -67,6 +75,7 @@
  *	and other link features that the link partner advertised
  *	through autonegotiation; 0 if unknown or not applicable.
  *	Read-only.
+ * @reserved: Reserved for future use; see the note on reserved space.
  *
  * The link speed in Mbps is split between @speed and @speed_hi.  Use
  * the ethtool_cmd_speed() and ethtool_cmd_speed_set() functions to
@@ -155,6 +164,7 @@ static inline uint32_t ethtool_cmd_speed(const struct ethtool_cmd *ep)
  * @bus_info: Device bus address.  This should match the dev_name()
  *	string for the underlying bus device, if there is one.  May be
  *	an empty string.
+ * @reserved2: Reserved for future use; see the note on reserved space.
  * @n_priv_flags: Number of flags valid for %ETHTOOL_GPFLAGS and
  *	%ETHTOOL_SPFLAGS commands; also the number of strings in the
  *	%ETH_SS_PRIV_FLAGS set
@@ -356,6 +366,7 @@ struct ethtool_eeprom {
  * @tx_lpi_timer: Time in microseconds the interface delays prior to asserting
  *	its tx lpi (after reaching 'idle' state). Effective only when eee
  *	was negotiated and tx_lpi_enabled was set.
+ * @reserved: Reserved for future use; see the note on reserved space.
  */
 struct ethtool_eee {
 	uint32_t	cmd;
@@ -374,6 +385,7 @@ struct ethtool_eee {
  * @cmd: %ETHTOOL_GMODULEINFO
  * @type: Standard the module information conforms to %ETH_MODULE_SFF_xxxx
  * @eeprom_len: Length of the eeprom
+ * @reserved: Reserved for future use; see the note on reserved space.
  *
  * This structure is used to return the information to
  * properly size memory for a subsequent call to %ETHTOOL_GMODULEEEPROM.
@@ -579,9 +591,7 @@ struct ethtool_pauseparam {
 	uint32_t	tx_pause;
 };
 
-/**
- * enum ethtool_link_ext_state - link extended state
- */
+/* Link extended state */
 enum ethtool_link_ext_state {
 	ETHTOOL_LINK_EXT_STATE_AUTONEG,
 	ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE,
@@ -595,10 +605,7 @@ enum ethtool_link_ext_state {
 	ETHTOOL_LINK_EXT_STATE_OVERHEAT,
 };
 
-/**
- * enum ethtool_link_ext_substate_autoneg - more information in addition to
- * ETHTOOL_LINK_EXT_STATE_AUTONEG.
- */
+/* More information in addition to ETHTOOL_LINK_EXT_STATE_AUTONEG. */
 enum ethtool_link_ext_substate_autoneg {
 	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED = 1,
 	ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED,
@@ -608,9 +615,7 @@ enum ethtool_link_ext_substate_autoneg {
 	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD,
 };
 
-/**
- * enum ethtool_link_ext_substate_link_training - more information in addition to
- * ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE.
+/* More information in addition to ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE.
  */
 enum ethtool_link_ext_substate_link_training {
 	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED = 1,
@@ -619,9 +624,7 @@ enum ethtool_link_ext_substate_link_training {
 	ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT,
 };
 
-/**
- * enum ethtool_link_ext_substate_logical_mismatch - more information in addition
- * to ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH.
+/* More information in addition to ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH.
  */
 enum ethtool_link_ext_substate_link_logical_mismatch {
 	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK = 1,
@@ -631,19 +634,14 @@ enum ethtool_link_ext_substate_link_logical_mismatch {
 	ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED,
 };
 
-/**
- * enum ethtool_link_ext_substate_bad_signal_integrity - more information in
- * addition to ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY.
+/* More information in addition to ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY.
  */
 enum ethtool_link_ext_substate_bad_signal_integrity {
 	ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS = 1,
 	ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE,
 };
 
-/**
- * enum ethtool_link_ext_substate_cable_issue - more information in
- * addition to ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE.
- */
+/* More information in addition to ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE. */
 enum ethtool_link_ext_substate_cable_issue {
 	ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE = 1,
 	ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE,
@@ -661,6 +659,7 @@ enum ethtool_link_ext_substate_cable_issue {
  *	now deprecated
  * @ETH_SS_FEATURES: Device feature names
  * @ETH_SS_RSS_HASH_FUNCS: RSS hush function names
+ * @ETH_SS_TUNABLES: tunable names
  * @ETH_SS_PHY_STATS: Statistic names, for use with %ETHTOOL_GPHYSTATS
  * @ETH_SS_PHY_TUNABLES: PHY tunable names
  * @ETH_SS_LINK_MODES: link mode names
@@ -670,6 +669,13 @@ enum ethtool_link_ext_substate_cable_issue {
  * @ETH_SS_TS_TX_TYPES: timestamping Tx types
  * @ETH_SS_TS_RX_FILTERS: timestamping Rx filters
  * @ETH_SS_UDP_TUNNEL_TYPES: UDP tunnel types
+ * @ETH_SS_STATS_STD: standardized stats
+ * @ETH_SS_STATS_ETH_PHY: names of IEEE 802.3 PHY statistics
+ * @ETH_SS_STATS_ETH_MAC: names of IEEE 802.3 MAC statistics
+ * @ETH_SS_STATS_ETH_CTRL: names of IEEE 802.3 MAC Control statistics
+ * @ETH_SS_STATS_RMON: names of RMON statistics
+ *
+ * @ETH_SS_COUNT: number of defined string sets
  */
 enum ethtool_stringset {
 	ETH_SS_TEST		= 0,
@@ -688,6 +694,11 @@ enum ethtool_stringset {
 	ETH_SS_TS_TX_TYPES,
 	ETH_SS_TS_RX_FILTERS,
 	ETH_SS_UDP_TUNNEL_TYPES,
+	ETH_SS_STATS_STD,
+	ETH_SS_STATS_ETH_PHY,
+	ETH_SS_STATS_ETH_MAC,
+	ETH_SS_STATS_ETH_CTRL,
+	ETH_SS_STATS_RMON,
 
 	/* add new constants above here */
 	ETH_SS_COUNT
@@ -715,6 +726,7 @@ struct ethtool_gstrings {
 /**
  * struct ethtool_sset_info - string set information
  * @cmd: Command number = %ETHTOOL_GSSET_INFO
+ * @reserved: Reserved for future use; see the note on reserved space.
  * @sset_mask: On entry, a bitmask of string sets to query, with bits
  *	numbered according to &enum ethtool_stringset.  On return, a
  *	bitmask of those string sets queried that are supported.
@@ -759,6 +771,7 @@ enum ethtool_test_flags {
  * @flags: A bitmask of flags from &enum ethtool_test_flags.  Some
  *	flags may be set by the user on entry; others may be set by
  *	the driver on return.
+ * @reserved: Reserved for future use; see the note on reserved space.
  * @len: On return, the number of test results
  * @data: Array of test results
  *
@@ -959,6 +972,7 @@ union ethtool_flow_union {
  * @vlan_etype: VLAN EtherType
  * @vlan_tci: VLAN tag control information
  * @data: user defined data
+ * @padding: Reserved for future use; see the note on reserved space.
  *
  * Note, @vlan_etype, @vlan_tci, and @data are only valid if %FLOW_EXT
  * is set in &struct ethtool_rx_flow_spec @flow_type.
@@ -1134,7 +1148,8 @@ struct ethtool_rxfh_indir {
  *	hardware hash key.
  * @hfunc: Defines the current RSS hash function used by HW (or to be set to).
  *	Valid values are one of the %ETH_RSS_HASH_*.
- * @rsvd:	Reserved for future extensions.
+ * @rsvd8: Reserved for future use; see the note on reserved space.
+ * @rsvd32: Reserved for future use; see the note on reserved space.
  * @rss_config: RX ring/queue index for each hash value i.e., indirection table
  *	of @indir_size uint32_t elements, followed by hash key of @key_size
  *	bytes.
@@ -1302,7 +1317,9 @@ struct ethtool_sfeatures {
  * @so_timestamping: bit mask of the sum of the supported SO_TIMESTAMPING flags
  * @phc_index: device index of the associated PHC, or -1 if there is none
  * @tx_types: bit mask of the supported hwtstamp_tx_types enumeration values
+ * @tx_reserved: Reserved for future use; see the note on reserved space.
  * @rx_filters: bit mask of the supported hwtstamp_rx_filters enumeration values
+ * @rx_reserved: Reserved for future use; see the note on reserved space.
  *
  * The bits in the 'tx_types' and 'rx_filters' fields correspond to
  * the 'hwtstamp_tx_types' and 'hwtstamp_rx_filters' enumeration values,
@@ -1376,15 +1393,33 @@ struct ethtool_per_queue_op {
 };
 
 /**
- * struct ethtool_fecparam - Ethernet forward error correction(fec) parameters
+ * struct ethtool_fecparam - Ethernet Forward Error Correction parameters
  * @cmd: Command number = %ETHTOOL_GFECPARAM or %ETHTOOL_SFECPARAM
- * @active_fec: FEC mode which is active on porte
- * @fec: Bitmask of supported/configured FEC modes
- * @rsvd: Reserved for future extensions. i.e FEC bypass feature.
+ * @active_fec: FEC mode which is active on the port, single bit set, GET only.
+ * @fec: Bitmask of configured FEC modes.
+ * @reserved: Reserved for future extensions, ignore on GET, write 0 for SET.
  *
- * Drivers should reject a non-zero setting of @autoneg when
- * autoneogotiation is disabled (or not supported) for the link.
+ * Note that @reserved was never validated on input and ethtool user space
+ * left it uninitialized when calling SET. Hence going forward it can only be
+ * used to return a value to userspace with GET.
+ *
+ * FEC modes supported by the device can be read via %ETHTOOL_GLINKSETTINGS.
+ * FEC settings are configured by link autonegotiation whenever it's enabled.
+ * With autoneg on %ETHTOOL_GFECPARAM can be used to read the current mode.
+ *
+ * When autoneg is disabled %ETHTOOL_SFECPARAM controls the FEC settings.
+ * It is recommended that drivers only accept a single bit set in @fec.
+ * When multiple bits are set in @fec drivers may pick mode in an implementation
+ * dependent way. Drivers should reject mixing %ETHTOOL_FEC_AUTO_BIT with other
+ * FEC modes, because it's unclear whether in this case other modes constrain
+ * AUTO or are independent choices.
+ * Drivers must reject SET requests if they support none of the requested modes.
+ *
+ * If device does not support FEC drivers may use %ETHTOOL_FEC_NONE instead
+ * of returning %EOPNOTSUPP from %ETHTOOL_GFECPARAM.
  *
+ * See enum ethtool_fec_config_bits for definition of valid bits for both
+ * @fec and @active_fec.
  */
 struct ethtool_fecparam {
 	uint32_t   cmd;
@@ -1396,11 +1431,16 @@ struct ethtool_fecparam {
 
 /**
  * enum ethtool_fec_config_bits - flags definition of ethtool_fec_configuration
- * @ETHTOOL_FEC_NONE: FEC mode configuration is not supported
- * @ETHTOOL_FEC_AUTO: Default/Best FEC mode provided by driver
- * @ETHTOOL_FEC_OFF: No FEC Mode
- * @ETHTOOL_FEC_RS: Reed-Solomon Forward Error Detection mode
- * @ETHTOOL_FEC_BASER: Base-R/Reed-Solomon Forward Error Detection mode
+ * @ETHTOOL_FEC_NONE_BIT: FEC mode configuration is not supported. Should not
+ *			be used together with other bits. GET only.
+ * @ETHTOOL_FEC_AUTO_BIT: Select default/best FEC mode automatically, usually
+ *			based link mode and SFP parameters read from module's
+ *			EEPROM. This bit does _not_ mean autonegotiation.
+ * @ETHTOOL_FEC_OFF_BIT: No FEC Mode
+ * @ETHTOOL_FEC_RS_BIT: Reed-Solomon FEC Mode
+ * @ETHTOOL_FEC_BASER_BIT: Base-R/Reed-Solomon FEC Mode
+ * @ETHTOOL_FEC_LLRS_BIT: Low Latency Reed Solomon FEC Mode (25G/50G Ethernet
+ *			Consortium)
  */
 enum ethtool_fec_config_bits {
 	ETHTOOL_FEC_NONE_BIT,
@@ -1958,6 +1998,11 @@ enum ethtool_reset_flags {
  *	autonegotiation; 0 if unknown or not applicable.  Read-only.
  * @transceiver: Used to distinguish different possible PHY types,
  *	reported consistently by PHYLIB.  Read-only.
+ * @master_slave_cfg: Master/slave port mode.
+ * @master_slave_state: Master/slave port state.
+ * @reserved: Reserved for future use; see the note on reserved space.
+ * @reserved1: Reserved for future use; see the note on reserved space.
+ * @link_mode_masks: Variable length bitmaps.
  *
  * If autonegotiation is disabled, the speed and @duplex represent the
  * fixed link mode and are writable if the driver supports multiple
diff --git a/include/standard-headers/linux/fuse.h b/include/standard-headers/linux/fuse.h
index 950d7edb7e..cce105bfba 100644
--- a/include/standard-headers/linux/fuse.h
+++ b/include/standard-headers/linux/fuse.h
@@ -179,6 +179,8 @@
  *  7.33
  *  - add FUSE_HANDLE_KILLPRIV_V2, FUSE_WRITE_KILL_SUIDGID, FATTR_KILL_SUIDGID
  *  - add FUSE_OPEN_KILL_SUIDGID
+ *  - extend fuse_setxattr_in, add FUSE_SETXATTR_EXT
+ *  - add FUSE_SETXATTR_ACL_KILL_SGID
  */
 
 #ifndef _LINUX_FUSE_H
@@ -326,6 +328,7 @@ struct fuse_file_lock {
  *			does not have CAP_FSETID. Additionally upon
  *			write/truncate sgid is killed only if file has group
  *			execute permission. (Same as Linux VFS behavior).
+ * FUSE_SETXATTR_EXT:	Server supports extended struct fuse_setxattr_in
  */
 #define FUSE_ASYNC_READ		(1 << 0)
 #define FUSE_POSIX_LOCKS	(1 << 1)
@@ -356,6 +359,7 @@ struct fuse_file_lock {
 #define FUSE_MAP_ALIGNMENT	(1 << 26)
 #define FUSE_SUBMOUNTS		(1 << 27)
 #define FUSE_HANDLE_KILLPRIV_V2	(1 << 28)
+#define FUSE_SETXATTR_EXT	(1 << 29)
 
 /**
  * CUSE INIT request/reply flags
@@ -447,6 +451,12 @@ struct fuse_file_lock {
  */
 #define FUSE_OPEN_KILL_SUIDGID	(1 << 0)
 
+/**
+ * setxattr flags
+ * FUSE_SETXATTR_ACL_KILL_SGID: Clear SGID when system.posix_acl_access is set
+ */
+#define FUSE_SETXATTR_ACL_KILL_SGID	(1 << 0)
+
 enum fuse_opcode {
 	FUSE_LOOKUP		= 1,
 	FUSE_FORGET		= 2,  /* no reply */
@@ -677,9 +687,13 @@ struct fuse_fsync_in {
 	uint32_t	padding;
 };
 
+#define FUSE_COMPAT_SETXATTR_IN_SIZE 8
+
 struct fuse_setxattr_in {
 	uint32_t	size;
 	uint32_t	flags;
+	uint32_t	setxattr_flags;
+	uint32_t	padding;
 };
 
 struct fuse_getxattr_in {
@@ -899,7 +913,8 @@ struct fuse_notify_retrieve_in {
 };
 
 /* Device ioctls: */
-#define FUSE_DEV_IOC_CLONE	_IOR(229, 0, uint32_t)
+#define FUSE_DEV_IOC_MAGIC		229
+#define FUSE_DEV_IOC_CLONE		_IOR(FUSE_DEV_IOC_MAGIC, 0, uint32_t)
 
 struct fuse_lseek_in {
 	uint64_t	fh;
diff --git a/include/standard-headers/linux/input.h b/include/standard-headers/linux/input.h
index f89c986190..7822c24178 100644
--- a/include/standard-headers/linux/input.h
+++ b/include/standard-headers/linux/input.h
@@ -81,7 +81,7 @@ struct input_id {
  * in units per radian.
  * When INPUT_PROP_ACCELEROMETER is set the resolution changes.
  * The main axes (ABS_X, ABS_Y, ABS_Z) are then reported in
- * in units per g (units/g) and in units per degree per second
+ * units per g (units/g) and in units per degree per second
  * (units/deg/s) for rotational axes (ABS_RX, ABS_RY, ABS_RZ).
  */
 struct input_absinfo {
diff --git a/include/standard-headers/linux/virtio_bt.h b/include/standard-headers/linux/virtio_bt.h
new file mode 100644
index 0000000000..245e1eff4b
--- /dev/null
+++ b/include/standard-headers/linux/virtio_bt.h
@@ -0,0 +1,31 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+#ifndef _LINUX_VIRTIO_BT_H
+#define _LINUX_VIRTIO_BT_H
+
+#include "standard-headers/linux/virtio_types.h"
+
+/* Feature bits */
+#define VIRTIO_BT_F_VND_HCI	0	/* Indicates vendor command support */
+#define VIRTIO_BT_F_MSFT_EXT	1	/* Indicates MSFT vendor support */
+#define VIRTIO_BT_F_AOSP_EXT	2	/* Indicates AOSP vendor support */
+
+enum virtio_bt_config_type {
+	VIRTIO_BT_CONFIG_TYPE_PRIMARY	= 0,
+	VIRTIO_BT_CONFIG_TYPE_AMP	= 1,
+};
+
+enum virtio_bt_config_vendor {
+	VIRTIO_BT_CONFIG_VENDOR_NONE	= 0,
+	VIRTIO_BT_CONFIG_VENDOR_ZEPHYR	= 1,
+	VIRTIO_BT_CONFIG_VENDOR_INTEL	= 2,
+	VIRTIO_BT_CONFIG_VENDOR_REALTEK	= 3,
+};
+
+struct virtio_bt_config {
+	uint8_t  type;
+	uint16_t vendor;
+	uint16_t msft_opcode;
+} QEMU_PACKED;
+
+#endif /* _LINUX_VIRTIO_BT_H */
diff --git a/include/standard-headers/linux/virtio_ids.h b/include/standard-headers/linux/virtio_ids.h
index bc1c0621f5..f0c35ce862 100644
--- a/include/standard-headers/linux/virtio_ids.h
+++ b/include/standard-headers/linux/virtio_ids.h
@@ -51,8 +51,10 @@
 #define VIRTIO_ID_PSTORE		22 /* virtio pstore device */
 #define VIRTIO_ID_IOMMU			23 /* virtio IOMMU */
 #define VIRTIO_ID_MEM			24 /* virtio mem */
+#define VIRTIO_ID_SOUND			25 /* virtio sound */
 #define VIRTIO_ID_FS			26 /* virtio filesystem */
 #define VIRTIO_ID_PMEM			27 /* virtio pmem */
+#define VIRTIO_ID_BT			28 /* virtio bluetooth */
 #define VIRTIO_ID_MAC80211_HWSIM	29 /* virtio mac80211-hwsim */
 
 #endif /* _LINUX_VIRTIO_IDS_H */
diff --git a/include/standard-headers/linux/virtio_snd.h b/include/standard-headers/linux/virtio_snd.h
new file mode 100644
index 0000000000..1af96b9fc6
--- /dev/null
+++ b/include/standard-headers/linux/virtio_snd.h
@@ -0,0 +1,334 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+/*
+ * Copyright (C) 2021 OpenSynergy GmbH
+ */
+#ifndef VIRTIO_SND_IF_H
+#define VIRTIO_SND_IF_H
+
+#include "standard-headers/linux/virtio_types.h"
+
+/*******************************************************************************
+ * CONFIGURATION SPACE
+ */
+struct virtio_snd_config {
+	/* # of available physical jacks */
+	uint32_t jacks;
+	/* # of available PCM streams */
+	uint32_t streams;
+	/* # of available channel maps */
+	uint32_t chmaps;
+};
+
+enum {
+	/* device virtqueue indexes */
+	VIRTIO_SND_VQ_CONTROL = 0,
+	VIRTIO_SND_VQ_EVENT,
+	VIRTIO_SND_VQ_TX,
+	VIRTIO_SND_VQ_RX,
+	/* # of device virtqueues */
+	VIRTIO_SND_VQ_MAX
+};
+
+/*******************************************************************************
+ * COMMON DEFINITIONS
+ */
+
+/* supported dataflow directions */
+enum {
+	VIRTIO_SND_D_OUTPUT = 0,
+	VIRTIO_SND_D_INPUT
+};
+
+enum {
+	/* jack control request types */
+	VIRTIO_SND_R_JACK_INFO = 1,
+	VIRTIO_SND_R_JACK_REMAP,
+
+	/* PCM control request types */
+	VIRTIO_SND_R_PCM_INFO = 0x0100,
+	VIRTIO_SND_R_PCM_SET_PARAMS,
+	VIRTIO_SND_R_PCM_PREPARE,
+	VIRTIO_SND_R_PCM_RELEASE,
+	VIRTIO_SND_R_PCM_START,
+	VIRTIO_SND_R_PCM_STOP,
+
+	/* channel map control request types */
+	VIRTIO_SND_R_CHMAP_INFO = 0x0200,
+
+	/* jack event types */
+	VIRTIO_SND_EVT_JACK_CONNECTED = 0x1000,
+	VIRTIO_SND_EVT_JACK_DISCONNECTED,
+
+	/* PCM event types */
+	VIRTIO_SND_EVT_PCM_PERIOD_ELAPSED = 0x1100,
+	VIRTIO_SND_EVT_PCM_XRUN,
+
+	/* common status codes */
+	VIRTIO_SND_S_OK = 0x8000,
+	VIRTIO_SND_S_BAD_MSG,
+	VIRTIO_SND_S_NOT_SUPP,
+	VIRTIO_SND_S_IO_ERR
+};
+
+/* common header */
+struct virtio_snd_hdr {
+	uint32_t code;
+};
+
+/* event notification */
+struct virtio_snd_event {
+	/* VIRTIO_SND_EVT_XXX */
+	struct virtio_snd_hdr hdr;
+	/* optional event data */
+	uint32_t data;
+};
+
+/* common control request to query an item information */
+struct virtio_snd_query_info {
+	/* VIRTIO_SND_R_XXX_INFO */
+	struct virtio_snd_hdr hdr;
+	/* item start identifier */
+	uint32_t start_id;
+	/* item count to query */
+	uint32_t count;
+	/* item information size in bytes */
+	uint32_t size;
+};
+
+/* common item information header */
+struct virtio_snd_info {
+	/* function group node id (High Definition Audio Specification 7.1.2) */
+	uint32_t hda_fn_nid;
+};
+
+/*******************************************************************************
+ * JACK CONTROL MESSAGES
+ */
+struct virtio_snd_jack_hdr {
+	/* VIRTIO_SND_R_JACK_XXX */
+	struct virtio_snd_hdr hdr;
+	/* 0 ... virtio_snd_config::jacks - 1 */
+	uint32_t jack_id;
+};
+
+/* supported jack features */
+enum {
+	VIRTIO_SND_JACK_F_REMAP = 0
+};
+
+struct virtio_snd_jack_info {
+	/* common header */
+	struct virtio_snd_info hdr;
+	/* supported feature bit map (1 << VIRTIO_SND_JACK_F_XXX) */
+	uint32_t features;
+	/* pin configuration (High Definition Audio Specification 7.3.3.31) */
+	uint32_t hda_reg_defconf;
+	/* pin capabilities (High Definition Audio Specification 7.3.4.9) */
+	uint32_t hda_reg_caps;
+	/* current jack connection status (0: disconnected, 1: connected) */
+	uint8_t connected;
+
+	uint8_t padding[7];
+};
+
+/* jack remapping control request */
+struct virtio_snd_jack_remap {
+	/* .code = VIRTIO_SND_R_JACK_REMAP */
+	struct virtio_snd_jack_hdr hdr;
+	/* selected association number */
+	uint32_t association;
+	/* selected sequence number */
+	uint32_t sequence;
+};
+
+/*******************************************************************************
+ * PCM CONTROL MESSAGES
+ */
+struct virtio_snd_pcm_hdr {
+	/* VIRTIO_SND_R_PCM_XXX */
+	struct virtio_snd_hdr hdr;
+	/* 0 ... virtio_snd_config::streams - 1 */
+	uint32_t stream_id;
+};
+
+/* supported PCM stream features */
+enum {
+	VIRTIO_SND_PCM_F_SHMEM_HOST = 0,
+	VIRTIO_SND_PCM_F_SHMEM_GUEST,
+	VIRTIO_SND_PCM_F_MSG_POLLING,
+	VIRTIO_SND_PCM_F_EVT_SHMEM_PERIODS,
+	VIRTIO_SND_PCM_F_EVT_XRUNS
+};
+
+/* supported PCM sample formats */
+enum {
+	/* analog formats (width / physical width) */
+	VIRTIO_SND_PCM_FMT_IMA_ADPCM = 0,	/*  4 /  4 bits */
+	VIRTIO_SND_PCM_FMT_MU_LAW,		/*  8 /  8 bits */
+	VIRTIO_SND_PCM_FMT_A_LAW,		/*  8 /  8 bits */
+	VIRTIO_SND_PCM_FMT_S8,			/*  8 /  8 bits */
+	VIRTIO_SND_PCM_FMT_U8,			/*  8 /  8 bits */
+	VIRTIO_SND_PCM_FMT_S16,			/* 16 / 16 bits */
+	VIRTIO_SND_PCM_FMT_U16,			/* 16 / 16 bits */
+	VIRTIO_SND_PCM_FMT_S18_3,		/* 18 / 24 bits */
+	VIRTIO_SND_PCM_FMT_U18_3,		/* 18 / 24 bits */
+	VIRTIO_SND_PCM_FMT_S20_3,		/* 20 / 24 bits */
+	VIRTIO_SND_PCM_FMT_U20_3,		/* 20 / 24 bits */
+	VIRTIO_SND_PCM_FMT_S24_3,		/* 24 / 24 bits */
+	VIRTIO_SND_PCM_FMT_U24_3,		/* 24 / 24 bits */
+	VIRTIO_SND_PCM_FMT_S20,			/* 20 / 32 bits */
+	VIRTIO_SND_PCM_FMT_U20,			/* 20 / 32 bits */
+	VIRTIO_SND_PCM_FMT_S24,			/* 24 / 32 bits */
+	VIRTIO_SND_PCM_FMT_U24,			/* 24 / 32 bits */
+	VIRTIO_SND_PCM_FMT_S32,			/* 32 / 32 bits */
+	VIRTIO_SND_PCM_FMT_U32,			/* 32 / 32 bits */
+	VIRTIO_SND_PCM_FMT_FLOAT,		/* 32 / 32 bits */
+	VIRTIO_SND_PCM_FMT_FLOAT64,		/* 64 / 64 bits */
+	/* digital formats (width / physical width) */
+	VIRTIO_SND_PCM_FMT_DSD_U8,		/*  8 /  8 bits */
+	VIRTIO_SND_PCM_FMT_DSD_U16,		/* 16 / 16 bits */
+	VIRTIO_SND_PCM_FMT_DSD_U32,		/* 32 / 32 bits */
+	VIRTIO_SND_PCM_FMT_IEC958_SUBFRAME	/* 32 / 32 bits */
+};
+
+/* supported PCM frame rates */
+enum {
+	VIRTIO_SND_PCM_RATE_5512 = 0,
+	VIRTIO_SND_PCM_RATE_8000,
+	VIRTIO_SND_PCM_RATE_11025,
+	VIRTIO_SND_PCM_RATE_16000,
+	VIRTIO_SND_PCM_RATE_22050,
+	VIRTIO_SND_PCM_RATE_32000,
+	VIRTIO_SND_PCM_RATE_44100,
+	VIRTIO_SND_PCM_RATE_48000,
+	VIRTIO_SND_PCM_RATE_64000,
+	VIRTIO_SND_PCM_RATE_88200,
+	VIRTIO_SND_PCM_RATE_96000,
+	VIRTIO_SND_PCM_RATE_176400,
+	VIRTIO_SND_PCM_RATE_192000,
+	VIRTIO_SND_PCM_RATE_384000
+};
+
+struct virtio_snd_pcm_info {
+	/* common header */
+	struct virtio_snd_info hdr;
+	/* supported feature bit map (1 << VIRTIO_SND_PCM_F_XXX) */
+	uint32_t features;
+	/* supported sample format bit map (1 << VIRTIO_SND_PCM_FMT_XXX) */
+	uint64_t formats;
+	/* supported frame rate bit map (1 << VIRTIO_SND_PCM_RATE_XXX) */
+	uint64_t rates;
+	/* dataflow direction (VIRTIO_SND_D_XXX) */
+	uint8_t direction;
+	/* minimum # of supported channels */
+	uint8_t channels_min;
+	/* maximum # of supported channels */
+	uint8_t channels_max;
+
+	uint8_t padding[5];
+};
+
+/* set PCM stream format */
+struct virtio_snd_pcm_set_params {
+	/* .code = VIRTIO_SND_R_PCM_SET_PARAMS */
+	struct virtio_snd_pcm_hdr hdr;
+	/* size of the hardware buffer */
+	uint32_t buffer_bytes;
+	/* size of the hardware period */
+	uint32_t period_bytes;
+	/* selected feature bit map (1 << VIRTIO_SND_PCM_F_XXX) */
+	uint32_t features;
+	/* selected # of channels */
+	uint8_t channels;
+	/* selected sample format (VIRTIO_SND_PCM_FMT_XXX) */
+	uint8_t format;
+	/* selected frame rate (VIRTIO_SND_PCM_RATE_XXX) */
+	uint8_t rate;
+
+	uint8_t padding;
+};
+
+/*******************************************************************************
+ * PCM I/O MESSAGES
+ */
+
+/* I/O request header */
+struct virtio_snd_pcm_xfer {
+	/* 0 ... virtio_snd_config::streams - 1 */
+	uint32_t stream_id;
+};
+
+/* I/O request status */
+struct virtio_snd_pcm_status {
+	/* VIRTIO_SND_S_XXX */
+	uint32_t status;
+	/* current device latency */
+	uint32_t latency_bytes;
+};
+
+/*******************************************************************************
+ * CHANNEL MAP CONTROL MESSAGES
+ */
+struct virtio_snd_chmap_hdr {
+	/* VIRTIO_SND_R_CHMAP_XXX */
+	struct virtio_snd_hdr hdr;
+	/* 0 ... virtio_snd_config::chmaps - 1 */
+	uint32_t chmap_id;
+};
+
+/* standard channel position definition */
+enum {
+	VIRTIO_SND_CHMAP_NONE = 0,	/* undefined */
+	VIRTIO_SND_CHMAP_NA,		/* silent */
+	VIRTIO_SND_CHMAP_MONO,		/* mono stream */
+	VIRTIO_SND_CHMAP_FL,		/* front left */
+	VIRTIO_SND_CHMAP_FR,		/* front right */
+	VIRTIO_SND_CHMAP_RL,		/* rear left */
+	VIRTIO_SND_CHMAP_RR,		/* rear right */
+	VIRTIO_SND_CHMAP_FC,		/* front center */
+	VIRTIO_SND_CHMAP_LFE,		/* low frequency (LFE) */
+	VIRTIO_SND_CHMAP_SL,		/* side left */
+	VIRTIO_SND_CHMAP_SR,		/* side right */
+	VIRTIO_SND_CHMAP_RC,		/* rear center */
+	VIRTIO_SND_CHMAP_FLC,		/* front left center */
+	VIRTIO_SND_CHMAP_FRC,		/* front right center */
+	VIRTIO_SND_CHMAP_RLC,		/* rear left center */
+	VIRTIO_SND_CHMAP_RRC,		/* rear right center */
+	VIRTIO_SND_CHMAP_FLW,		/* front left wide */
+	VIRTIO_SND_CHMAP_FRW,		/* front right wide */
+	VIRTIO_SND_CHMAP_FLH,		/* front left high */
+	VIRTIO_SND_CHMAP_FCH,		/* front center high */
+	VIRTIO_SND_CHMAP_FRH,		/* front right high */
+	VIRTIO_SND_CHMAP_TC,		/* top center */
+	VIRTIO_SND_CHMAP_TFL,		/* top front left */
+	VIRTIO_SND_CHMAP_TFR,		/* top front right */
+	VIRTIO_SND_CHMAP_TFC,		/* top front center */
+	VIRTIO_SND_CHMAP_TRL,		/* top rear left */
+	VIRTIO_SND_CHMAP_TRR,		/* top rear right */
+	VIRTIO_SND_CHMAP_TRC,		/* top rear center */
+	VIRTIO_SND_CHMAP_TFLC,		/* top front left center */
+	VIRTIO_SND_CHMAP_TFRC,		/* top front right center */
+	VIRTIO_SND_CHMAP_TSL,		/* top side left */
+	VIRTIO_SND_CHMAP_TSR,		/* top side right */
+	VIRTIO_SND_CHMAP_LLFE,		/* left LFE */
+	VIRTIO_SND_CHMAP_RLFE,		/* right LFE */
+	VIRTIO_SND_CHMAP_BC,		/* bottom center */
+	VIRTIO_SND_CHMAP_BLC,		/* bottom left center */
+	VIRTIO_SND_CHMAP_BRC		/* bottom right center */
+};
+
+/* maximum possible number of channels */
+#define VIRTIO_SND_CHMAP_MAX_SIZE	18
+
+struct virtio_snd_chmap_info {
+	/* common header */
+	struct virtio_snd_info hdr;
+	/* dataflow direction (VIRTIO_SND_D_XXX) */
+	uint8_t direction;
+	/* # of valid channel position values */
+	uint8_t channels;
+	/* channel position values (VIRTIO_SND_CHMAP_XXX) */
+	uint8_t positions[VIRTIO_SND_CHMAP_MAX_SIZE];
+};
+
+#endif /* VIRTIO_SND_IF_H */
diff --git a/include/standard-headers/rdma/vmw_pvrdma-abi.h b/include/standard-headers/rdma/vmw_pvrdma-abi.h
index 0989426a3f..c30182a7ae 100644
--- a/include/standard-headers/rdma/vmw_pvrdma-abi.h
+++ b/include/standard-headers/rdma/vmw_pvrdma-abi.h
@@ -133,6 +133,13 @@ enum pvrdma_wc_flags {
 	PVRDMA_WC_FLAGS_MAX		= PVRDMA_WC_WITH_NETWORK_HDR_TYPE,
 };
 
+enum pvrdma_network_type {
+	PVRDMA_NETWORK_IB,
+	PVRDMA_NETWORK_ROCE_V1 = PVRDMA_NETWORK_IB,
+	PVRDMA_NETWORK_IPV4,
+	PVRDMA_NETWORK_IPV6
+};
+
 struct pvrdma_alloc_ucontext_resp {
 	uint32_t qp_tab_size;
 	uint32_t reserved;
diff --git a/include/sysemu/hostmem.h b/include/sysemu/hostmem.h
index 9ff5c16963..df5644723a 100644
--- a/include/sysemu/hostmem.h
+++ b/include/sysemu/hostmem.h
@@ -64,7 +64,7 @@ struct HostMemoryBackend {
     /* protected */
     uint64_t size;
     bool merge, dump, use_canonical_path;
-    bool prealloc, is_mapped, share, reserve;
+    bool prealloc, is_mapped, share;
     uint32_t prealloc_threads;
     DECLARE_BITMAP(host_nodes, MAX_NODES + 1);
     HostMemPolicy policy;
diff --git a/linux-headers/asm-generic/unistd.h b/linux-headers/asm-generic/unistd.h
index 7287529177..6de5a7fc06 100644
--- a/linux-headers/asm-generic/unistd.h
+++ b/linux-headers/asm-generic/unistd.h
@@ -861,9 +861,20 @@ __SYSCALL(__NR_faccessat2, sys_faccessat2)
 __SYSCALL(__NR_process_madvise, sys_process_madvise)
 #define __NR_epoll_pwait2 441
 __SC_COMP(__NR_epoll_pwait2, sys_epoll_pwait2, compat_sys_epoll_pwait2)
+#define __NR_mount_setattr 442
+__SYSCALL(__NR_mount_setattr, sys_mount_setattr)
+#define __NR_quotactl_path 443
+__SYSCALL(__NR_quotactl_path, sys_quotactl_path)
+
+#define __NR_landlock_create_ruleset 444
+__SYSCALL(__NR_landlock_create_ruleset, sys_landlock_create_ruleset)
+#define __NR_landlock_add_rule 445
+__SYSCALL(__NR_landlock_add_rule, sys_landlock_add_rule)
+#define __NR_landlock_restrict_self 446
+__SYSCALL(__NR_landlock_restrict_self, sys_landlock_restrict_self)
 
 #undef __NR_syscalls
-#define __NR_syscalls 442
+#define __NR_syscalls 447
 
 /*
  * 32 bit systems traditionally used different
diff --git a/linux-headers/asm-mips/unistd_n32.h b/linux-headers/asm-mips/unistd_n32.h
index 59e53b6e07..fce51fee09 100644
--- a/linux-headers/asm-mips/unistd_n32.h
+++ b/linux-headers/asm-mips/unistd_n32.h
@@ -1,376 +1,379 @@
-#ifndef _ASM_MIPS_UNISTD_N32_H
-#define _ASM_MIPS_UNISTD_N32_H
+#ifndef _ASM_UNISTD_N32_H
+#define _ASM_UNISTD_N32_H
 
-#define __NR_read	(__NR_Linux + 0)
-#define __NR_write	(__NR_Linux + 1)
-#define __NR_open	(__NR_Linux + 2)
-#define __NR_close	(__NR_Linux + 3)
-#define __NR_stat	(__NR_Linux + 4)
-#define __NR_fstat	(__NR_Linux + 5)
-#define __NR_lstat	(__NR_Linux + 6)
-#define __NR_poll	(__NR_Linux + 7)
-#define __NR_lseek	(__NR_Linux + 8)
-#define __NR_mmap	(__NR_Linux + 9)
-#define __NR_mprotect	(__NR_Linux + 10)
-#define __NR_munmap	(__NR_Linux + 11)
-#define __NR_brk	(__NR_Linux + 12)
-#define __NR_rt_sigaction	(__NR_Linux + 13)
-#define __NR_rt_sigprocmask	(__NR_Linux + 14)
-#define __NR_ioctl	(__NR_Linux + 15)
-#define __NR_pread64	(__NR_Linux + 16)
-#define __NR_pwrite64	(__NR_Linux + 17)
-#define __NR_readv	(__NR_Linux + 18)
-#define __NR_writev	(__NR_Linux + 19)
-#define __NR_access	(__NR_Linux + 20)
-#define __NR_pipe	(__NR_Linux + 21)
-#define __NR__newselect	(__NR_Linux + 22)
-#define __NR_sched_yield	(__NR_Linux + 23)
-#define __NR_mremap	(__NR_Linux + 24)
-#define __NR_msync	(__NR_Linux + 25)
-#define __NR_mincore	(__NR_Linux + 26)
-#define __NR_madvise	(__NR_Linux + 27)
-#define __NR_shmget	(__NR_Linux + 28)
-#define __NR_shmat	(__NR_Linux + 29)
-#define __NR_shmctl	(__NR_Linux + 30)
-#define __NR_dup	(__NR_Linux + 31)
-#define __NR_dup2	(__NR_Linux + 32)
-#define __NR_pause	(__NR_Linux + 33)
-#define __NR_nanosleep	(__NR_Linux + 34)
-#define __NR_getitimer	(__NR_Linux + 35)
-#define __NR_setitimer	(__NR_Linux + 36)
-#define __NR_alarm	(__NR_Linux + 37)
-#define __NR_getpid	(__NR_Linux + 38)
-#define __NR_sendfile	(__NR_Linux + 39)
-#define __NR_socket	(__NR_Linux + 40)
-#define __NR_connect	(__NR_Linux + 41)
-#define __NR_accept	(__NR_Linux + 42)
-#define __NR_sendto	(__NR_Linux + 43)
-#define __NR_recvfrom	(__NR_Linux + 44)
-#define __NR_sendmsg	(__NR_Linux + 45)
-#define __NR_recvmsg	(__NR_Linux + 46)
-#define __NR_shutdown	(__NR_Linux + 47)
-#define __NR_bind	(__NR_Linux + 48)
-#define __NR_listen	(__NR_Linux + 49)
-#define __NR_getsockname	(__NR_Linux + 50)
-#define __NR_getpeername	(__NR_Linux + 51)
-#define __NR_socketpair	(__NR_Linux + 52)
-#define __NR_setsockopt	(__NR_Linux + 53)
-#define __NR_getsockopt	(__NR_Linux + 54)
-#define __NR_clone	(__NR_Linux + 55)
-#define __NR_fork	(__NR_Linux + 56)
-#define __NR_execve	(__NR_Linux + 57)
-#define __NR_exit	(__NR_Linux + 58)
-#define __NR_wait4	(__NR_Linux + 59)
-#define __NR_kill	(__NR_Linux + 60)
-#define __NR_uname	(__NR_Linux + 61)
-#define __NR_semget	(__NR_Linux + 62)
-#define __NR_semop	(__NR_Linux + 63)
-#define __NR_semctl	(__NR_Linux + 64)
-#define __NR_shmdt	(__NR_Linux + 65)
-#define __NR_msgget	(__NR_Linux + 66)
-#define __NR_msgsnd	(__NR_Linux + 67)
-#define __NR_msgrcv	(__NR_Linux + 68)
-#define __NR_msgctl	(__NR_Linux + 69)
-#define __NR_fcntl	(__NR_Linux + 70)
-#define __NR_flock	(__NR_Linux + 71)
-#define __NR_fsync	(__NR_Linux + 72)
-#define __NR_fdatasync	(__NR_Linux + 73)
-#define __NR_truncate	(__NR_Linux + 74)
-#define __NR_ftruncate	(__NR_Linux + 75)
-#define __NR_getdents	(__NR_Linux + 76)
-#define __NR_getcwd	(__NR_Linux + 77)
-#define __NR_chdir	(__NR_Linux + 78)
-#define __NR_fchdir	(__NR_Linux + 79)
-#define __NR_rename	(__NR_Linux + 80)
-#define __NR_mkdir	(__NR_Linux + 81)
-#define __NR_rmdir	(__NR_Linux + 82)
-#define __NR_creat	(__NR_Linux + 83)
-#define __NR_link	(__NR_Linux + 84)
-#define __NR_unlink	(__NR_Linux + 85)
-#define __NR_symlink	(__NR_Linux + 86)
-#define __NR_readlink	(__NR_Linux + 87)
-#define __NR_chmod	(__NR_Linux + 88)
-#define __NR_fchmod	(__NR_Linux + 89)
-#define __NR_chown	(__NR_Linux + 90)
-#define __NR_fchown	(__NR_Linux + 91)
-#define __NR_lchown	(__NR_Linux + 92)
-#define __NR_umask	(__NR_Linux + 93)
-#define __NR_gettimeofday	(__NR_Linux + 94)
-#define __NR_getrlimit	(__NR_Linux + 95)
-#define __NR_getrusage	(__NR_Linux + 96)
-#define __NR_sysinfo	(__NR_Linux + 97)
-#define __NR_times	(__NR_Linux + 98)
-#define __NR_ptrace	(__NR_Linux + 99)
-#define __NR_getuid	(__NR_Linux + 100)
-#define __NR_syslog	(__NR_Linux + 101)
-#define __NR_getgid	(__NR_Linux + 102)
-#define __NR_setuid	(__NR_Linux + 103)
-#define __NR_setgid	(__NR_Linux + 104)
-#define __NR_geteuid	(__NR_Linux + 105)
-#define __NR_getegid	(__NR_Linux + 106)
-#define __NR_setpgid	(__NR_Linux + 107)
-#define __NR_getppid	(__NR_Linux + 108)
-#define __NR_getpgrp	(__NR_Linux + 109)
-#define __NR_setsid	(__NR_Linux + 110)
-#define __NR_setreuid	(__NR_Linux + 111)
-#define __NR_setregid	(__NR_Linux + 112)
-#define __NR_getgroups	(__NR_Linux + 113)
-#define __NR_setgroups	(__NR_Linux + 114)
-#define __NR_setresuid	(__NR_Linux + 115)
-#define __NR_getresuid	(__NR_Linux + 116)
-#define __NR_setresgid	(__NR_Linux + 117)
-#define __NR_getresgid	(__NR_Linux + 118)
-#define __NR_getpgid	(__NR_Linux + 119)
-#define __NR_setfsuid	(__NR_Linux + 120)
-#define __NR_setfsgid	(__NR_Linux + 121)
-#define __NR_getsid	(__NR_Linux + 122)
-#define __NR_capget	(__NR_Linux + 123)
-#define __NR_capset	(__NR_Linux + 124)
-#define __NR_rt_sigpending	(__NR_Linux + 125)
-#define __NR_rt_sigtimedwait	(__NR_Linux + 126)
-#define __NR_rt_sigqueueinfo	(__NR_Linux + 127)
-#define __NR_rt_sigsuspend	(__NR_Linux + 128)
-#define __NR_sigaltstack	(__NR_Linux + 129)
-#define __NR_utime	(__NR_Linux + 130)
-#define __NR_mknod	(__NR_Linux + 131)
-#define __NR_personality	(__NR_Linux + 132)
-#define __NR_ustat	(__NR_Linux + 133)
-#define __NR_statfs	(__NR_Linux + 134)
-#define __NR_fstatfs	(__NR_Linux + 135)
-#define __NR_sysfs	(__NR_Linux + 136)
-#define __NR_getpriority	(__NR_Linux + 137)
-#define __NR_setpriority	(__NR_Linux + 138)
-#define __NR_sched_setparam	(__NR_Linux + 139)
-#define __NR_sched_getparam	(__NR_Linux + 140)
-#define __NR_sched_setscheduler	(__NR_Linux + 141)
-#define __NR_sched_getscheduler	(__NR_Linux + 142)
-#define __NR_sched_get_priority_max	(__NR_Linux + 143)
-#define __NR_sched_get_priority_min	(__NR_Linux + 144)
-#define __NR_sched_rr_get_interval	(__NR_Linux + 145)
-#define __NR_mlock	(__NR_Linux + 146)
-#define __NR_munlock	(__NR_Linux + 147)
-#define __NR_mlockall	(__NR_Linux + 148)
-#define __NR_munlockall	(__NR_Linux + 149)
-#define __NR_vhangup	(__NR_Linux + 150)
-#define __NR_pivot_root	(__NR_Linux + 151)
-#define __NR__sysctl	(__NR_Linux + 152)
-#define __NR_prctl	(__NR_Linux + 153)
-#define __NR_adjtimex	(__NR_Linux + 154)
-#define __NR_setrlimit	(__NR_Linux + 155)
-#define __NR_chroot	(__NR_Linux + 156)
-#define __NR_sync	(__NR_Linux + 157)
-#define __NR_acct	(__NR_Linux + 158)
-#define __NR_settimeofday	(__NR_Linux + 159)
-#define __NR_mount	(__NR_Linux + 160)
-#define __NR_umount2	(__NR_Linux + 161)
-#define __NR_swapon	(__NR_Linux + 162)
-#define __NR_swapoff	(__NR_Linux + 163)
-#define __NR_reboot	(__NR_Linux + 164)
-#define __NR_sethostname	(__NR_Linux + 165)
-#define __NR_setdomainname	(__NR_Linux + 166)
-#define __NR_create_module	(__NR_Linux + 167)
-#define __NR_init_module	(__NR_Linux + 168)
-#define __NR_delete_module	(__NR_Linux + 169)
-#define __NR_get_kernel_syms	(__NR_Linux + 170)
-#define __NR_query_module	(__NR_Linux + 171)
-#define __NR_quotactl	(__NR_Linux + 172)
-#define __NR_nfsservctl	(__NR_Linux + 173)
-#define __NR_getpmsg	(__NR_Linux + 174)
-#define __NR_putpmsg	(__NR_Linux + 175)
-#define __NR_afs_syscall	(__NR_Linux + 176)
-#define __NR_reserved177	(__NR_Linux + 177)
-#define __NR_gettid	(__NR_Linux + 178)
-#define __NR_readahead	(__NR_Linux + 179)
-#define __NR_setxattr	(__NR_Linux + 180)
-#define __NR_lsetxattr	(__NR_Linux + 181)
-#define __NR_fsetxattr	(__NR_Linux + 182)
-#define __NR_getxattr	(__NR_Linux + 183)
-#define __NR_lgetxattr	(__NR_Linux + 184)
-#define __NR_fgetxattr	(__NR_Linux + 185)
-#define __NR_listxattr	(__NR_Linux + 186)
-#define __NR_llistxattr	(__NR_Linux + 187)
-#define __NR_flistxattr	(__NR_Linux + 188)
-#define __NR_removexattr	(__NR_Linux + 189)
-#define __NR_lremovexattr	(__NR_Linux + 190)
-#define __NR_fremovexattr	(__NR_Linux + 191)
-#define __NR_tkill	(__NR_Linux + 192)
-#define __NR_reserved193	(__NR_Linux + 193)
-#define __NR_futex	(__NR_Linux + 194)
-#define __NR_sched_setaffinity	(__NR_Linux + 195)
-#define __NR_sched_getaffinity	(__NR_Linux + 196)
-#define __NR_cacheflush	(__NR_Linux + 197)
-#define __NR_cachectl	(__NR_Linux + 198)
-#define __NR_sysmips	(__NR_Linux + 199)
-#define __NR_io_setup	(__NR_Linux + 200)
-#define __NR_io_destroy	(__NR_Linux + 201)
-#define __NR_io_getevents	(__NR_Linux + 202)
-#define __NR_io_submit	(__NR_Linux + 203)
-#define __NR_io_cancel	(__NR_Linux + 204)
-#define __NR_exit_group	(__NR_Linux + 205)
-#define __NR_lookup_dcookie	(__NR_Linux + 206)
-#define __NR_epoll_create	(__NR_Linux + 207)
-#define __NR_epoll_ctl	(__NR_Linux + 208)
-#define __NR_epoll_wait	(__NR_Linux + 209)
-#define __NR_remap_file_pages	(__NR_Linux + 210)
-#define __NR_rt_sigreturn	(__NR_Linux + 211)
-#define __NR_fcntl64	(__NR_Linux + 212)
-#define __NR_set_tid_address	(__NR_Linux + 213)
-#define __NR_restart_syscall	(__NR_Linux + 214)
-#define __NR_semtimedop	(__NR_Linux + 215)
-#define __NR_fadvise64	(__NR_Linux + 216)
-#define __NR_statfs64	(__NR_Linux + 217)
-#define __NR_fstatfs64	(__NR_Linux + 218)
-#define __NR_sendfile64	(__NR_Linux + 219)
-#define __NR_timer_create	(__NR_Linux + 220)
-#define __NR_timer_settime	(__NR_Linux + 221)
-#define __NR_timer_gettime	(__NR_Linux + 222)
-#define __NR_timer_getoverrun	(__NR_Linux + 223)
-#define __NR_timer_delete	(__NR_Linux + 224)
-#define __NR_clock_settime	(__NR_Linux + 225)
-#define __NR_clock_gettime	(__NR_Linux + 226)
-#define __NR_clock_getres	(__NR_Linux + 227)
-#define __NR_clock_nanosleep	(__NR_Linux + 228)
-#define __NR_tgkill	(__NR_Linux + 229)
-#define __NR_utimes	(__NR_Linux + 230)
-#define __NR_mbind	(__NR_Linux + 231)
-#define __NR_get_mempolicy	(__NR_Linux + 232)
-#define __NR_set_mempolicy	(__NR_Linux + 233)
-#define __NR_mq_open	(__NR_Linux + 234)
-#define __NR_mq_unlink	(__NR_Linux + 235)
-#define __NR_mq_timedsend	(__NR_Linux + 236)
-#define __NR_mq_timedreceive	(__NR_Linux + 237)
-#define __NR_mq_notify	(__NR_Linux + 238)
-#define __NR_mq_getsetattr	(__NR_Linux + 239)
-#define __NR_vserver	(__NR_Linux + 240)
-#define __NR_waitid	(__NR_Linux + 241)
-#define __NR_add_key	(__NR_Linux + 243)
-#define __NR_request_key	(__NR_Linux + 244)
-#define __NR_keyctl	(__NR_Linux + 245)
-#define __NR_set_thread_area	(__NR_Linux + 246)
-#define __NR_inotify_init	(__NR_Linux + 247)
-#define __NR_inotify_add_watch	(__NR_Linux + 248)
-#define __NR_inotify_rm_watch	(__NR_Linux + 249)
-#define __NR_migrate_pages	(__NR_Linux + 250)
-#define __NR_openat	(__NR_Linux + 251)
-#define __NR_mkdirat	(__NR_Linux + 252)
-#define __NR_mknodat	(__NR_Linux + 253)
-#define __NR_fchownat	(__NR_Linux + 254)
-#define __NR_futimesat	(__NR_Linux + 255)
-#define __NR_newfstatat	(__NR_Linux + 256)
-#define __NR_unlinkat	(__NR_Linux + 257)
-#define __NR_renameat	(__NR_Linux + 258)
-#define __NR_linkat	(__NR_Linux + 259)
-#define __NR_symlinkat	(__NR_Linux + 260)
-#define __NR_readlinkat	(__NR_Linux + 261)
-#define __NR_fchmodat	(__NR_Linux + 262)
-#define __NR_faccessat	(__NR_Linux + 263)
-#define __NR_pselect6	(__NR_Linux + 264)
-#define __NR_ppoll	(__NR_Linux + 265)
-#define __NR_unshare	(__NR_Linux + 266)
-#define __NR_splice	(__NR_Linux + 267)
-#define __NR_sync_file_range	(__NR_Linux + 268)
-#define __NR_tee	(__NR_Linux + 269)
-#define __NR_vmsplice	(__NR_Linux + 270)
-#define __NR_move_pages	(__NR_Linux + 271)
-#define __NR_set_robust_list	(__NR_Linux + 272)
-#define __NR_get_robust_list	(__NR_Linux + 273)
-#define __NR_kexec_load	(__NR_Linux + 274)
-#define __NR_getcpu	(__NR_Linux + 275)
-#define __NR_epoll_pwait	(__NR_Linux + 276)
-#define __NR_ioprio_set	(__NR_Linux + 277)
-#define __NR_ioprio_get	(__NR_Linux + 278)
-#define __NR_utimensat	(__NR_Linux + 279)
-#define __NR_signalfd	(__NR_Linux + 280)
-#define __NR_timerfd	(__NR_Linux + 281)
-#define __NR_eventfd	(__NR_Linux + 282)
-#define __NR_fallocate	(__NR_Linux + 283)
-#define __NR_timerfd_create	(__NR_Linux + 284)
-#define __NR_timerfd_gettime	(__NR_Linux + 285)
-#define __NR_timerfd_settime	(__NR_Linux + 286)
-#define __NR_signalfd4	(__NR_Linux + 287)
-#define __NR_eventfd2	(__NR_Linux + 288)
-#define __NR_epoll_create1	(__NR_Linux + 289)
-#define __NR_dup3	(__NR_Linux + 290)
-#define __NR_pipe2	(__NR_Linux + 291)
-#define __NR_inotify_init1	(__NR_Linux + 292)
-#define __NR_preadv	(__NR_Linux + 293)
-#define __NR_pwritev	(__NR_Linux + 294)
-#define __NR_rt_tgsigqueueinfo	(__NR_Linux + 295)
-#define __NR_perf_event_open	(__NR_Linux + 296)
-#define __NR_accept4	(__NR_Linux + 297)
-#define __NR_recvmmsg	(__NR_Linux + 298)
-#define __NR_getdents64	(__NR_Linux + 299)
-#define __NR_fanotify_init	(__NR_Linux + 300)
-#define __NR_fanotify_mark	(__NR_Linux + 301)
-#define __NR_prlimit64	(__NR_Linux + 302)
-#define __NR_name_to_handle_at	(__NR_Linux + 303)
-#define __NR_open_by_handle_at	(__NR_Linux + 304)
-#define __NR_clock_adjtime	(__NR_Linux + 305)
-#define __NR_syncfs	(__NR_Linux + 306)
-#define __NR_sendmmsg	(__NR_Linux + 307)
-#define __NR_setns	(__NR_Linux + 308)
-#define __NR_process_vm_readv	(__NR_Linux + 309)
-#define __NR_process_vm_writev	(__NR_Linux + 310)
-#define __NR_kcmp	(__NR_Linux + 311)
-#define __NR_finit_module	(__NR_Linux + 312)
-#define __NR_sched_setattr	(__NR_Linux + 313)
-#define __NR_sched_getattr	(__NR_Linux + 314)
-#define __NR_renameat2	(__NR_Linux + 315)
-#define __NR_seccomp	(__NR_Linux + 316)
-#define __NR_getrandom	(__NR_Linux + 317)
-#define __NR_memfd_create	(__NR_Linux + 318)
-#define __NR_bpf	(__NR_Linux + 319)
-#define __NR_execveat	(__NR_Linux + 320)
-#define __NR_userfaultfd	(__NR_Linux + 321)
-#define __NR_membarrier	(__NR_Linux + 322)
-#define __NR_mlock2	(__NR_Linux + 323)
-#define __NR_copy_file_range	(__NR_Linux + 324)
-#define __NR_preadv2	(__NR_Linux + 325)
-#define __NR_pwritev2	(__NR_Linux + 326)
-#define __NR_pkey_mprotect	(__NR_Linux + 327)
-#define __NR_pkey_alloc	(__NR_Linux + 328)
-#define __NR_pkey_free	(__NR_Linux + 329)
-#define __NR_statx	(__NR_Linux + 330)
-#define __NR_rseq	(__NR_Linux + 331)
-#define __NR_io_pgetevents	(__NR_Linux + 332)
-#define __NR_clock_gettime64	(__NR_Linux + 403)
-#define __NR_clock_settime64	(__NR_Linux + 404)
-#define __NR_clock_adjtime64	(__NR_Linux + 405)
-#define __NR_clock_getres_time64	(__NR_Linux + 406)
-#define __NR_clock_nanosleep_time64	(__NR_Linux + 407)
-#define __NR_timer_gettime64	(__NR_Linux + 408)
-#define __NR_timer_settime64	(__NR_Linux + 409)
-#define __NR_timerfd_gettime64	(__NR_Linux + 410)
-#define __NR_timerfd_settime64	(__NR_Linux + 411)
-#define __NR_utimensat_time64	(__NR_Linux + 412)
-#define __NR_pselect6_time64	(__NR_Linux + 413)
-#define __NR_ppoll_time64	(__NR_Linux + 414)
-#define __NR_io_pgetevents_time64	(__NR_Linux + 416)
-#define __NR_recvmmsg_time64	(__NR_Linux + 417)
-#define __NR_mq_timedsend_time64	(__NR_Linux + 418)
-#define __NR_mq_timedreceive_time64	(__NR_Linux + 419)
-#define __NR_semtimedop_time64	(__NR_Linux + 420)
-#define __NR_rt_sigtimedwait_time64	(__NR_Linux + 421)
-#define __NR_futex_time64	(__NR_Linux + 422)
-#define __NR_sched_rr_get_interval_time64	(__NR_Linux + 423)
-#define __NR_pidfd_send_signal	(__NR_Linux + 424)
-#define __NR_io_uring_setup	(__NR_Linux + 425)
-#define __NR_io_uring_enter	(__NR_Linux + 426)
-#define __NR_io_uring_register	(__NR_Linux + 427)
-#define __NR_open_tree	(__NR_Linux + 428)
-#define __NR_move_mount	(__NR_Linux + 429)
-#define __NR_fsopen	(__NR_Linux + 430)
-#define __NR_fsconfig	(__NR_Linux + 431)
-#define __NR_fsmount	(__NR_Linux + 432)
-#define __NR_fspick	(__NR_Linux + 433)
-#define __NR_pidfd_open	(__NR_Linux + 434)
-#define __NR_clone3	(__NR_Linux + 435)
-#define __NR_close_range	(__NR_Linux + 436)
-#define __NR_openat2	(__NR_Linux + 437)
-#define __NR_pidfd_getfd	(__NR_Linux + 438)
-#define __NR_faccessat2	(__NR_Linux + 439)
-#define __NR_process_madvise	(__NR_Linux + 440)
-#define __NR_epoll_pwait2	(__NR_Linux + 441)
+#define __NR_read (__NR_Linux + 0)
+#define __NR_write (__NR_Linux + 1)
+#define __NR_open (__NR_Linux + 2)
+#define __NR_close (__NR_Linux + 3)
+#define __NR_stat (__NR_Linux + 4)
+#define __NR_fstat (__NR_Linux + 5)
+#define __NR_lstat (__NR_Linux + 6)
+#define __NR_poll (__NR_Linux + 7)
+#define __NR_lseek (__NR_Linux + 8)
+#define __NR_mmap (__NR_Linux + 9)
+#define __NR_mprotect (__NR_Linux + 10)
+#define __NR_munmap (__NR_Linux + 11)
+#define __NR_brk (__NR_Linux + 12)
+#define __NR_rt_sigaction (__NR_Linux + 13)
+#define __NR_rt_sigprocmask (__NR_Linux + 14)
+#define __NR_ioctl (__NR_Linux + 15)
+#define __NR_pread64 (__NR_Linux + 16)
+#define __NR_pwrite64 (__NR_Linux + 17)
+#define __NR_readv (__NR_Linux + 18)
+#define __NR_writev (__NR_Linux + 19)
+#define __NR_access (__NR_Linux + 20)
+#define __NR_pipe (__NR_Linux + 21)
+#define __NR__newselect (__NR_Linux + 22)
+#define __NR_sched_yield (__NR_Linux + 23)
+#define __NR_mremap (__NR_Linux + 24)
+#define __NR_msync (__NR_Linux + 25)
+#define __NR_mincore (__NR_Linux + 26)
+#define __NR_madvise (__NR_Linux + 27)
+#define __NR_shmget (__NR_Linux + 28)
+#define __NR_shmat (__NR_Linux + 29)
+#define __NR_shmctl (__NR_Linux + 30)
+#define __NR_dup (__NR_Linux + 31)
+#define __NR_dup2 (__NR_Linux + 32)
+#define __NR_pause (__NR_Linux + 33)
+#define __NR_nanosleep (__NR_Linux + 34)
+#define __NR_getitimer (__NR_Linux + 35)
+#define __NR_setitimer (__NR_Linux + 36)
+#define __NR_alarm (__NR_Linux + 37)
+#define __NR_getpid (__NR_Linux + 38)
+#define __NR_sendfile (__NR_Linux + 39)
+#define __NR_socket (__NR_Linux + 40)
+#define __NR_connect (__NR_Linux + 41)
+#define __NR_accept (__NR_Linux + 42)
+#define __NR_sendto (__NR_Linux + 43)
+#define __NR_recvfrom (__NR_Linux + 44)
+#define __NR_sendmsg (__NR_Linux + 45)
+#define __NR_recvmsg (__NR_Linux + 46)
+#define __NR_shutdown (__NR_Linux + 47)
+#define __NR_bind (__NR_Linux + 48)
+#define __NR_listen (__NR_Linux + 49)
+#define __NR_getsockname (__NR_Linux + 50)
+#define __NR_getpeername (__NR_Linux + 51)
+#define __NR_socketpair (__NR_Linux + 52)
+#define __NR_setsockopt (__NR_Linux + 53)
+#define __NR_getsockopt (__NR_Linux + 54)
+#define __NR_clone (__NR_Linux + 55)
+#define __NR_fork (__NR_Linux + 56)
+#define __NR_execve (__NR_Linux + 57)
+#define __NR_exit (__NR_Linux + 58)
+#define __NR_wait4 (__NR_Linux + 59)
+#define __NR_kill (__NR_Linux + 60)
+#define __NR_uname (__NR_Linux + 61)
+#define __NR_semget (__NR_Linux + 62)
+#define __NR_semop (__NR_Linux + 63)
+#define __NR_semctl (__NR_Linux + 64)
+#define __NR_shmdt (__NR_Linux + 65)
+#define __NR_msgget (__NR_Linux + 66)
+#define __NR_msgsnd (__NR_Linux + 67)
+#define __NR_msgrcv (__NR_Linux + 68)
+#define __NR_msgctl (__NR_Linux + 69)
+#define __NR_fcntl (__NR_Linux + 70)
+#define __NR_flock (__NR_Linux + 71)
+#define __NR_fsync (__NR_Linux + 72)
+#define __NR_fdatasync (__NR_Linux + 73)
+#define __NR_truncate (__NR_Linux + 74)
+#define __NR_ftruncate (__NR_Linux + 75)
+#define __NR_getdents (__NR_Linux + 76)
+#define __NR_getcwd (__NR_Linux + 77)
+#define __NR_chdir (__NR_Linux + 78)
+#define __NR_fchdir (__NR_Linux + 79)
+#define __NR_rename (__NR_Linux + 80)
+#define __NR_mkdir (__NR_Linux + 81)
+#define __NR_rmdir (__NR_Linux + 82)
+#define __NR_creat (__NR_Linux + 83)
+#define __NR_link (__NR_Linux + 84)
+#define __NR_unlink (__NR_Linux + 85)
+#define __NR_symlink (__NR_Linux + 86)
+#define __NR_readlink (__NR_Linux + 87)
+#define __NR_chmod (__NR_Linux + 88)
+#define __NR_fchmod (__NR_Linux + 89)
+#define __NR_chown (__NR_Linux + 90)
+#define __NR_fchown (__NR_Linux + 91)
+#define __NR_lchown (__NR_Linux + 92)
+#define __NR_umask (__NR_Linux + 93)
+#define __NR_gettimeofday (__NR_Linux + 94)
+#define __NR_getrlimit (__NR_Linux + 95)
+#define __NR_getrusage (__NR_Linux + 96)
+#define __NR_sysinfo (__NR_Linux + 97)
+#define __NR_times (__NR_Linux + 98)
+#define __NR_ptrace (__NR_Linux + 99)
+#define __NR_getuid (__NR_Linux + 100)
+#define __NR_syslog (__NR_Linux + 101)
+#define __NR_getgid (__NR_Linux + 102)
+#define __NR_setuid (__NR_Linux + 103)
+#define __NR_setgid (__NR_Linux + 104)
+#define __NR_geteuid (__NR_Linux + 105)
+#define __NR_getegid (__NR_Linux + 106)
+#define __NR_setpgid (__NR_Linux + 107)
+#define __NR_getppid (__NR_Linux + 108)
+#define __NR_getpgrp (__NR_Linux + 109)
+#define __NR_setsid (__NR_Linux + 110)
+#define __NR_setreuid (__NR_Linux + 111)
+#define __NR_setregid (__NR_Linux + 112)
+#define __NR_getgroups (__NR_Linux + 113)
+#define __NR_setgroups (__NR_Linux + 114)
+#define __NR_setresuid (__NR_Linux + 115)
+#define __NR_getresuid (__NR_Linux + 116)
+#define __NR_setresgid (__NR_Linux + 117)
+#define __NR_getresgid (__NR_Linux + 118)
+#define __NR_getpgid (__NR_Linux + 119)
+#define __NR_setfsuid (__NR_Linux + 120)
+#define __NR_setfsgid (__NR_Linux + 121)
+#define __NR_getsid (__NR_Linux + 122)
+#define __NR_capget (__NR_Linux + 123)
+#define __NR_capset (__NR_Linux + 124)
+#define __NR_rt_sigpending (__NR_Linux + 125)
+#define __NR_rt_sigtimedwait (__NR_Linux + 126)
+#define __NR_rt_sigqueueinfo (__NR_Linux + 127)
+#define __NR_rt_sigsuspend (__NR_Linux + 128)
+#define __NR_sigaltstack (__NR_Linux + 129)
+#define __NR_utime (__NR_Linux + 130)
+#define __NR_mknod (__NR_Linux + 131)
+#define __NR_personality (__NR_Linux + 132)
+#define __NR_ustat (__NR_Linux + 133)
+#define __NR_statfs (__NR_Linux + 134)
+#define __NR_fstatfs (__NR_Linux + 135)
+#define __NR_sysfs (__NR_Linux + 136)
+#define __NR_getpriority (__NR_Linux + 137)
+#define __NR_setpriority (__NR_Linux + 138)
+#define __NR_sched_setparam (__NR_Linux + 139)
+#define __NR_sched_getparam (__NR_Linux + 140)
+#define __NR_sched_setscheduler (__NR_Linux + 141)
+#define __NR_sched_getscheduler (__NR_Linux + 142)
+#define __NR_sched_get_priority_max (__NR_Linux + 143)
+#define __NR_sched_get_priority_min (__NR_Linux + 144)
+#define __NR_sched_rr_get_interval (__NR_Linux + 145)
+#define __NR_mlock (__NR_Linux + 146)
+#define __NR_munlock (__NR_Linux + 147)
+#define __NR_mlockall (__NR_Linux + 148)
+#define __NR_munlockall (__NR_Linux + 149)
+#define __NR_vhangup (__NR_Linux + 150)
+#define __NR_pivot_root (__NR_Linux + 151)
+#define __NR__sysctl (__NR_Linux + 152)
+#define __NR_prctl (__NR_Linux + 153)
+#define __NR_adjtimex (__NR_Linux + 154)
+#define __NR_setrlimit (__NR_Linux + 155)
+#define __NR_chroot (__NR_Linux + 156)
+#define __NR_sync (__NR_Linux + 157)
+#define __NR_acct (__NR_Linux + 158)
+#define __NR_settimeofday (__NR_Linux + 159)
+#define __NR_mount (__NR_Linux + 160)
+#define __NR_umount2 (__NR_Linux + 161)
+#define __NR_swapon (__NR_Linux + 162)
+#define __NR_swapoff (__NR_Linux + 163)
+#define __NR_reboot (__NR_Linux + 164)
+#define __NR_sethostname (__NR_Linux + 165)
+#define __NR_setdomainname (__NR_Linux + 166)
+#define __NR_create_module (__NR_Linux + 167)
+#define __NR_init_module (__NR_Linux + 168)
+#define __NR_delete_module (__NR_Linux + 169)
+#define __NR_get_kernel_syms (__NR_Linux + 170)
+#define __NR_query_module (__NR_Linux + 171)
+#define __NR_quotactl (__NR_Linux + 172)
+#define __NR_nfsservctl (__NR_Linux + 173)
+#define __NR_getpmsg (__NR_Linux + 174)
+#define __NR_putpmsg (__NR_Linux + 175)
+#define __NR_afs_syscall (__NR_Linux + 176)
+#define __NR_reserved177 (__NR_Linux + 177)
+#define __NR_gettid (__NR_Linux + 178)
+#define __NR_readahead (__NR_Linux + 179)
+#define __NR_setxattr (__NR_Linux + 180)
+#define __NR_lsetxattr (__NR_Linux + 181)
+#define __NR_fsetxattr (__NR_Linux + 182)
+#define __NR_getxattr (__NR_Linux + 183)
+#define __NR_lgetxattr (__NR_Linux + 184)
+#define __NR_fgetxattr (__NR_Linux + 185)
+#define __NR_listxattr (__NR_Linux + 186)
+#define __NR_llistxattr (__NR_Linux + 187)
+#define __NR_flistxattr (__NR_Linux + 188)
+#define __NR_removexattr (__NR_Linux + 189)
+#define __NR_lremovexattr (__NR_Linux + 190)
+#define __NR_fremovexattr (__NR_Linux + 191)
+#define __NR_tkill (__NR_Linux + 192)
+#define __NR_reserved193 (__NR_Linux + 193)
+#define __NR_futex (__NR_Linux + 194)
+#define __NR_sched_setaffinity (__NR_Linux + 195)
+#define __NR_sched_getaffinity (__NR_Linux + 196)
+#define __NR_cacheflush (__NR_Linux + 197)
+#define __NR_cachectl (__NR_Linux + 198)
+#define __NR_sysmips (__NR_Linux + 199)
+#define __NR_io_setup (__NR_Linux + 200)
+#define __NR_io_destroy (__NR_Linux + 201)
+#define __NR_io_getevents (__NR_Linux + 202)
+#define __NR_io_submit (__NR_Linux + 203)
+#define __NR_io_cancel (__NR_Linux + 204)
+#define __NR_exit_group (__NR_Linux + 205)
+#define __NR_lookup_dcookie (__NR_Linux + 206)
+#define __NR_epoll_create (__NR_Linux + 207)
+#define __NR_epoll_ctl (__NR_Linux + 208)
+#define __NR_epoll_wait (__NR_Linux + 209)
+#define __NR_remap_file_pages (__NR_Linux + 210)
+#define __NR_rt_sigreturn (__NR_Linux + 211)
+#define __NR_fcntl64 (__NR_Linux + 212)
+#define __NR_set_tid_address (__NR_Linux + 213)
+#define __NR_restart_syscall (__NR_Linux + 214)
+#define __NR_semtimedop (__NR_Linux + 215)
+#define __NR_fadvise64 (__NR_Linux + 216)
+#define __NR_statfs64 (__NR_Linux + 217)
+#define __NR_fstatfs64 (__NR_Linux + 218)
+#define __NR_sendfile64 (__NR_Linux + 219)
+#define __NR_timer_create (__NR_Linux + 220)
+#define __NR_timer_settime (__NR_Linux + 221)
+#define __NR_timer_gettime (__NR_Linux + 222)
+#define __NR_timer_getoverrun (__NR_Linux + 223)
+#define __NR_timer_delete (__NR_Linux + 224)
+#define __NR_clock_settime (__NR_Linux + 225)
+#define __NR_clock_gettime (__NR_Linux + 226)
+#define __NR_clock_getres (__NR_Linux + 227)
+#define __NR_clock_nanosleep (__NR_Linux + 228)
+#define __NR_tgkill (__NR_Linux + 229)
+#define __NR_utimes (__NR_Linux + 230)
+#define __NR_mbind (__NR_Linux + 231)
+#define __NR_get_mempolicy (__NR_Linux + 232)
+#define __NR_set_mempolicy (__NR_Linux + 233)
+#define __NR_mq_open (__NR_Linux + 234)
+#define __NR_mq_unlink (__NR_Linux + 235)
+#define __NR_mq_timedsend (__NR_Linux + 236)
+#define __NR_mq_timedreceive (__NR_Linux + 237)
+#define __NR_mq_notify (__NR_Linux + 238)
+#define __NR_mq_getsetattr (__NR_Linux + 239)
+#define __NR_vserver (__NR_Linux + 240)
+#define __NR_waitid (__NR_Linux + 241)
+#define __NR_add_key (__NR_Linux + 243)
+#define __NR_request_key (__NR_Linux + 244)
+#define __NR_keyctl (__NR_Linux + 245)
+#define __NR_set_thread_area (__NR_Linux + 246)
+#define __NR_inotify_init (__NR_Linux + 247)
+#define __NR_inotify_add_watch (__NR_Linux + 248)
+#define __NR_inotify_rm_watch (__NR_Linux + 249)
+#define __NR_migrate_pages (__NR_Linux + 250)
+#define __NR_openat (__NR_Linux + 251)
+#define __NR_mkdirat (__NR_Linux + 252)
+#define __NR_mknodat (__NR_Linux + 253)
+#define __NR_fchownat (__NR_Linux + 254)
+#define __NR_futimesat (__NR_Linux + 255)
+#define __NR_newfstatat (__NR_Linux + 256)
+#define __NR_unlinkat (__NR_Linux + 257)
+#define __NR_renameat (__NR_Linux + 258)
+#define __NR_linkat (__NR_Linux + 259)
+#define __NR_symlinkat (__NR_Linux + 260)
+#define __NR_readlinkat (__NR_Linux + 261)
+#define __NR_fchmodat (__NR_Linux + 262)
+#define __NR_faccessat (__NR_Linux + 263)
+#define __NR_pselect6 (__NR_Linux + 264)
+#define __NR_ppoll (__NR_Linux + 265)
+#define __NR_unshare (__NR_Linux + 266)
+#define __NR_splice (__NR_Linux + 267)
+#define __NR_sync_file_range (__NR_Linux + 268)
+#define __NR_tee (__NR_Linux + 269)
+#define __NR_vmsplice (__NR_Linux + 270)
+#define __NR_move_pages (__NR_Linux + 271)
+#define __NR_set_robust_list (__NR_Linux + 272)
+#define __NR_get_robust_list (__NR_Linux + 273)
+#define __NR_kexec_load (__NR_Linux + 274)
+#define __NR_getcpu (__NR_Linux + 275)
+#define __NR_epoll_pwait (__NR_Linux + 276)
+#define __NR_ioprio_set (__NR_Linux + 277)
+#define __NR_ioprio_get (__NR_Linux + 278)
+#define __NR_utimensat (__NR_Linux + 279)
+#define __NR_signalfd (__NR_Linux + 280)
+#define __NR_timerfd (__NR_Linux + 281)
+#define __NR_eventfd (__NR_Linux + 282)
+#define __NR_fallocate (__NR_Linux + 283)
+#define __NR_timerfd_create (__NR_Linux + 284)
+#define __NR_timerfd_gettime (__NR_Linux + 285)
+#define __NR_timerfd_settime (__NR_Linux + 286)
+#define __NR_signalfd4 (__NR_Linux + 287)
+#define __NR_eventfd2 (__NR_Linux + 288)
+#define __NR_epoll_create1 (__NR_Linux + 289)
+#define __NR_dup3 (__NR_Linux + 290)
+#define __NR_pipe2 (__NR_Linux + 291)
+#define __NR_inotify_init1 (__NR_Linux + 292)
+#define __NR_preadv (__NR_Linux + 293)
+#define __NR_pwritev (__NR_Linux + 294)
+#define __NR_rt_tgsigqueueinfo (__NR_Linux + 295)
+#define __NR_perf_event_open (__NR_Linux + 296)
+#define __NR_accept4 (__NR_Linux + 297)
+#define __NR_recvmmsg (__NR_Linux + 298)
+#define __NR_getdents64 (__NR_Linux + 299)
+#define __NR_fanotify_init (__NR_Linux + 300)
+#define __NR_fanotify_mark (__NR_Linux + 301)
+#define __NR_prlimit64 (__NR_Linux + 302)
+#define __NR_name_to_handle_at (__NR_Linux + 303)
+#define __NR_open_by_handle_at (__NR_Linux + 304)
+#define __NR_clock_adjtime (__NR_Linux + 305)
+#define __NR_syncfs (__NR_Linux + 306)
+#define __NR_sendmmsg (__NR_Linux + 307)
+#define __NR_setns (__NR_Linux + 308)
+#define __NR_process_vm_readv (__NR_Linux + 309)
+#define __NR_process_vm_writev (__NR_Linux + 310)
+#define __NR_kcmp (__NR_Linux + 311)
+#define __NR_finit_module (__NR_Linux + 312)
+#define __NR_sched_setattr (__NR_Linux + 313)
+#define __NR_sched_getattr (__NR_Linux + 314)
+#define __NR_renameat2 (__NR_Linux + 315)
+#define __NR_seccomp (__NR_Linux + 316)
+#define __NR_getrandom (__NR_Linux + 317)
+#define __NR_memfd_create (__NR_Linux + 318)
+#define __NR_bpf (__NR_Linux + 319)
+#define __NR_execveat (__NR_Linux + 320)
+#define __NR_userfaultfd (__NR_Linux + 321)
+#define __NR_membarrier (__NR_Linux + 322)
+#define __NR_mlock2 (__NR_Linux + 323)
+#define __NR_copy_file_range (__NR_Linux + 324)
+#define __NR_preadv2 (__NR_Linux + 325)
+#define __NR_pwritev2 (__NR_Linux + 326)
+#define __NR_pkey_mprotect (__NR_Linux + 327)
+#define __NR_pkey_alloc (__NR_Linux + 328)
+#define __NR_pkey_free (__NR_Linux + 329)
+#define __NR_statx (__NR_Linux + 330)
+#define __NR_rseq (__NR_Linux + 331)
+#define __NR_io_pgetevents (__NR_Linux + 332)
+#define __NR_clock_gettime64 (__NR_Linux + 403)
+#define __NR_clock_settime64 (__NR_Linux + 404)
+#define __NR_clock_adjtime64 (__NR_Linux + 405)
+#define __NR_clock_getres_time64 (__NR_Linux + 406)
+#define __NR_clock_nanosleep_time64 (__NR_Linux + 407)
+#define __NR_timer_gettime64 (__NR_Linux + 408)
+#define __NR_timer_settime64 (__NR_Linux + 409)
+#define __NR_timerfd_gettime64 (__NR_Linux + 410)
+#define __NR_timerfd_settime64 (__NR_Linux + 411)
+#define __NR_utimensat_time64 (__NR_Linux + 412)
+#define __NR_pselect6_time64 (__NR_Linux + 413)
+#define __NR_ppoll_time64 (__NR_Linux + 414)
+#define __NR_io_pgetevents_time64 (__NR_Linux + 416)
+#define __NR_recvmmsg_time64 (__NR_Linux + 417)
+#define __NR_mq_timedsend_time64 (__NR_Linux + 418)
+#define __NR_mq_timedreceive_time64 (__NR_Linux + 419)
+#define __NR_semtimedop_time64 (__NR_Linux + 420)
+#define __NR_rt_sigtimedwait_time64 (__NR_Linux + 421)
+#define __NR_futex_time64 (__NR_Linux + 422)
+#define __NR_sched_rr_get_interval_time64 (__NR_Linux + 423)
+#define __NR_pidfd_send_signal (__NR_Linux + 424)
+#define __NR_io_uring_setup (__NR_Linux + 425)
+#define __NR_io_uring_enter (__NR_Linux + 426)
+#define __NR_io_uring_register (__NR_Linux + 427)
+#define __NR_open_tree (__NR_Linux + 428)
+#define __NR_move_mount (__NR_Linux + 429)
+#define __NR_fsopen (__NR_Linux + 430)
+#define __NR_fsconfig (__NR_Linux + 431)
+#define __NR_fsmount (__NR_Linux + 432)
+#define __NR_fspick (__NR_Linux + 433)
+#define __NR_pidfd_open (__NR_Linux + 434)
+#define __NR_clone3 (__NR_Linux + 435)
+#define __NR_close_range (__NR_Linux + 436)
+#define __NR_openat2 (__NR_Linux + 437)
+#define __NR_pidfd_getfd (__NR_Linux + 438)
+#define __NR_faccessat2 (__NR_Linux + 439)
+#define __NR_process_madvise (__NR_Linux + 440)
+#define __NR_epoll_pwait2 (__NR_Linux + 441)
+#define __NR_mount_setattr (__NR_Linux + 442)
+#define __NR_landlock_create_ruleset (__NR_Linux + 444)
+#define __NR_landlock_add_rule (__NR_Linux + 445)
+#define __NR_landlock_restrict_self (__NR_Linux + 446)
 
-
-#endif /* _ASM_MIPS_UNISTD_N32_H */
+#endif /* _ASM_UNISTD_N32_H */
diff --git a/linux-headers/asm-mips/unistd_n64.h b/linux-headers/asm-mips/unistd_n64.h
index 683558a7f8..0996001802 100644
--- a/linux-headers/asm-mips/unistd_n64.h
+++ b/linux-headers/asm-mips/unistd_n64.h
@@ -1,352 +1,355 @@
-#ifndef _ASM_MIPS_UNISTD_N64_H
-#define _ASM_MIPS_UNISTD_N64_H
+#ifndef _ASM_UNISTD_N64_H
+#define _ASM_UNISTD_N64_H
 
-#define __NR_read	(__NR_Linux + 0)
-#define __NR_write	(__NR_Linux + 1)
-#define __NR_open	(__NR_Linux + 2)
-#define __NR_close	(__NR_Linux + 3)
-#define __NR_stat	(__NR_Linux + 4)
-#define __NR_fstat	(__NR_Linux + 5)
-#define __NR_lstat	(__NR_Linux + 6)
-#define __NR_poll	(__NR_Linux + 7)
-#define __NR_lseek	(__NR_Linux + 8)
-#define __NR_mmap	(__NR_Linux + 9)
-#define __NR_mprotect	(__NR_Linux + 10)
-#define __NR_munmap	(__NR_Linux + 11)
-#define __NR_brk	(__NR_Linux + 12)
-#define __NR_rt_sigaction	(__NR_Linux + 13)
-#define __NR_rt_sigprocmask	(__NR_Linux + 14)
-#define __NR_ioctl	(__NR_Linux + 15)
-#define __NR_pread64	(__NR_Linux + 16)
-#define __NR_pwrite64	(__NR_Linux + 17)
-#define __NR_readv	(__NR_Linux + 18)
-#define __NR_writev	(__NR_Linux + 19)
-#define __NR_access	(__NR_Linux + 20)
-#define __NR_pipe	(__NR_Linux + 21)
-#define __NR__newselect	(__NR_Linux + 22)
-#define __NR_sched_yield	(__NR_Linux + 23)
-#define __NR_mremap	(__NR_Linux + 24)
-#define __NR_msync	(__NR_Linux + 25)
-#define __NR_mincore	(__NR_Linux + 26)
-#define __NR_madvise	(__NR_Linux + 27)
-#define __NR_shmget	(__NR_Linux + 28)
-#define __NR_shmat	(__NR_Linux + 29)
-#define __NR_shmctl	(__NR_Linux + 30)
-#define __NR_dup	(__NR_Linux + 31)
-#define __NR_dup2	(__NR_Linux + 32)
-#define __NR_pause	(__NR_Linux + 33)
-#define __NR_nanosleep	(__NR_Linux + 34)
-#define __NR_getitimer	(__NR_Linux + 35)
-#define __NR_setitimer	(__NR_Linux + 36)
-#define __NR_alarm	(__NR_Linux + 37)
-#define __NR_getpid	(__NR_Linux + 38)
-#define __NR_sendfile	(__NR_Linux + 39)
-#define __NR_socket	(__NR_Linux + 40)
-#define __NR_connect	(__NR_Linux + 41)
-#define __NR_accept	(__NR_Linux + 42)
-#define __NR_sendto	(__NR_Linux + 43)
-#define __NR_recvfrom	(__NR_Linux + 44)
-#define __NR_sendmsg	(__NR_Linux + 45)
-#define __NR_recvmsg	(__NR_Linux + 46)
-#define __NR_shutdown	(__NR_Linux + 47)
-#define __NR_bind	(__NR_Linux + 48)
-#define __NR_listen	(__NR_Linux + 49)
-#define __NR_getsockname	(__NR_Linux + 50)
-#define __NR_getpeername	(__NR_Linux + 51)
-#define __NR_socketpair	(__NR_Linux + 52)
-#define __NR_setsockopt	(__NR_Linux + 53)
-#define __NR_getsockopt	(__NR_Linux + 54)
-#define __NR_clone	(__NR_Linux + 55)
-#define __NR_fork	(__NR_Linux + 56)
-#define __NR_execve	(__NR_Linux + 57)
-#define __NR_exit	(__NR_Linux + 58)
-#define __NR_wait4	(__NR_Linux + 59)
-#define __NR_kill	(__NR_Linux + 60)
-#define __NR_uname	(__NR_Linux + 61)
-#define __NR_semget	(__NR_Linux + 62)
-#define __NR_semop	(__NR_Linux + 63)
-#define __NR_semctl	(__NR_Linux + 64)
-#define __NR_shmdt	(__NR_Linux + 65)
-#define __NR_msgget	(__NR_Linux + 66)
-#define __NR_msgsnd	(__NR_Linux + 67)
-#define __NR_msgrcv	(__NR_Linux + 68)
-#define __NR_msgctl	(__NR_Linux + 69)
-#define __NR_fcntl	(__NR_Linux + 70)
-#define __NR_flock	(__NR_Linux + 71)
-#define __NR_fsync	(__NR_Linux + 72)
-#define __NR_fdatasync	(__NR_Linux + 73)
-#define __NR_truncate	(__NR_Linux + 74)
-#define __NR_ftruncate	(__NR_Linux + 75)
-#define __NR_getdents	(__NR_Linux + 76)
-#define __NR_getcwd	(__NR_Linux + 77)
-#define __NR_chdir	(__NR_Linux + 78)
-#define __NR_fchdir	(__NR_Linux + 79)
-#define __NR_rename	(__NR_Linux + 80)
-#define __NR_mkdir	(__NR_Linux + 81)
-#define __NR_rmdir	(__NR_Linux + 82)
-#define __NR_creat	(__NR_Linux + 83)
-#define __NR_link	(__NR_Linux + 84)
-#define __NR_unlink	(__NR_Linux + 85)
-#define __NR_symlink	(__NR_Linux + 86)
-#define __NR_readlink	(__NR_Linux + 87)
-#define __NR_chmod	(__NR_Linux + 88)
-#define __NR_fchmod	(__NR_Linux + 89)
-#define __NR_chown	(__NR_Linux + 90)
-#define __NR_fchown	(__NR_Linux + 91)
-#define __NR_lchown	(__NR_Linux + 92)
-#define __NR_umask	(__NR_Linux + 93)
-#define __NR_gettimeofday	(__NR_Linux + 94)
-#define __NR_getrlimit	(__NR_Linux + 95)
-#define __NR_getrusage	(__NR_Linux + 96)
-#define __NR_sysinfo	(__NR_Linux + 97)
-#define __NR_times	(__NR_Linux + 98)
-#define __NR_ptrace	(__NR_Linux + 99)
-#define __NR_getuid	(__NR_Linux + 100)
-#define __NR_syslog	(__NR_Linux + 101)
-#define __NR_getgid	(__NR_Linux + 102)
-#define __NR_setuid	(__NR_Linux + 103)
-#define __NR_setgid	(__NR_Linux + 104)
-#define __NR_geteuid	(__NR_Linux + 105)
-#define __NR_getegid	(__NR_Linux + 106)
-#define __NR_setpgid	(__NR_Linux + 107)
-#define __NR_getppid	(__NR_Linux + 108)
-#define __NR_getpgrp	(__NR_Linux + 109)
-#define __NR_setsid	(__NR_Linux + 110)
-#define __NR_setreuid	(__NR_Linux + 111)
-#define __NR_setregid	(__NR_Linux + 112)
-#define __NR_getgroups	(__NR_Linux + 113)
-#define __NR_setgroups	(__NR_Linux + 114)
-#define __NR_setresuid	(__NR_Linux + 115)
-#define __NR_getresuid	(__NR_Linux + 116)
-#define __NR_setresgid	(__NR_Linux + 117)
-#define __NR_getresgid	(__NR_Linux + 118)
-#define __NR_getpgid	(__NR_Linux + 119)
-#define __NR_setfsuid	(__NR_Linux + 120)
-#define __NR_setfsgid	(__NR_Linux + 121)
-#define __NR_getsid	(__NR_Linux + 122)
-#define __NR_capget	(__NR_Linux + 123)
-#define __NR_capset	(__NR_Linux + 124)
-#define __NR_rt_sigpending	(__NR_Linux + 125)
-#define __NR_rt_sigtimedwait	(__NR_Linux + 126)
-#define __NR_rt_sigqueueinfo	(__NR_Linux + 127)
-#define __NR_rt_sigsuspend	(__NR_Linux + 128)
-#define __NR_sigaltstack	(__NR_Linux + 129)
-#define __NR_utime	(__NR_Linux + 130)
-#define __NR_mknod	(__NR_Linux + 131)
-#define __NR_personality	(__NR_Linux + 132)
-#define __NR_ustat	(__NR_Linux + 133)
-#define __NR_statfs	(__NR_Linux + 134)
-#define __NR_fstatfs	(__NR_Linux + 135)
-#define __NR_sysfs	(__NR_Linux + 136)
-#define __NR_getpriority	(__NR_Linux + 137)
-#define __NR_setpriority	(__NR_Linux + 138)
-#define __NR_sched_setparam	(__NR_Linux + 139)
-#define __NR_sched_getparam	(__NR_Linux + 140)
-#define __NR_sched_setscheduler	(__NR_Linux + 141)
-#define __NR_sched_getscheduler	(__NR_Linux + 142)
-#define __NR_sched_get_priority_max	(__NR_Linux + 143)
-#define __NR_sched_get_priority_min	(__NR_Linux + 144)
-#define __NR_sched_rr_get_interval	(__NR_Linux + 145)
-#define __NR_mlock	(__NR_Linux + 146)
-#define __NR_munlock	(__NR_Linux + 147)
-#define __NR_mlockall	(__NR_Linux + 148)
-#define __NR_munlockall	(__NR_Linux + 149)
-#define __NR_vhangup	(__NR_Linux + 150)
-#define __NR_pivot_root	(__NR_Linux + 151)
-#define __NR__sysctl	(__NR_Linux + 152)
-#define __NR_prctl	(__NR_Linux + 153)
-#define __NR_adjtimex	(__NR_Linux + 154)
-#define __NR_setrlimit	(__NR_Linux + 155)
-#define __NR_chroot	(__NR_Linux + 156)
-#define __NR_sync	(__NR_Linux + 157)
-#define __NR_acct	(__NR_Linux + 158)
-#define __NR_settimeofday	(__NR_Linux + 159)
-#define __NR_mount	(__NR_Linux + 160)
-#define __NR_umount2	(__NR_Linux + 161)
-#define __NR_swapon	(__NR_Linux + 162)
-#define __NR_swapoff	(__NR_Linux + 163)
-#define __NR_reboot	(__NR_Linux + 164)
-#define __NR_sethostname	(__NR_Linux + 165)
-#define __NR_setdomainname	(__NR_Linux + 166)
-#define __NR_create_module	(__NR_Linux + 167)
-#define __NR_init_module	(__NR_Linux + 168)
-#define __NR_delete_module	(__NR_Linux + 169)
-#define __NR_get_kernel_syms	(__NR_Linux + 170)
-#define __NR_query_module	(__NR_Linux + 171)
-#define __NR_quotactl	(__NR_Linux + 172)
-#define __NR_nfsservctl	(__NR_Linux + 173)
-#define __NR_getpmsg	(__NR_Linux + 174)
-#define __NR_putpmsg	(__NR_Linux + 175)
-#define __NR_afs_syscall	(__NR_Linux + 176)
-#define __NR_reserved177	(__NR_Linux + 177)
-#define __NR_gettid	(__NR_Linux + 178)
-#define __NR_readahead	(__NR_Linux + 179)
-#define __NR_setxattr	(__NR_Linux + 180)
-#define __NR_lsetxattr	(__NR_Linux + 181)
-#define __NR_fsetxattr	(__NR_Linux + 182)
-#define __NR_getxattr	(__NR_Linux + 183)
-#define __NR_lgetxattr	(__NR_Linux + 184)
-#define __NR_fgetxattr	(__NR_Linux + 185)
-#define __NR_listxattr	(__NR_Linux + 186)
-#define __NR_llistxattr	(__NR_Linux + 187)
-#define __NR_flistxattr	(__NR_Linux + 188)
-#define __NR_removexattr	(__NR_Linux + 189)
-#define __NR_lremovexattr	(__NR_Linux + 190)
-#define __NR_fremovexattr	(__NR_Linux + 191)
-#define __NR_tkill	(__NR_Linux + 192)
-#define __NR_reserved193	(__NR_Linux + 193)
-#define __NR_futex	(__NR_Linux + 194)
-#define __NR_sched_setaffinity	(__NR_Linux + 195)
-#define __NR_sched_getaffinity	(__NR_Linux + 196)
-#define __NR_cacheflush	(__NR_Linux + 197)
-#define __NR_cachectl	(__NR_Linux + 198)
-#define __NR_sysmips	(__NR_Linux + 199)
-#define __NR_io_setup	(__NR_Linux + 200)
-#define __NR_io_destroy	(__NR_Linux + 201)
-#define __NR_io_getevents	(__NR_Linux + 202)
-#define __NR_io_submit	(__NR_Linux + 203)
-#define __NR_io_cancel	(__NR_Linux + 204)
-#define __NR_exit_group	(__NR_Linux + 205)
-#define __NR_lookup_dcookie	(__NR_Linux + 206)
-#define __NR_epoll_create	(__NR_Linux + 207)
-#define __NR_epoll_ctl	(__NR_Linux + 208)
-#define __NR_epoll_wait	(__NR_Linux + 209)
-#define __NR_remap_file_pages	(__NR_Linux + 210)
-#define __NR_rt_sigreturn	(__NR_Linux + 211)
-#define __NR_set_tid_address	(__NR_Linux + 212)
-#define __NR_restart_syscall	(__NR_Linux + 213)
-#define __NR_semtimedop	(__NR_Linux + 214)
-#define __NR_fadvise64	(__NR_Linux + 215)
-#define __NR_timer_create	(__NR_Linux + 216)
-#define __NR_timer_settime	(__NR_Linux + 217)
-#define __NR_timer_gettime	(__NR_Linux + 218)
-#define __NR_timer_getoverrun	(__NR_Linux + 219)
-#define __NR_timer_delete	(__NR_Linux + 220)
-#define __NR_clock_settime	(__NR_Linux + 221)
-#define __NR_clock_gettime	(__NR_Linux + 222)
-#define __NR_clock_getres	(__NR_Linux + 223)
-#define __NR_clock_nanosleep	(__NR_Linux + 224)
-#define __NR_tgkill	(__NR_Linux + 225)
-#define __NR_utimes	(__NR_Linux + 226)
-#define __NR_mbind	(__NR_Linux + 227)
-#define __NR_get_mempolicy	(__NR_Linux + 228)
-#define __NR_set_mempolicy	(__NR_Linux + 229)
-#define __NR_mq_open	(__NR_Linux + 230)
-#define __NR_mq_unlink	(__NR_Linux + 231)
-#define __NR_mq_timedsend	(__NR_Linux + 232)
-#define __NR_mq_timedreceive	(__NR_Linux + 233)
-#define __NR_mq_notify	(__NR_Linux + 234)
-#define __NR_mq_getsetattr	(__NR_Linux + 235)
-#define __NR_vserver	(__NR_Linux + 236)
-#define __NR_waitid	(__NR_Linux + 237)
-#define __NR_add_key	(__NR_Linux + 239)
-#define __NR_request_key	(__NR_Linux + 240)
-#define __NR_keyctl	(__NR_Linux + 241)
-#define __NR_set_thread_area	(__NR_Linux + 242)
-#define __NR_inotify_init	(__NR_Linux + 243)
-#define __NR_inotify_add_watch	(__NR_Linux + 244)
-#define __NR_inotify_rm_watch	(__NR_Linux + 245)
-#define __NR_migrate_pages	(__NR_Linux + 246)
-#define __NR_openat	(__NR_Linux + 247)
-#define __NR_mkdirat	(__NR_Linux + 248)
-#define __NR_mknodat	(__NR_Linux + 249)
-#define __NR_fchownat	(__NR_Linux + 250)
-#define __NR_futimesat	(__NR_Linux + 251)
-#define __NR_newfstatat	(__NR_Linux + 252)
-#define __NR_unlinkat	(__NR_Linux + 253)
-#define __NR_renameat	(__NR_Linux + 254)
-#define __NR_linkat	(__NR_Linux + 255)
-#define __NR_symlinkat	(__NR_Linux + 256)
-#define __NR_readlinkat	(__NR_Linux + 257)
-#define __NR_fchmodat	(__NR_Linux + 258)
-#define __NR_faccessat	(__NR_Linux + 259)
-#define __NR_pselect6	(__NR_Linux + 260)
-#define __NR_ppoll	(__NR_Linux + 261)
-#define __NR_unshare	(__NR_Linux + 262)
-#define __NR_splice	(__NR_Linux + 263)
-#define __NR_sync_file_range	(__NR_Linux + 264)
-#define __NR_tee	(__NR_Linux + 265)
-#define __NR_vmsplice	(__NR_Linux + 266)
-#define __NR_move_pages	(__NR_Linux + 267)
-#define __NR_set_robust_list	(__NR_Linux + 268)
-#define __NR_get_robust_list	(__NR_Linux + 269)
-#define __NR_kexec_load	(__NR_Linux + 270)
-#define __NR_getcpu	(__NR_Linux + 271)
-#define __NR_epoll_pwait	(__NR_Linux + 272)
-#define __NR_ioprio_set	(__NR_Linux + 273)
-#define __NR_ioprio_get	(__NR_Linux + 274)
-#define __NR_utimensat	(__NR_Linux + 275)
-#define __NR_signalfd	(__NR_Linux + 276)
-#define __NR_timerfd	(__NR_Linux + 277)
-#define __NR_eventfd	(__NR_Linux + 278)
-#define __NR_fallocate	(__NR_Linux + 279)
-#define __NR_timerfd_create	(__NR_Linux + 280)
-#define __NR_timerfd_gettime	(__NR_Linux + 281)
-#define __NR_timerfd_settime	(__NR_Linux + 282)
-#define __NR_signalfd4	(__NR_Linux + 283)
-#define __NR_eventfd2	(__NR_Linux + 284)
-#define __NR_epoll_create1	(__NR_Linux + 285)
-#define __NR_dup3	(__NR_Linux + 286)
-#define __NR_pipe2	(__NR_Linux + 287)
-#define __NR_inotify_init1	(__NR_Linux + 288)
-#define __NR_preadv	(__NR_Linux + 289)
-#define __NR_pwritev	(__NR_Linux + 290)
-#define __NR_rt_tgsigqueueinfo	(__NR_Linux + 291)
-#define __NR_perf_event_open	(__NR_Linux + 292)
-#define __NR_accept4	(__NR_Linux + 293)
-#define __NR_recvmmsg	(__NR_Linux + 294)
-#define __NR_fanotify_init	(__NR_Linux + 295)
-#define __NR_fanotify_mark	(__NR_Linux + 296)
-#define __NR_prlimit64	(__NR_Linux + 297)
-#define __NR_name_to_handle_at	(__NR_Linux + 298)
-#define __NR_open_by_handle_at	(__NR_Linux + 299)
-#define __NR_clock_adjtime	(__NR_Linux + 300)
-#define __NR_syncfs	(__NR_Linux + 301)
-#define __NR_sendmmsg	(__NR_Linux + 302)
-#define __NR_setns	(__NR_Linux + 303)
-#define __NR_process_vm_readv	(__NR_Linux + 304)
-#define __NR_process_vm_writev	(__NR_Linux + 305)
-#define __NR_kcmp	(__NR_Linux + 306)
-#define __NR_finit_module	(__NR_Linux + 307)
-#define __NR_getdents64	(__NR_Linux + 308)
-#define __NR_sched_setattr	(__NR_Linux + 309)
-#define __NR_sched_getattr	(__NR_Linux + 310)
-#define __NR_renameat2	(__NR_Linux + 311)
-#define __NR_seccomp	(__NR_Linux + 312)
-#define __NR_getrandom	(__NR_Linux + 313)
-#define __NR_memfd_create	(__NR_Linux + 314)
-#define __NR_bpf	(__NR_Linux + 315)
-#define __NR_execveat	(__NR_Linux + 316)
-#define __NR_userfaultfd	(__NR_Linux + 317)
-#define __NR_membarrier	(__NR_Linux + 318)
-#define __NR_mlock2	(__NR_Linux + 319)
-#define __NR_copy_file_range	(__NR_Linux + 320)
-#define __NR_preadv2	(__NR_Linux + 321)
-#define __NR_pwritev2	(__NR_Linux + 322)
-#define __NR_pkey_mprotect	(__NR_Linux + 323)
-#define __NR_pkey_alloc	(__NR_Linux + 324)
-#define __NR_pkey_free	(__NR_Linux + 325)
-#define __NR_statx	(__NR_Linux + 326)
-#define __NR_rseq	(__NR_Linux + 327)
-#define __NR_io_pgetevents	(__NR_Linux + 328)
-#define __NR_pidfd_send_signal	(__NR_Linux + 424)
-#define __NR_io_uring_setup	(__NR_Linux + 425)
-#define __NR_io_uring_enter	(__NR_Linux + 426)
-#define __NR_io_uring_register	(__NR_Linux + 427)
-#define __NR_open_tree	(__NR_Linux + 428)
-#define __NR_move_mount	(__NR_Linux + 429)
-#define __NR_fsopen	(__NR_Linux + 430)
-#define __NR_fsconfig	(__NR_Linux + 431)
-#define __NR_fsmount	(__NR_Linux + 432)
-#define __NR_fspick	(__NR_Linux + 433)
-#define __NR_pidfd_open	(__NR_Linux + 434)
-#define __NR_clone3	(__NR_Linux + 435)
-#define __NR_close_range	(__NR_Linux + 436)
-#define __NR_openat2	(__NR_Linux + 437)
-#define __NR_pidfd_getfd	(__NR_Linux + 438)
-#define __NR_faccessat2	(__NR_Linux + 439)
-#define __NR_process_madvise	(__NR_Linux + 440)
-#define __NR_epoll_pwait2	(__NR_Linux + 441)
+#define __NR_read (__NR_Linux + 0)
+#define __NR_write (__NR_Linux + 1)
+#define __NR_open (__NR_Linux + 2)
+#define __NR_close (__NR_Linux + 3)
+#define __NR_stat (__NR_Linux + 4)
+#define __NR_fstat (__NR_Linux + 5)
+#define __NR_lstat (__NR_Linux + 6)
+#define __NR_poll (__NR_Linux + 7)
+#define __NR_lseek (__NR_Linux + 8)
+#define __NR_mmap (__NR_Linux + 9)
+#define __NR_mprotect (__NR_Linux + 10)
+#define __NR_munmap (__NR_Linux + 11)
+#define __NR_brk (__NR_Linux + 12)
+#define __NR_rt_sigaction (__NR_Linux + 13)
+#define __NR_rt_sigprocmask (__NR_Linux + 14)
+#define __NR_ioctl (__NR_Linux + 15)
+#define __NR_pread64 (__NR_Linux + 16)
+#define __NR_pwrite64 (__NR_Linux + 17)
+#define __NR_readv (__NR_Linux + 18)
+#define __NR_writev (__NR_Linux + 19)
+#define __NR_access (__NR_Linux + 20)
+#define __NR_pipe (__NR_Linux + 21)
+#define __NR__newselect (__NR_Linux + 22)
+#define __NR_sched_yield (__NR_Linux + 23)
+#define __NR_mremap (__NR_Linux + 24)
+#define __NR_msync (__NR_Linux + 25)
+#define __NR_mincore (__NR_Linux + 26)
+#define __NR_madvise (__NR_Linux + 27)
+#define __NR_shmget (__NR_Linux + 28)
+#define __NR_shmat (__NR_Linux + 29)
+#define __NR_shmctl (__NR_Linux + 30)
+#define __NR_dup (__NR_Linux + 31)
+#define __NR_dup2 (__NR_Linux + 32)
+#define __NR_pause (__NR_Linux + 33)
+#define __NR_nanosleep (__NR_Linux + 34)
+#define __NR_getitimer (__NR_Linux + 35)
+#define __NR_setitimer (__NR_Linux + 36)
+#define __NR_alarm (__NR_Linux + 37)
+#define __NR_getpid (__NR_Linux + 38)
+#define __NR_sendfile (__NR_Linux + 39)
+#define __NR_socket (__NR_Linux + 40)
+#define __NR_connect (__NR_Linux + 41)
+#define __NR_accept (__NR_Linux + 42)
+#define __NR_sendto (__NR_Linux + 43)
+#define __NR_recvfrom (__NR_Linux + 44)
+#define __NR_sendmsg (__NR_Linux + 45)
+#define __NR_recvmsg (__NR_Linux + 46)
+#define __NR_shutdown (__NR_Linux + 47)
+#define __NR_bind (__NR_Linux + 48)
+#define __NR_listen (__NR_Linux + 49)
+#define __NR_getsockname (__NR_Linux + 50)
+#define __NR_getpeername (__NR_Linux + 51)
+#define __NR_socketpair (__NR_Linux + 52)
+#define __NR_setsockopt (__NR_Linux + 53)
+#define __NR_getsockopt (__NR_Linux + 54)
+#define __NR_clone (__NR_Linux + 55)
+#define __NR_fork (__NR_Linux + 56)
+#define __NR_execve (__NR_Linux + 57)
+#define __NR_exit (__NR_Linux + 58)
+#define __NR_wait4 (__NR_Linux + 59)
+#define __NR_kill (__NR_Linux + 60)
+#define __NR_uname (__NR_Linux + 61)
+#define __NR_semget (__NR_Linux + 62)
+#define __NR_semop (__NR_Linux + 63)
+#define __NR_semctl (__NR_Linux + 64)
+#define __NR_shmdt (__NR_Linux + 65)
+#define __NR_msgget (__NR_Linux + 66)
+#define __NR_msgsnd (__NR_Linux + 67)
+#define __NR_msgrcv (__NR_Linux + 68)
+#define __NR_msgctl (__NR_Linux + 69)
+#define __NR_fcntl (__NR_Linux + 70)
+#define __NR_flock (__NR_Linux + 71)
+#define __NR_fsync (__NR_Linux + 72)
+#define __NR_fdatasync (__NR_Linux + 73)
+#define __NR_truncate (__NR_Linux + 74)
+#define __NR_ftruncate (__NR_Linux + 75)
+#define __NR_getdents (__NR_Linux + 76)
+#define __NR_getcwd (__NR_Linux + 77)
+#define __NR_chdir (__NR_Linux + 78)
+#define __NR_fchdir (__NR_Linux + 79)
+#define __NR_rename (__NR_Linux + 80)
+#define __NR_mkdir (__NR_Linux + 81)
+#define __NR_rmdir (__NR_Linux + 82)
+#define __NR_creat (__NR_Linux + 83)
+#define __NR_link (__NR_Linux + 84)
+#define __NR_unlink (__NR_Linux + 85)
+#define __NR_symlink (__NR_Linux + 86)
+#define __NR_readlink (__NR_Linux + 87)
+#define __NR_chmod (__NR_Linux + 88)
+#define __NR_fchmod (__NR_Linux + 89)
+#define __NR_chown (__NR_Linux + 90)
+#define __NR_fchown (__NR_Linux + 91)
+#define __NR_lchown (__NR_Linux + 92)
+#define __NR_umask (__NR_Linux + 93)
+#define __NR_gettimeofday (__NR_Linux + 94)
+#define __NR_getrlimit (__NR_Linux + 95)
+#define __NR_getrusage (__NR_Linux + 96)
+#define __NR_sysinfo (__NR_Linux + 97)
+#define __NR_times (__NR_Linux + 98)
+#define __NR_ptrace (__NR_Linux + 99)
+#define __NR_getuid (__NR_Linux + 100)
+#define __NR_syslog (__NR_Linux + 101)
+#define __NR_getgid (__NR_Linux + 102)
+#define __NR_setuid (__NR_Linux + 103)
+#define __NR_setgid (__NR_Linux + 104)
+#define __NR_geteuid (__NR_Linux + 105)
+#define __NR_getegid (__NR_Linux + 106)
+#define __NR_setpgid (__NR_Linux + 107)
+#define __NR_getppid (__NR_Linux + 108)
+#define __NR_getpgrp (__NR_Linux + 109)
+#define __NR_setsid (__NR_Linux + 110)
+#define __NR_setreuid (__NR_Linux + 111)
+#define __NR_setregid (__NR_Linux + 112)
+#define __NR_getgroups (__NR_Linux + 113)
+#define __NR_setgroups (__NR_Linux + 114)
+#define __NR_setresuid (__NR_Linux + 115)
+#define __NR_getresuid (__NR_Linux + 116)
+#define __NR_setresgid (__NR_Linux + 117)
+#define __NR_getresgid (__NR_Linux + 118)
+#define __NR_getpgid (__NR_Linux + 119)
+#define __NR_setfsuid (__NR_Linux + 120)
+#define __NR_setfsgid (__NR_Linux + 121)
+#define __NR_getsid (__NR_Linux + 122)
+#define __NR_capget (__NR_Linux + 123)
+#define __NR_capset (__NR_Linux + 124)
+#define __NR_rt_sigpending (__NR_Linux + 125)
+#define __NR_rt_sigtimedwait (__NR_Linux + 126)
+#define __NR_rt_sigqueueinfo (__NR_Linux + 127)
+#define __NR_rt_sigsuspend (__NR_Linux + 128)
+#define __NR_sigaltstack (__NR_Linux + 129)
+#define __NR_utime (__NR_Linux + 130)
+#define __NR_mknod (__NR_Linux + 131)
+#define __NR_personality (__NR_Linux + 132)
+#define __NR_ustat (__NR_Linux + 133)
+#define __NR_statfs (__NR_Linux + 134)
+#define __NR_fstatfs (__NR_Linux + 135)
+#define __NR_sysfs (__NR_Linux + 136)
+#define __NR_getpriority (__NR_Linux + 137)
+#define __NR_setpriority (__NR_Linux + 138)
+#define __NR_sched_setparam (__NR_Linux + 139)
+#define __NR_sched_getparam (__NR_Linux + 140)
+#define __NR_sched_setscheduler (__NR_Linux + 141)
+#define __NR_sched_getscheduler (__NR_Linux + 142)
+#define __NR_sched_get_priority_max (__NR_Linux + 143)
+#define __NR_sched_get_priority_min (__NR_Linux + 144)
+#define __NR_sched_rr_get_interval (__NR_Linux + 145)
+#define __NR_mlock (__NR_Linux + 146)
+#define __NR_munlock (__NR_Linux + 147)
+#define __NR_mlockall (__NR_Linux + 148)
+#define __NR_munlockall (__NR_Linux + 149)
+#define __NR_vhangup (__NR_Linux + 150)
+#define __NR_pivot_root (__NR_Linux + 151)
+#define __NR__sysctl (__NR_Linux + 152)
+#define __NR_prctl (__NR_Linux + 153)
+#define __NR_adjtimex (__NR_Linux + 154)
+#define __NR_setrlimit (__NR_Linux + 155)
+#define __NR_chroot (__NR_Linux + 156)
+#define __NR_sync (__NR_Linux + 157)
+#define __NR_acct (__NR_Linux + 158)
+#define __NR_settimeofday (__NR_Linux + 159)
+#define __NR_mount (__NR_Linux + 160)
+#define __NR_umount2 (__NR_Linux + 161)
+#define __NR_swapon (__NR_Linux + 162)
+#define __NR_swapoff (__NR_Linux + 163)
+#define __NR_reboot (__NR_Linux + 164)
+#define __NR_sethostname (__NR_Linux + 165)
+#define __NR_setdomainname (__NR_Linux + 166)
+#define __NR_create_module (__NR_Linux + 167)
+#define __NR_init_module (__NR_Linux + 168)
+#define __NR_delete_module (__NR_Linux + 169)
+#define __NR_get_kernel_syms (__NR_Linux + 170)
+#define __NR_query_module (__NR_Linux + 171)
+#define __NR_quotactl (__NR_Linux + 172)
+#define __NR_nfsservctl (__NR_Linux + 173)
+#define __NR_getpmsg (__NR_Linux + 174)
+#define __NR_putpmsg (__NR_Linux + 175)
+#define __NR_afs_syscall (__NR_Linux + 176)
+#define __NR_reserved177 (__NR_Linux + 177)
+#define __NR_gettid (__NR_Linux + 178)
+#define __NR_readahead (__NR_Linux + 179)
+#define __NR_setxattr (__NR_Linux + 180)
+#define __NR_lsetxattr (__NR_Linux + 181)
+#define __NR_fsetxattr (__NR_Linux + 182)
+#define __NR_getxattr (__NR_Linux + 183)
+#define __NR_lgetxattr (__NR_Linux + 184)
+#define __NR_fgetxattr (__NR_Linux + 185)
+#define __NR_listxattr (__NR_Linux + 186)
+#define __NR_llistxattr (__NR_Linux + 187)
+#define __NR_flistxattr (__NR_Linux + 188)
+#define __NR_removexattr (__NR_Linux + 189)
+#define __NR_lremovexattr (__NR_Linux + 190)
+#define __NR_fremovexattr (__NR_Linux + 191)
+#define __NR_tkill (__NR_Linux + 192)
+#define __NR_reserved193 (__NR_Linux + 193)
+#define __NR_futex (__NR_Linux + 194)
+#define __NR_sched_setaffinity (__NR_Linux + 195)
+#define __NR_sched_getaffinity (__NR_Linux + 196)
+#define __NR_cacheflush (__NR_Linux + 197)
+#define __NR_cachectl (__NR_Linux + 198)
+#define __NR_sysmips (__NR_Linux + 199)
+#define __NR_io_setup (__NR_Linux + 200)
+#define __NR_io_destroy (__NR_Linux + 201)
+#define __NR_io_getevents (__NR_Linux + 202)
+#define __NR_io_submit (__NR_Linux + 203)
+#define __NR_io_cancel (__NR_Linux + 204)
+#define __NR_exit_group (__NR_Linux + 205)
+#define __NR_lookup_dcookie (__NR_Linux + 206)
+#define __NR_epoll_create (__NR_Linux + 207)
+#define __NR_epoll_ctl (__NR_Linux + 208)
+#define __NR_epoll_wait (__NR_Linux + 209)
+#define __NR_remap_file_pages (__NR_Linux + 210)
+#define __NR_rt_sigreturn (__NR_Linux + 211)
+#define __NR_set_tid_address (__NR_Linux + 212)
+#define __NR_restart_syscall (__NR_Linux + 213)
+#define __NR_semtimedop (__NR_Linux + 214)
+#define __NR_fadvise64 (__NR_Linux + 215)
+#define __NR_timer_create (__NR_Linux + 216)
+#define __NR_timer_settime (__NR_Linux + 217)
+#define __NR_timer_gettime (__NR_Linux + 218)
+#define __NR_timer_getoverrun (__NR_Linux + 219)
+#define __NR_timer_delete (__NR_Linux + 220)
+#define __NR_clock_settime (__NR_Linux + 221)
+#define __NR_clock_gettime (__NR_Linux + 222)
+#define __NR_clock_getres (__NR_Linux + 223)
+#define __NR_clock_nanosleep (__NR_Linux + 224)
+#define __NR_tgkill (__NR_Linux + 225)
+#define __NR_utimes (__NR_Linux + 226)
+#define __NR_mbind (__NR_Linux + 227)
+#define __NR_get_mempolicy (__NR_Linux + 228)
+#define __NR_set_mempolicy (__NR_Linux + 229)
+#define __NR_mq_open (__NR_Linux + 230)
+#define __NR_mq_unlink (__NR_Linux + 231)
+#define __NR_mq_timedsend (__NR_Linux + 232)
+#define __NR_mq_timedreceive (__NR_Linux + 233)
+#define __NR_mq_notify (__NR_Linux + 234)
+#define __NR_mq_getsetattr (__NR_Linux + 235)
+#define __NR_vserver (__NR_Linux + 236)
+#define __NR_waitid (__NR_Linux + 237)
+#define __NR_add_key (__NR_Linux + 239)
+#define __NR_request_key (__NR_Linux + 240)
+#define __NR_keyctl (__NR_Linux + 241)
+#define __NR_set_thread_area (__NR_Linux + 242)
+#define __NR_inotify_init (__NR_Linux + 243)
+#define __NR_inotify_add_watch (__NR_Linux + 244)
+#define __NR_inotify_rm_watch (__NR_Linux + 245)
+#define __NR_migrate_pages (__NR_Linux + 246)
+#define __NR_openat (__NR_Linux + 247)
+#define __NR_mkdirat (__NR_Linux + 248)
+#define __NR_mknodat (__NR_Linux + 249)
+#define __NR_fchownat (__NR_Linux + 250)
+#define __NR_futimesat (__NR_Linux + 251)
+#define __NR_newfstatat (__NR_Linux + 252)
+#define __NR_unlinkat (__NR_Linux + 253)
+#define __NR_renameat (__NR_Linux + 254)
+#define __NR_linkat (__NR_Linux + 255)
+#define __NR_symlinkat (__NR_Linux + 256)
+#define __NR_readlinkat (__NR_Linux + 257)
+#define __NR_fchmodat (__NR_Linux + 258)
+#define __NR_faccessat (__NR_Linux + 259)
+#define __NR_pselect6 (__NR_Linux + 260)
+#define __NR_ppoll (__NR_Linux + 261)
+#define __NR_unshare (__NR_Linux + 262)
+#define __NR_splice (__NR_Linux + 263)
+#define __NR_sync_file_range (__NR_Linux + 264)
+#define __NR_tee (__NR_Linux + 265)
+#define __NR_vmsplice (__NR_Linux + 266)
+#define __NR_move_pages (__NR_Linux + 267)
+#define __NR_set_robust_list (__NR_Linux + 268)
+#define __NR_get_robust_list (__NR_Linux + 269)
+#define __NR_kexec_load (__NR_Linux + 270)
+#define __NR_getcpu (__NR_Linux + 271)
+#define __NR_epoll_pwait (__NR_Linux + 272)
+#define __NR_ioprio_set (__NR_Linux + 273)
+#define __NR_ioprio_get (__NR_Linux + 274)
+#define __NR_utimensat (__NR_Linux + 275)
+#define __NR_signalfd (__NR_Linux + 276)
+#define __NR_timerfd (__NR_Linux + 277)
+#define __NR_eventfd (__NR_Linux + 278)
+#define __NR_fallocate (__NR_Linux + 279)
+#define __NR_timerfd_create (__NR_Linux + 280)
+#define __NR_timerfd_gettime (__NR_Linux + 281)
+#define __NR_timerfd_settime (__NR_Linux + 282)
+#define __NR_signalfd4 (__NR_Linux + 283)
+#define __NR_eventfd2 (__NR_Linux + 284)
+#define __NR_epoll_create1 (__NR_Linux + 285)
+#define __NR_dup3 (__NR_Linux + 286)
+#define __NR_pipe2 (__NR_Linux + 287)
+#define __NR_inotify_init1 (__NR_Linux + 288)
+#define __NR_preadv (__NR_Linux + 289)
+#define __NR_pwritev (__NR_Linux + 290)
+#define __NR_rt_tgsigqueueinfo (__NR_Linux + 291)
+#define __NR_perf_event_open (__NR_Linux + 292)
+#define __NR_accept4 (__NR_Linux + 293)
+#define __NR_recvmmsg (__NR_Linux + 294)
+#define __NR_fanotify_init (__NR_Linux + 295)
+#define __NR_fanotify_mark (__NR_Linux + 296)
+#define __NR_prlimit64 (__NR_Linux + 297)
+#define __NR_name_to_handle_at (__NR_Linux + 298)
+#define __NR_open_by_handle_at (__NR_Linux + 299)
+#define __NR_clock_adjtime (__NR_Linux + 300)
+#define __NR_syncfs (__NR_Linux + 301)
+#define __NR_sendmmsg (__NR_Linux + 302)
+#define __NR_setns (__NR_Linux + 303)
+#define __NR_process_vm_readv (__NR_Linux + 304)
+#define __NR_process_vm_writev (__NR_Linux + 305)
+#define __NR_kcmp (__NR_Linux + 306)
+#define __NR_finit_module (__NR_Linux + 307)
+#define __NR_getdents64 (__NR_Linux + 308)
+#define __NR_sched_setattr (__NR_Linux + 309)
+#define __NR_sched_getattr (__NR_Linux + 310)
+#define __NR_renameat2 (__NR_Linux + 311)
+#define __NR_seccomp (__NR_Linux + 312)
+#define __NR_getrandom (__NR_Linux + 313)
+#define __NR_memfd_create (__NR_Linux + 314)
+#define __NR_bpf (__NR_Linux + 315)
+#define __NR_execveat (__NR_Linux + 316)
+#define __NR_userfaultfd (__NR_Linux + 317)
+#define __NR_membarrier (__NR_Linux + 318)
+#define __NR_mlock2 (__NR_Linux + 319)
+#define __NR_copy_file_range (__NR_Linux + 320)
+#define __NR_preadv2 (__NR_Linux + 321)
+#define __NR_pwritev2 (__NR_Linux + 322)
+#define __NR_pkey_mprotect (__NR_Linux + 323)
+#define __NR_pkey_alloc (__NR_Linux + 324)
+#define __NR_pkey_free (__NR_Linux + 325)
+#define __NR_statx (__NR_Linux + 326)
+#define __NR_rseq (__NR_Linux + 327)
+#define __NR_io_pgetevents (__NR_Linux + 328)
+#define __NR_pidfd_send_signal (__NR_Linux + 424)
+#define __NR_io_uring_setup (__NR_Linux + 425)
+#define __NR_io_uring_enter (__NR_Linux + 426)
+#define __NR_io_uring_register (__NR_Linux + 427)
+#define __NR_open_tree (__NR_Linux + 428)
+#define __NR_move_mount (__NR_Linux + 429)
+#define __NR_fsopen (__NR_Linux + 430)
+#define __NR_fsconfig (__NR_Linux + 431)
+#define __NR_fsmount (__NR_Linux + 432)
+#define __NR_fspick (__NR_Linux + 433)
+#define __NR_pidfd_open (__NR_Linux + 434)
+#define __NR_clone3 (__NR_Linux + 435)
+#define __NR_close_range (__NR_Linux + 436)
+#define __NR_openat2 (__NR_Linux + 437)
+#define __NR_pidfd_getfd (__NR_Linux + 438)
+#define __NR_faccessat2 (__NR_Linux + 439)
+#define __NR_process_madvise (__NR_Linux + 440)
+#define __NR_epoll_pwait2 (__NR_Linux + 441)
+#define __NR_mount_setattr (__NR_Linux + 442)
+#define __NR_landlock_create_ruleset (__NR_Linux + 444)
+#define __NR_landlock_add_rule (__NR_Linux + 445)
+#define __NR_landlock_restrict_self (__NR_Linux + 446)
 
-
-#endif /* _ASM_MIPS_UNISTD_N64_H */
+#endif /* _ASM_UNISTD_N64_H */
diff --git a/linux-headers/asm-mips/unistd_o32.h b/linux-headers/asm-mips/unistd_o32.h
index ca6a7e5c0b..954303ad69 100644
--- a/linux-headers/asm-mips/unistd_o32.h
+++ b/linux-headers/asm-mips/unistd_o32.h
@@ -1,422 +1,425 @@
-#ifndef _ASM_MIPS_UNISTD_O32_H
-#define _ASM_MIPS_UNISTD_O32_H
+#ifndef _ASM_UNISTD_O32_H
+#define _ASM_UNISTD_O32_H
 
-#define __NR_syscall	(__NR_Linux + 0)
-#define __NR_exit	(__NR_Linux + 1)
-#define __NR_fork	(__NR_Linux + 2)
-#define __NR_read	(__NR_Linux + 3)
-#define __NR_write	(__NR_Linux + 4)
-#define __NR_open	(__NR_Linux + 5)
-#define __NR_close	(__NR_Linux + 6)
-#define __NR_waitpid	(__NR_Linux + 7)
-#define __NR_creat	(__NR_Linux + 8)
-#define __NR_link	(__NR_Linux + 9)
-#define __NR_unlink	(__NR_Linux + 10)
-#define __NR_execve	(__NR_Linux + 11)
-#define __NR_chdir	(__NR_Linux + 12)
-#define __NR_time	(__NR_Linux + 13)
-#define __NR_mknod	(__NR_Linux + 14)
-#define __NR_chmod	(__NR_Linux + 15)
-#define __NR_lchown	(__NR_Linux + 16)
-#define __NR_break	(__NR_Linux + 17)
-#define __NR_unused18	(__NR_Linux + 18)
-#define __NR_lseek	(__NR_Linux + 19)
-#define __NR_getpid	(__NR_Linux + 20)
-#define __NR_mount	(__NR_Linux + 21)
-#define __NR_umount	(__NR_Linux + 22)
-#define __NR_setuid	(__NR_Linux + 23)
-#define __NR_getuid	(__NR_Linux + 24)
-#define __NR_stime	(__NR_Linux + 25)
-#define __NR_ptrace	(__NR_Linux + 26)
-#define __NR_alarm	(__NR_Linux + 27)
-#define __NR_unused28	(__NR_Linux + 28)
-#define __NR_pause	(__NR_Linux + 29)
-#define __NR_utime	(__NR_Linux + 30)
-#define __NR_stty	(__NR_Linux + 31)
-#define __NR_gtty	(__NR_Linux + 32)
-#define __NR_access	(__NR_Linux + 33)
-#define __NR_nice	(__NR_Linux + 34)
-#define __NR_ftime	(__NR_Linux + 35)
-#define __NR_sync	(__NR_Linux + 36)
-#define __NR_kill	(__NR_Linux + 37)
-#define __NR_rename	(__NR_Linux + 38)
-#define __NR_mkdir	(__NR_Linux + 39)
-#define __NR_rmdir	(__NR_Linux + 40)
-#define __NR_dup	(__NR_Linux + 41)
-#define __NR_pipe	(__NR_Linux + 42)
-#define __NR_times	(__NR_Linux + 43)
-#define __NR_prof	(__NR_Linux + 44)
-#define __NR_brk	(__NR_Linux + 45)
-#define __NR_setgid	(__NR_Linux + 46)
-#define __NR_getgid	(__NR_Linux + 47)
-#define __NR_signal	(__NR_Linux + 48)
-#define __NR_geteuid	(__NR_Linux + 49)
-#define __NR_getegid	(__NR_Linux + 50)
-#define __NR_acct	(__NR_Linux + 51)
-#define __NR_umount2	(__NR_Linux + 52)
-#define __NR_lock	(__NR_Linux + 53)
-#define __NR_ioctl	(__NR_Linux + 54)
-#define __NR_fcntl	(__NR_Linux + 55)
-#define __NR_mpx	(__NR_Linux + 56)
-#define __NR_setpgid	(__NR_Linux + 57)
-#define __NR_ulimit	(__NR_Linux + 58)
-#define __NR_unused59	(__NR_Linux + 59)
-#define __NR_umask	(__NR_Linux + 60)
-#define __NR_chroot	(__NR_Linux + 61)
-#define __NR_ustat	(__NR_Linux + 62)
-#define __NR_dup2	(__NR_Linux + 63)
-#define __NR_getppid	(__NR_Linux + 64)
-#define __NR_getpgrp	(__NR_Linux + 65)
-#define __NR_setsid	(__NR_Linux + 66)
-#define __NR_sigaction	(__NR_Linux + 67)
-#define __NR_sgetmask	(__NR_Linux + 68)
-#define __NR_ssetmask	(__NR_Linux + 69)
-#define __NR_setreuid	(__NR_Linux + 70)
-#define __NR_setregid	(__NR_Linux + 71)
-#define __NR_sigsuspend	(__NR_Linux + 72)
-#define __NR_sigpending	(__NR_Linux + 73)
-#define __NR_sethostname	(__NR_Linux + 74)
-#define __NR_setrlimit	(__NR_Linux + 75)
-#define __NR_getrlimit	(__NR_Linux + 76)
-#define __NR_getrusage	(__NR_Linux + 77)
-#define __NR_gettimeofday	(__NR_Linux + 78)
-#define __NR_settimeofday	(__NR_Linux + 79)
-#define __NR_getgroups	(__NR_Linux + 80)
-#define __NR_setgroups	(__NR_Linux + 81)
-#define __NR_reserved82	(__NR_Linux + 82)
-#define __NR_symlink	(__NR_Linux + 83)
-#define __NR_unused84	(__NR_Linux + 84)
-#define __NR_readlink	(__NR_Linux + 85)
-#define __NR_uselib	(__NR_Linux + 86)
-#define __NR_swapon	(__NR_Linux + 87)
-#define __NR_reboot	(__NR_Linux + 88)
-#define __NR_readdir	(__NR_Linux + 89)
-#define __NR_mmap	(__NR_Linux + 90)
-#define __NR_munmap	(__NR_Linux + 91)
-#define __NR_truncate	(__NR_Linux + 92)
-#define __NR_ftruncate	(__NR_Linux + 93)
-#define __NR_fchmod	(__NR_Linux + 94)
-#define __NR_fchown	(__NR_Linux + 95)
-#define __NR_getpriority	(__NR_Linux + 96)
-#define __NR_setpriority	(__NR_Linux + 97)
-#define __NR_profil	(__NR_Linux + 98)
-#define __NR_statfs	(__NR_Linux + 99)
-#define __NR_fstatfs	(__NR_Linux + 100)
-#define __NR_ioperm	(__NR_Linux + 101)
-#define __NR_socketcall	(__NR_Linux + 102)
-#define __NR_syslog	(__NR_Linux + 103)
-#define __NR_setitimer	(__NR_Linux + 104)
-#define __NR_getitimer	(__NR_Linux + 105)
-#define __NR_stat	(__NR_Linux + 106)
-#define __NR_lstat	(__NR_Linux + 107)
-#define __NR_fstat	(__NR_Linux + 108)
-#define __NR_unused109	(__NR_Linux + 109)
-#define __NR_iopl	(__NR_Linux + 110)
-#define __NR_vhangup	(__NR_Linux + 111)
-#define __NR_idle	(__NR_Linux + 112)
-#define __NR_vm86	(__NR_Linux + 113)
-#define __NR_wait4	(__NR_Linux + 114)
-#define __NR_swapoff	(__NR_Linux + 115)
-#define __NR_sysinfo	(__NR_Linux + 116)
-#define __NR_ipc	(__NR_Linux + 117)
-#define __NR_fsync	(__NR_Linux + 118)
-#define __NR_sigreturn	(__NR_Linux + 119)
-#define __NR_clone	(__NR_Linux + 120)
-#define __NR_setdomainname	(__NR_Linux + 121)
-#define __NR_uname	(__NR_Linux + 122)
-#define __NR_modify_ldt	(__NR_Linux + 123)
-#define __NR_adjtimex	(__NR_Linux + 124)
-#define __NR_mprotect	(__NR_Linux + 125)
-#define __NR_sigprocmask	(__NR_Linux + 126)
-#define __NR_create_module	(__NR_Linux + 127)
-#define __NR_init_module	(__NR_Linux + 128)
-#define __NR_delete_module	(__NR_Linux + 129)
-#define __NR_get_kernel_syms	(__NR_Linux + 130)
-#define __NR_quotactl	(__NR_Linux + 131)
-#define __NR_getpgid	(__NR_Linux + 132)
-#define __NR_fchdir	(__NR_Linux + 133)
-#define __NR_bdflush	(__NR_Linux + 134)
-#define __NR_sysfs	(__NR_Linux + 135)
-#define __NR_personality	(__NR_Linux + 136)
-#define __NR_afs_syscall	(__NR_Linux + 137)
-#define __NR_setfsuid	(__NR_Linux + 138)
-#define __NR_setfsgid	(__NR_Linux + 139)
-#define __NR__llseek	(__NR_Linux + 140)
-#define __NR_getdents	(__NR_Linux + 141)
-#define __NR__newselect	(__NR_Linux + 142)
-#define __NR_flock	(__NR_Linux + 143)
-#define __NR_msync	(__NR_Linux + 144)
-#define __NR_readv	(__NR_Linux + 145)
-#define __NR_writev	(__NR_Linux + 146)
-#define __NR_cacheflush	(__NR_Linux + 147)
-#define __NR_cachectl	(__NR_Linux + 148)
-#define __NR_sysmips	(__NR_Linux + 149)
-#define __NR_unused150	(__NR_Linux + 150)
-#define __NR_getsid	(__NR_Linux + 151)
-#define __NR_fdatasync	(__NR_Linux + 152)
-#define __NR__sysctl	(__NR_Linux + 153)
-#define __NR_mlock	(__NR_Linux + 154)
-#define __NR_munlock	(__NR_Linux + 155)
-#define __NR_mlockall	(__NR_Linux + 156)
-#define __NR_munlockall	(__NR_Linux + 157)
-#define __NR_sched_setparam	(__NR_Linux + 158)
-#define __NR_sched_getparam	(__NR_Linux + 159)
-#define __NR_sched_setscheduler	(__NR_Linux + 160)
-#define __NR_sched_getscheduler	(__NR_Linux + 161)
-#define __NR_sched_yield	(__NR_Linux + 162)
-#define __NR_sched_get_priority_max	(__NR_Linux + 163)
-#define __NR_sched_get_priority_min	(__NR_Linux + 164)
-#define __NR_sched_rr_get_interval	(__NR_Linux + 165)
-#define __NR_nanosleep	(__NR_Linux + 166)
-#define __NR_mremap	(__NR_Linux + 167)
-#define __NR_accept	(__NR_Linux + 168)
-#define __NR_bind	(__NR_Linux + 169)
-#define __NR_connect	(__NR_Linux + 170)
-#define __NR_getpeername	(__NR_Linux + 171)
-#define __NR_getsockname	(__NR_Linux + 172)
-#define __NR_getsockopt	(__NR_Linux + 173)
-#define __NR_listen	(__NR_Linux + 174)
-#define __NR_recv	(__NR_Linux + 175)
-#define __NR_recvfrom	(__NR_Linux + 176)
-#define __NR_recvmsg	(__NR_Linux + 177)
-#define __NR_send	(__NR_Linux + 178)
-#define __NR_sendmsg	(__NR_Linux + 179)
-#define __NR_sendto	(__NR_Linux + 180)
-#define __NR_setsockopt	(__NR_Linux + 181)
-#define __NR_shutdown	(__NR_Linux + 182)
-#define __NR_socket	(__NR_Linux + 183)
-#define __NR_socketpair	(__NR_Linux + 184)
-#define __NR_setresuid	(__NR_Linux + 185)
-#define __NR_getresuid	(__NR_Linux + 186)
-#define __NR_query_module	(__NR_Linux + 187)
-#define __NR_poll	(__NR_Linux + 188)
-#define __NR_nfsservctl	(__NR_Linux + 189)
-#define __NR_setresgid	(__NR_Linux + 190)
-#define __NR_getresgid	(__NR_Linux + 191)
-#define __NR_prctl	(__NR_Linux + 192)
-#define __NR_rt_sigreturn	(__NR_Linux + 193)
-#define __NR_rt_sigaction	(__NR_Linux + 194)
-#define __NR_rt_sigprocmask	(__NR_Linux + 195)
-#define __NR_rt_sigpending	(__NR_Linux + 196)
-#define __NR_rt_sigtimedwait	(__NR_Linux + 197)
-#define __NR_rt_sigqueueinfo	(__NR_Linux + 198)
-#define __NR_rt_sigsuspend	(__NR_Linux + 199)
-#define __NR_pread64	(__NR_Linux + 200)
-#define __NR_pwrite64	(__NR_Linux + 201)
-#define __NR_chown	(__NR_Linux + 202)
-#define __NR_getcwd	(__NR_Linux + 203)
-#define __NR_capget	(__NR_Linux + 204)
-#define __NR_capset	(__NR_Linux + 205)
-#define __NR_sigaltstack	(__NR_Linux + 206)
-#define __NR_sendfile	(__NR_Linux + 207)
-#define __NR_getpmsg	(__NR_Linux + 208)
-#define __NR_putpmsg	(__NR_Linux + 209)
-#define __NR_mmap2	(__NR_Linux + 210)
-#define __NR_truncate64	(__NR_Linux + 211)
-#define __NR_ftruncate64	(__NR_Linux + 212)
-#define __NR_stat64	(__NR_Linux + 213)
-#define __NR_lstat64	(__NR_Linux + 214)
-#define __NR_fstat64	(__NR_Linux + 215)
-#define __NR_pivot_root	(__NR_Linux + 216)
-#define __NR_mincore	(__NR_Linux + 217)
-#define __NR_madvise	(__NR_Linux + 218)
-#define __NR_getdents64	(__NR_Linux + 219)
-#define __NR_fcntl64	(__NR_Linux + 220)
-#define __NR_reserved221	(__NR_Linux + 221)
-#define __NR_gettid	(__NR_Linux + 222)
-#define __NR_readahead	(__NR_Linux + 223)
-#define __NR_setxattr	(__NR_Linux + 224)
-#define __NR_lsetxattr	(__NR_Linux + 225)
-#define __NR_fsetxattr	(__NR_Linux + 226)
-#define __NR_getxattr	(__NR_Linux + 227)
-#define __NR_lgetxattr	(__NR_Linux + 228)
-#define __NR_fgetxattr	(__NR_Linux + 229)
-#define __NR_listxattr	(__NR_Linux + 230)
-#define __NR_llistxattr	(__NR_Linux + 231)
-#define __NR_flistxattr	(__NR_Linux + 232)
-#define __NR_removexattr	(__NR_Linux + 233)
-#define __NR_lremovexattr	(__NR_Linux + 234)
-#define __NR_fremovexattr	(__NR_Linux + 235)
-#define __NR_tkill	(__NR_Linux + 236)
-#define __NR_sendfile64	(__NR_Linux + 237)
-#define __NR_futex	(__NR_Linux + 238)
-#define __NR_sched_setaffinity	(__NR_Linux + 239)
-#define __NR_sched_getaffinity	(__NR_Linux + 240)
-#define __NR_io_setup	(__NR_Linux + 241)
-#define __NR_io_destroy	(__NR_Linux + 242)
-#define __NR_io_getevents	(__NR_Linux + 243)
-#define __NR_io_submit	(__NR_Linux + 244)
-#define __NR_io_cancel	(__NR_Linux + 245)
-#define __NR_exit_group	(__NR_Linux + 246)
-#define __NR_lookup_dcookie	(__NR_Linux + 247)
-#define __NR_epoll_create	(__NR_Linux + 248)
-#define __NR_epoll_ctl	(__NR_Linux + 249)
-#define __NR_epoll_wait	(__NR_Linux + 250)
-#define __NR_remap_file_pages	(__NR_Linux + 251)
-#define __NR_set_tid_address	(__NR_Linux + 252)
-#define __NR_restart_syscall	(__NR_Linux + 253)
-#define __NR_fadvise64	(__NR_Linux + 254)
-#define __NR_statfs64	(__NR_Linux + 255)
-#define __NR_fstatfs64	(__NR_Linux + 256)
-#define __NR_timer_create	(__NR_Linux + 257)
-#define __NR_timer_settime	(__NR_Linux + 258)
-#define __NR_timer_gettime	(__NR_Linux + 259)
-#define __NR_timer_getoverrun	(__NR_Linux + 260)
-#define __NR_timer_delete	(__NR_Linux + 261)
-#define __NR_clock_settime	(__NR_Linux + 262)
-#define __NR_clock_gettime	(__NR_Linux + 263)
-#define __NR_clock_getres	(__NR_Linux + 264)
-#define __NR_clock_nanosleep	(__NR_Linux + 265)
-#define __NR_tgkill	(__NR_Linux + 266)
-#define __NR_utimes	(__NR_Linux + 267)
-#define __NR_mbind	(__NR_Linux + 268)
-#define __NR_get_mempolicy	(__NR_Linux + 269)
-#define __NR_set_mempolicy	(__NR_Linux + 270)
-#define __NR_mq_open	(__NR_Linux + 271)
-#define __NR_mq_unlink	(__NR_Linux + 272)
-#define __NR_mq_timedsend	(__NR_Linux + 273)
-#define __NR_mq_timedreceive	(__NR_Linux + 274)
-#define __NR_mq_notify	(__NR_Linux + 275)
-#define __NR_mq_getsetattr	(__NR_Linux + 276)
-#define __NR_vserver	(__NR_Linux + 277)
-#define __NR_waitid	(__NR_Linux + 278)
-#define __NR_add_key	(__NR_Linux + 280)
-#define __NR_request_key	(__NR_Linux + 281)
-#define __NR_keyctl	(__NR_Linux + 282)
-#define __NR_set_thread_area	(__NR_Linux + 283)
-#define __NR_inotify_init	(__NR_Linux + 284)
-#define __NR_inotify_add_watch	(__NR_Linux + 285)
-#define __NR_inotify_rm_watch	(__NR_Linux + 286)
-#define __NR_migrate_pages	(__NR_Linux + 287)
-#define __NR_openat	(__NR_Linux + 288)
-#define __NR_mkdirat	(__NR_Linux + 289)
-#define __NR_mknodat	(__NR_Linux + 290)
-#define __NR_fchownat	(__NR_Linux + 291)
-#define __NR_futimesat	(__NR_Linux + 292)
-#define __NR_fstatat64	(__NR_Linux + 293)
-#define __NR_unlinkat	(__NR_Linux + 294)
-#define __NR_renameat	(__NR_Linux + 295)
-#define __NR_linkat	(__NR_Linux + 296)
-#define __NR_symlinkat	(__NR_Linux + 297)
-#define __NR_readlinkat	(__NR_Linux + 298)
-#define __NR_fchmodat	(__NR_Linux + 299)
-#define __NR_faccessat	(__NR_Linux + 300)
-#define __NR_pselect6	(__NR_Linux + 301)
-#define __NR_ppoll	(__NR_Linux + 302)
-#define __NR_unshare	(__NR_Linux + 303)
-#define __NR_splice	(__NR_Linux + 304)
-#define __NR_sync_file_range	(__NR_Linux + 305)
-#define __NR_tee	(__NR_Linux + 306)
-#define __NR_vmsplice	(__NR_Linux + 307)
-#define __NR_move_pages	(__NR_Linux + 308)
-#define __NR_set_robust_list	(__NR_Linux + 309)
-#define __NR_get_robust_list	(__NR_Linux + 310)
-#define __NR_kexec_load	(__NR_Linux + 311)
-#define __NR_getcpu	(__NR_Linux + 312)
-#define __NR_epoll_pwait	(__NR_Linux + 313)
-#define __NR_ioprio_set	(__NR_Linux + 314)
-#define __NR_ioprio_get	(__NR_Linux + 315)
-#define __NR_utimensat	(__NR_Linux + 316)
-#define __NR_signalfd	(__NR_Linux + 317)
-#define __NR_timerfd	(__NR_Linux + 318)
-#define __NR_eventfd	(__NR_Linux + 319)
-#define __NR_fallocate	(__NR_Linux + 320)
-#define __NR_timerfd_create	(__NR_Linux + 321)
-#define __NR_timerfd_gettime	(__NR_Linux + 322)
-#define __NR_timerfd_settime	(__NR_Linux + 323)
-#define __NR_signalfd4	(__NR_Linux + 324)
-#define __NR_eventfd2	(__NR_Linux + 325)
-#define __NR_epoll_create1	(__NR_Linux + 326)
-#define __NR_dup3	(__NR_Linux + 327)
-#define __NR_pipe2	(__NR_Linux + 328)
-#define __NR_inotify_init1	(__NR_Linux + 329)
-#define __NR_preadv	(__NR_Linux + 330)
-#define __NR_pwritev	(__NR_Linux + 331)
-#define __NR_rt_tgsigqueueinfo	(__NR_Linux + 332)
-#define __NR_perf_event_open	(__NR_Linux + 333)
-#define __NR_accept4	(__NR_Linux + 334)
-#define __NR_recvmmsg	(__NR_Linux + 335)
-#define __NR_fanotify_init	(__NR_Linux + 336)
-#define __NR_fanotify_mark	(__NR_Linux + 337)
-#define __NR_prlimit64	(__NR_Linux + 338)
-#define __NR_name_to_handle_at	(__NR_Linux + 339)
-#define __NR_open_by_handle_at	(__NR_Linux + 340)
-#define __NR_clock_adjtime	(__NR_Linux + 341)
-#define __NR_syncfs	(__NR_Linux + 342)
-#define __NR_sendmmsg	(__NR_Linux + 343)
-#define __NR_setns	(__NR_Linux + 344)
-#define __NR_process_vm_readv	(__NR_Linux + 345)
-#define __NR_process_vm_writev	(__NR_Linux + 346)
-#define __NR_kcmp	(__NR_Linux + 347)
-#define __NR_finit_module	(__NR_Linux + 348)
-#define __NR_sched_setattr	(__NR_Linux + 349)
-#define __NR_sched_getattr	(__NR_Linux + 350)
-#define __NR_renameat2	(__NR_Linux + 351)
-#define __NR_seccomp	(__NR_Linux + 352)
-#define __NR_getrandom	(__NR_Linux + 353)
-#define __NR_memfd_create	(__NR_Linux + 354)
-#define __NR_bpf	(__NR_Linux + 355)
-#define __NR_execveat	(__NR_Linux + 356)
-#define __NR_userfaultfd	(__NR_Linux + 357)
-#define __NR_membarrier	(__NR_Linux + 358)
-#define __NR_mlock2	(__NR_Linux + 359)
-#define __NR_copy_file_range	(__NR_Linux + 360)
-#define __NR_preadv2	(__NR_Linux + 361)
-#define __NR_pwritev2	(__NR_Linux + 362)
-#define __NR_pkey_mprotect	(__NR_Linux + 363)
-#define __NR_pkey_alloc	(__NR_Linux + 364)
-#define __NR_pkey_free	(__NR_Linux + 365)
-#define __NR_statx	(__NR_Linux + 366)
-#define __NR_rseq	(__NR_Linux + 367)
-#define __NR_io_pgetevents	(__NR_Linux + 368)
-#define __NR_semget	(__NR_Linux + 393)
-#define __NR_semctl	(__NR_Linux + 394)
-#define __NR_shmget	(__NR_Linux + 395)
-#define __NR_shmctl	(__NR_Linux + 396)
-#define __NR_shmat	(__NR_Linux + 397)
-#define __NR_shmdt	(__NR_Linux + 398)
-#define __NR_msgget	(__NR_Linux + 399)
-#define __NR_msgsnd	(__NR_Linux + 400)
-#define __NR_msgrcv	(__NR_Linux + 401)
-#define __NR_msgctl	(__NR_Linux + 402)
-#define __NR_clock_gettime64	(__NR_Linux + 403)
-#define __NR_clock_settime64	(__NR_Linux + 404)
-#define __NR_clock_adjtime64	(__NR_Linux + 405)
-#define __NR_clock_getres_time64	(__NR_Linux + 406)
-#define __NR_clock_nanosleep_time64	(__NR_Linux + 407)
-#define __NR_timer_gettime64	(__NR_Linux + 408)
-#define __NR_timer_settime64	(__NR_Linux + 409)
-#define __NR_timerfd_gettime64	(__NR_Linux + 410)
-#define __NR_timerfd_settime64	(__NR_Linux + 411)
-#define __NR_utimensat_time64	(__NR_Linux + 412)
-#define __NR_pselect6_time64	(__NR_Linux + 413)
-#define __NR_ppoll_time64	(__NR_Linux + 414)
-#define __NR_io_pgetevents_time64	(__NR_Linux + 416)
-#define __NR_recvmmsg_time64	(__NR_Linux + 417)
-#define __NR_mq_timedsend_time64	(__NR_Linux + 418)
-#define __NR_mq_timedreceive_time64	(__NR_Linux + 419)
-#define __NR_semtimedop_time64	(__NR_Linux + 420)
-#define __NR_rt_sigtimedwait_time64	(__NR_Linux + 421)
-#define __NR_futex_time64	(__NR_Linux + 422)
-#define __NR_sched_rr_get_interval_time64	(__NR_Linux + 423)
-#define __NR_pidfd_send_signal	(__NR_Linux + 424)
-#define __NR_io_uring_setup	(__NR_Linux + 425)
-#define __NR_io_uring_enter	(__NR_Linux + 426)
-#define __NR_io_uring_register	(__NR_Linux + 427)
-#define __NR_open_tree	(__NR_Linux + 428)
-#define __NR_move_mount	(__NR_Linux + 429)
-#define __NR_fsopen	(__NR_Linux + 430)
-#define __NR_fsconfig	(__NR_Linux + 431)
-#define __NR_fsmount	(__NR_Linux + 432)
-#define __NR_fspick	(__NR_Linux + 433)
-#define __NR_pidfd_open	(__NR_Linux + 434)
-#define __NR_clone3	(__NR_Linux + 435)
-#define __NR_close_range	(__NR_Linux + 436)
-#define __NR_openat2	(__NR_Linux + 437)
-#define __NR_pidfd_getfd	(__NR_Linux + 438)
-#define __NR_faccessat2	(__NR_Linux + 439)
-#define __NR_process_madvise	(__NR_Linux + 440)
-#define __NR_epoll_pwait2	(__NR_Linux + 441)
+#define __NR_syscall (__NR_Linux + 0)
+#define __NR_exit (__NR_Linux + 1)
+#define __NR_fork (__NR_Linux + 2)
+#define __NR_read (__NR_Linux + 3)
+#define __NR_write (__NR_Linux + 4)
+#define __NR_open (__NR_Linux + 5)
+#define __NR_close (__NR_Linux + 6)
+#define __NR_waitpid (__NR_Linux + 7)
+#define __NR_creat (__NR_Linux + 8)
+#define __NR_link (__NR_Linux + 9)
+#define __NR_unlink (__NR_Linux + 10)
+#define __NR_execve (__NR_Linux + 11)
+#define __NR_chdir (__NR_Linux + 12)
+#define __NR_time (__NR_Linux + 13)
+#define __NR_mknod (__NR_Linux + 14)
+#define __NR_chmod (__NR_Linux + 15)
+#define __NR_lchown (__NR_Linux + 16)
+#define __NR_break (__NR_Linux + 17)
+#define __NR_unused18 (__NR_Linux + 18)
+#define __NR_lseek (__NR_Linux + 19)
+#define __NR_getpid (__NR_Linux + 20)
+#define __NR_mount (__NR_Linux + 21)
+#define __NR_umount (__NR_Linux + 22)
+#define __NR_setuid (__NR_Linux + 23)
+#define __NR_getuid (__NR_Linux + 24)
+#define __NR_stime (__NR_Linux + 25)
+#define __NR_ptrace (__NR_Linux + 26)
+#define __NR_alarm (__NR_Linux + 27)
+#define __NR_unused28 (__NR_Linux + 28)
+#define __NR_pause (__NR_Linux + 29)
+#define __NR_utime (__NR_Linux + 30)
+#define __NR_stty (__NR_Linux + 31)
+#define __NR_gtty (__NR_Linux + 32)
+#define __NR_access (__NR_Linux + 33)
+#define __NR_nice (__NR_Linux + 34)
+#define __NR_ftime (__NR_Linux + 35)
+#define __NR_sync (__NR_Linux + 36)
+#define __NR_kill (__NR_Linux + 37)
+#define __NR_rename (__NR_Linux + 38)
+#define __NR_mkdir (__NR_Linux + 39)
+#define __NR_rmdir (__NR_Linux + 40)
+#define __NR_dup (__NR_Linux + 41)
+#define __NR_pipe (__NR_Linux + 42)
+#define __NR_times (__NR_Linux + 43)
+#define __NR_prof (__NR_Linux + 44)
+#define __NR_brk (__NR_Linux + 45)
+#define __NR_setgid (__NR_Linux + 46)
+#define __NR_getgid (__NR_Linux + 47)
+#define __NR_signal (__NR_Linux + 48)
+#define __NR_geteuid (__NR_Linux + 49)
+#define __NR_getegid (__NR_Linux + 50)
+#define __NR_acct (__NR_Linux + 51)
+#define __NR_umount2 (__NR_Linux + 52)
+#define __NR_lock (__NR_Linux + 53)
+#define __NR_ioctl (__NR_Linux + 54)
+#define __NR_fcntl (__NR_Linux + 55)
+#define __NR_mpx (__NR_Linux + 56)
+#define __NR_setpgid (__NR_Linux + 57)
+#define __NR_ulimit (__NR_Linux + 58)
+#define __NR_unused59 (__NR_Linux + 59)
+#define __NR_umask (__NR_Linux + 60)
+#define __NR_chroot (__NR_Linux + 61)
+#define __NR_ustat (__NR_Linux + 62)
+#define __NR_dup2 (__NR_Linux + 63)
+#define __NR_getppid (__NR_Linux + 64)
+#define __NR_getpgrp (__NR_Linux + 65)
+#define __NR_setsid (__NR_Linux + 66)
+#define __NR_sigaction (__NR_Linux + 67)
+#define __NR_sgetmask (__NR_Linux + 68)
+#define __NR_ssetmask (__NR_Linux + 69)
+#define __NR_setreuid (__NR_Linux + 70)
+#define __NR_setregid (__NR_Linux + 71)
+#define __NR_sigsuspend (__NR_Linux + 72)
+#define __NR_sigpending (__NR_Linux + 73)
+#define __NR_sethostname (__NR_Linux + 74)
+#define __NR_setrlimit (__NR_Linux + 75)
+#define __NR_getrlimit (__NR_Linux + 76)
+#define __NR_getrusage (__NR_Linux + 77)
+#define __NR_gettimeofday (__NR_Linux + 78)
+#define __NR_settimeofday (__NR_Linux + 79)
+#define __NR_getgroups (__NR_Linux + 80)
+#define __NR_setgroups (__NR_Linux + 81)
+#define __NR_reserved82 (__NR_Linux + 82)
+#define __NR_symlink (__NR_Linux + 83)
+#define __NR_unused84 (__NR_Linux + 84)
+#define __NR_readlink (__NR_Linux + 85)
+#define __NR_uselib (__NR_Linux + 86)
+#define __NR_swapon (__NR_Linux + 87)
+#define __NR_reboot (__NR_Linux + 88)
+#define __NR_readdir (__NR_Linux + 89)
+#define __NR_mmap (__NR_Linux + 90)
+#define __NR_munmap (__NR_Linux + 91)
+#define __NR_truncate (__NR_Linux + 92)
+#define __NR_ftruncate (__NR_Linux + 93)
+#define __NR_fchmod (__NR_Linux + 94)
+#define __NR_fchown (__NR_Linux + 95)
+#define __NR_getpriority (__NR_Linux + 96)
+#define __NR_setpriority (__NR_Linux + 97)
+#define __NR_profil (__NR_Linux + 98)
+#define __NR_statfs (__NR_Linux + 99)
+#define __NR_fstatfs (__NR_Linux + 100)
+#define __NR_ioperm (__NR_Linux + 101)
+#define __NR_socketcall (__NR_Linux + 102)
+#define __NR_syslog (__NR_Linux + 103)
+#define __NR_setitimer (__NR_Linux + 104)
+#define __NR_getitimer (__NR_Linux + 105)
+#define __NR_stat (__NR_Linux + 106)
+#define __NR_lstat (__NR_Linux + 107)
+#define __NR_fstat (__NR_Linux + 108)
+#define __NR_unused109 (__NR_Linux + 109)
+#define __NR_iopl (__NR_Linux + 110)
+#define __NR_vhangup (__NR_Linux + 111)
+#define __NR_idle (__NR_Linux + 112)
+#define __NR_vm86 (__NR_Linux + 113)
+#define __NR_wait4 (__NR_Linux + 114)
+#define __NR_swapoff (__NR_Linux + 115)
+#define __NR_sysinfo (__NR_Linux + 116)
+#define __NR_ipc (__NR_Linux + 117)
+#define __NR_fsync (__NR_Linux + 118)
+#define __NR_sigreturn (__NR_Linux + 119)
+#define __NR_clone (__NR_Linux + 120)
+#define __NR_setdomainname (__NR_Linux + 121)
+#define __NR_uname (__NR_Linux + 122)
+#define __NR_modify_ldt (__NR_Linux + 123)
+#define __NR_adjtimex (__NR_Linux + 124)
+#define __NR_mprotect (__NR_Linux + 125)
+#define __NR_sigprocmask (__NR_Linux + 126)
+#define __NR_create_module (__NR_Linux + 127)
+#define __NR_init_module (__NR_Linux + 128)
+#define __NR_delete_module (__NR_Linux + 129)
+#define __NR_get_kernel_syms (__NR_Linux + 130)
+#define __NR_quotactl (__NR_Linux + 131)
+#define __NR_getpgid (__NR_Linux + 132)
+#define __NR_fchdir (__NR_Linux + 133)
+#define __NR_bdflush (__NR_Linux + 134)
+#define __NR_sysfs (__NR_Linux + 135)
+#define __NR_personality (__NR_Linux + 136)
+#define __NR_afs_syscall (__NR_Linux + 137)
+#define __NR_setfsuid (__NR_Linux + 138)
+#define __NR_setfsgid (__NR_Linux + 139)
+#define __NR__llseek (__NR_Linux + 140)
+#define __NR_getdents (__NR_Linux + 141)
+#define __NR__newselect (__NR_Linux + 142)
+#define __NR_flock (__NR_Linux + 143)
+#define __NR_msync (__NR_Linux + 144)
+#define __NR_readv (__NR_Linux + 145)
+#define __NR_writev (__NR_Linux + 146)
+#define __NR_cacheflush (__NR_Linux + 147)
+#define __NR_cachectl (__NR_Linux + 148)
+#define __NR_sysmips (__NR_Linux + 149)
+#define __NR_unused150 (__NR_Linux + 150)
+#define __NR_getsid (__NR_Linux + 151)
+#define __NR_fdatasync (__NR_Linux + 152)
+#define __NR__sysctl (__NR_Linux + 153)
+#define __NR_mlock (__NR_Linux + 154)
+#define __NR_munlock (__NR_Linux + 155)
+#define __NR_mlockall (__NR_Linux + 156)
+#define __NR_munlockall (__NR_Linux + 157)
+#define __NR_sched_setparam (__NR_Linux + 158)
+#define __NR_sched_getparam (__NR_Linux + 159)
+#define __NR_sched_setscheduler (__NR_Linux + 160)
+#define __NR_sched_getscheduler (__NR_Linux + 161)
+#define __NR_sched_yield (__NR_Linux + 162)
+#define __NR_sched_get_priority_max (__NR_Linux + 163)
+#define __NR_sched_get_priority_min (__NR_Linux + 164)
+#define __NR_sched_rr_get_interval (__NR_Linux + 165)
+#define __NR_nanosleep (__NR_Linux + 166)
+#define __NR_mremap (__NR_Linux + 167)
+#define __NR_accept (__NR_Linux + 168)
+#define __NR_bind (__NR_Linux + 169)
+#define __NR_connect (__NR_Linux + 170)
+#define __NR_getpeername (__NR_Linux + 171)
+#define __NR_getsockname (__NR_Linux + 172)
+#define __NR_getsockopt (__NR_Linux + 173)
+#define __NR_listen (__NR_Linux + 174)
+#define __NR_recv (__NR_Linux + 175)
+#define __NR_recvfrom (__NR_Linux + 176)
+#define __NR_recvmsg (__NR_Linux + 177)
+#define __NR_send (__NR_Linux + 178)
+#define __NR_sendmsg (__NR_Linux + 179)
+#define __NR_sendto (__NR_Linux + 180)
+#define __NR_setsockopt (__NR_Linux + 181)
+#define __NR_shutdown (__NR_Linux + 182)
+#define __NR_socket (__NR_Linux + 183)
+#define __NR_socketpair (__NR_Linux + 184)
+#define __NR_setresuid (__NR_Linux + 185)
+#define __NR_getresuid (__NR_Linux + 186)
+#define __NR_query_module (__NR_Linux + 187)
+#define __NR_poll (__NR_Linux + 188)
+#define __NR_nfsservctl (__NR_Linux + 189)
+#define __NR_setresgid (__NR_Linux + 190)
+#define __NR_getresgid (__NR_Linux + 191)
+#define __NR_prctl (__NR_Linux + 192)
+#define __NR_rt_sigreturn (__NR_Linux + 193)
+#define __NR_rt_sigaction (__NR_Linux + 194)
+#define __NR_rt_sigprocmask (__NR_Linux + 195)
+#define __NR_rt_sigpending (__NR_Linux + 196)
+#define __NR_rt_sigtimedwait (__NR_Linux + 197)
+#define __NR_rt_sigqueueinfo (__NR_Linux + 198)
+#define __NR_rt_sigsuspend (__NR_Linux + 199)
+#define __NR_pread64 (__NR_Linux + 200)
+#define __NR_pwrite64 (__NR_Linux + 201)
+#define __NR_chown (__NR_Linux + 202)
+#define __NR_getcwd (__NR_Linux + 203)
+#define __NR_capget (__NR_Linux + 204)
+#define __NR_capset (__NR_Linux + 205)
+#define __NR_sigaltstack (__NR_Linux + 206)
+#define __NR_sendfile (__NR_Linux + 207)
+#define __NR_getpmsg (__NR_Linux + 208)
+#define __NR_putpmsg (__NR_Linux + 209)
+#define __NR_mmap2 (__NR_Linux + 210)
+#define __NR_truncate64 (__NR_Linux + 211)
+#define __NR_ftruncate64 (__NR_Linux + 212)
+#define __NR_stat64 (__NR_Linux + 213)
+#define __NR_lstat64 (__NR_Linux + 214)
+#define __NR_fstat64 (__NR_Linux + 215)
+#define __NR_pivot_root (__NR_Linux + 216)
+#define __NR_mincore (__NR_Linux + 217)
+#define __NR_madvise (__NR_Linux + 218)
+#define __NR_getdents64 (__NR_Linux + 219)
+#define __NR_fcntl64 (__NR_Linux + 220)
+#define __NR_reserved221 (__NR_Linux + 221)
+#define __NR_gettid (__NR_Linux + 222)
+#define __NR_readahead (__NR_Linux + 223)
+#define __NR_setxattr (__NR_Linux + 224)
+#define __NR_lsetxattr (__NR_Linux + 225)
+#define __NR_fsetxattr (__NR_Linux + 226)
+#define __NR_getxattr (__NR_Linux + 227)
+#define __NR_lgetxattr (__NR_Linux + 228)
+#define __NR_fgetxattr (__NR_Linux + 229)
+#define __NR_listxattr (__NR_Linux + 230)
+#define __NR_llistxattr (__NR_Linux + 231)
+#define __NR_flistxattr (__NR_Linux + 232)
+#define __NR_removexattr (__NR_Linux + 233)
+#define __NR_lremovexattr (__NR_Linux + 234)
+#define __NR_fremovexattr (__NR_Linux + 235)
+#define __NR_tkill (__NR_Linux + 236)
+#define __NR_sendfile64 (__NR_Linux + 237)
+#define __NR_futex (__NR_Linux + 238)
+#define __NR_sched_setaffinity (__NR_Linux + 239)
+#define __NR_sched_getaffinity (__NR_Linux + 240)
+#define __NR_io_setup (__NR_Linux + 241)
+#define __NR_io_destroy (__NR_Linux + 242)
+#define __NR_io_getevents (__NR_Linux + 243)
+#define __NR_io_submit (__NR_Linux + 244)
+#define __NR_io_cancel (__NR_Linux + 245)
+#define __NR_exit_group (__NR_Linux + 246)
+#define __NR_lookup_dcookie (__NR_Linux + 247)
+#define __NR_epoll_create (__NR_Linux + 248)
+#define __NR_epoll_ctl (__NR_Linux + 249)
+#define __NR_epoll_wait (__NR_Linux + 250)
+#define __NR_remap_file_pages (__NR_Linux + 251)
+#define __NR_set_tid_address (__NR_Linux + 252)
+#define __NR_restart_syscall (__NR_Linux + 253)
+#define __NR_fadvise64 (__NR_Linux + 254)
+#define __NR_statfs64 (__NR_Linux + 255)
+#define __NR_fstatfs64 (__NR_Linux + 256)
+#define __NR_timer_create (__NR_Linux + 257)
+#define __NR_timer_settime (__NR_Linux + 258)
+#define __NR_timer_gettime (__NR_Linux + 259)
+#define __NR_timer_getoverrun (__NR_Linux + 260)
+#define __NR_timer_delete (__NR_Linux + 261)
+#define __NR_clock_settime (__NR_Linux + 262)
+#define __NR_clock_gettime (__NR_Linux + 263)
+#define __NR_clock_getres (__NR_Linux + 264)
+#define __NR_clock_nanosleep (__NR_Linux + 265)
+#define __NR_tgkill (__NR_Linux + 266)
+#define __NR_utimes (__NR_Linux + 267)
+#define __NR_mbind (__NR_Linux + 268)
+#define __NR_get_mempolicy (__NR_Linux + 269)
+#define __NR_set_mempolicy (__NR_Linux + 270)
+#define __NR_mq_open (__NR_Linux + 271)
+#define __NR_mq_unlink (__NR_Linux + 272)
+#define __NR_mq_timedsend (__NR_Linux + 273)
+#define __NR_mq_timedreceive (__NR_Linux + 274)
+#define __NR_mq_notify (__NR_Linux + 275)
+#define __NR_mq_getsetattr (__NR_Linux + 276)
+#define __NR_vserver (__NR_Linux + 277)
+#define __NR_waitid (__NR_Linux + 278)
+#define __NR_add_key (__NR_Linux + 280)
+#define __NR_request_key (__NR_Linux + 281)
+#define __NR_keyctl (__NR_Linux + 282)
+#define __NR_set_thread_area (__NR_Linux + 283)
+#define __NR_inotify_init (__NR_Linux + 284)
+#define __NR_inotify_add_watch (__NR_Linux + 285)
+#define __NR_inotify_rm_watch (__NR_Linux + 286)
+#define __NR_migrate_pages (__NR_Linux + 287)
+#define __NR_openat (__NR_Linux + 288)
+#define __NR_mkdirat (__NR_Linux + 289)
+#define __NR_mknodat (__NR_Linux + 290)
+#define __NR_fchownat (__NR_Linux + 291)
+#define __NR_futimesat (__NR_Linux + 292)
+#define __NR_fstatat64 (__NR_Linux + 293)
+#define __NR_unlinkat (__NR_Linux + 294)
+#define __NR_renameat (__NR_Linux + 295)
+#define __NR_linkat (__NR_Linux + 296)
+#define __NR_symlinkat (__NR_Linux + 297)
+#define __NR_readlinkat (__NR_Linux + 298)
+#define __NR_fchmodat (__NR_Linux + 299)
+#define __NR_faccessat (__NR_Linux + 300)
+#define __NR_pselect6 (__NR_Linux + 301)
+#define __NR_ppoll (__NR_Linux + 302)
+#define __NR_unshare (__NR_Linux + 303)
+#define __NR_splice (__NR_Linux + 304)
+#define __NR_sync_file_range (__NR_Linux + 305)
+#define __NR_tee (__NR_Linux + 306)
+#define __NR_vmsplice (__NR_Linux + 307)
+#define __NR_move_pages (__NR_Linux + 308)
+#define __NR_set_robust_list (__NR_Linux + 309)
+#define __NR_get_robust_list (__NR_Linux + 310)
+#define __NR_kexec_load (__NR_Linux + 311)
+#define __NR_getcpu (__NR_Linux + 312)
+#define __NR_epoll_pwait (__NR_Linux + 313)
+#define __NR_ioprio_set (__NR_Linux + 314)
+#define __NR_ioprio_get (__NR_Linux + 315)
+#define __NR_utimensat (__NR_Linux + 316)
+#define __NR_signalfd (__NR_Linux + 317)
+#define __NR_timerfd (__NR_Linux + 318)
+#define __NR_eventfd (__NR_Linux + 319)
+#define __NR_fallocate (__NR_Linux + 320)
+#define __NR_timerfd_create (__NR_Linux + 321)
+#define __NR_timerfd_gettime (__NR_Linux + 322)
+#define __NR_timerfd_settime (__NR_Linux + 323)
+#define __NR_signalfd4 (__NR_Linux + 324)
+#define __NR_eventfd2 (__NR_Linux + 325)
+#define __NR_epoll_create1 (__NR_Linux + 326)
+#define __NR_dup3 (__NR_Linux + 327)
+#define __NR_pipe2 (__NR_Linux + 328)
+#define __NR_inotify_init1 (__NR_Linux + 329)
+#define __NR_preadv (__NR_Linux + 330)
+#define __NR_pwritev (__NR_Linux + 331)
+#define __NR_rt_tgsigqueueinfo (__NR_Linux + 332)
+#define __NR_perf_event_open (__NR_Linux + 333)
+#define __NR_accept4 (__NR_Linux + 334)
+#define __NR_recvmmsg (__NR_Linux + 335)
+#define __NR_fanotify_init (__NR_Linux + 336)
+#define __NR_fanotify_mark (__NR_Linux + 337)
+#define __NR_prlimit64 (__NR_Linux + 338)
+#define __NR_name_to_handle_at (__NR_Linux + 339)
+#define __NR_open_by_handle_at (__NR_Linux + 340)
+#define __NR_clock_adjtime (__NR_Linux + 341)
+#define __NR_syncfs (__NR_Linux + 342)
+#define __NR_sendmmsg (__NR_Linux + 343)
+#define __NR_setns (__NR_Linux + 344)
+#define __NR_process_vm_readv (__NR_Linux + 345)
+#define __NR_process_vm_writev (__NR_Linux + 346)
+#define __NR_kcmp (__NR_Linux + 347)
+#define __NR_finit_module (__NR_Linux + 348)
+#define __NR_sched_setattr (__NR_Linux + 349)
+#define __NR_sched_getattr (__NR_Linux + 350)
+#define __NR_renameat2 (__NR_Linux + 351)
+#define __NR_seccomp (__NR_Linux + 352)
+#define __NR_getrandom (__NR_Linux + 353)
+#define __NR_memfd_create (__NR_Linux + 354)
+#define __NR_bpf (__NR_Linux + 355)
+#define __NR_execveat (__NR_Linux + 356)
+#define __NR_userfaultfd (__NR_Linux + 357)
+#define __NR_membarrier (__NR_Linux + 358)
+#define __NR_mlock2 (__NR_Linux + 359)
+#define __NR_copy_file_range (__NR_Linux + 360)
+#define __NR_preadv2 (__NR_Linux + 361)
+#define __NR_pwritev2 (__NR_Linux + 362)
+#define __NR_pkey_mprotect (__NR_Linux + 363)
+#define __NR_pkey_alloc (__NR_Linux + 364)
+#define __NR_pkey_free (__NR_Linux + 365)
+#define __NR_statx (__NR_Linux + 366)
+#define __NR_rseq (__NR_Linux + 367)
+#define __NR_io_pgetevents (__NR_Linux + 368)
+#define __NR_semget (__NR_Linux + 393)
+#define __NR_semctl (__NR_Linux + 394)
+#define __NR_shmget (__NR_Linux + 395)
+#define __NR_shmctl (__NR_Linux + 396)
+#define __NR_shmat (__NR_Linux + 397)
+#define __NR_shmdt (__NR_Linux + 398)
+#define __NR_msgget (__NR_Linux + 399)
+#define __NR_msgsnd (__NR_Linux + 400)
+#define __NR_msgrcv (__NR_Linux + 401)
+#define __NR_msgctl (__NR_Linux + 402)
+#define __NR_clock_gettime64 (__NR_Linux + 403)
+#define __NR_clock_settime64 (__NR_Linux + 404)
+#define __NR_clock_adjtime64 (__NR_Linux + 405)
+#define __NR_clock_getres_time64 (__NR_Linux + 406)
+#define __NR_clock_nanosleep_time64 (__NR_Linux + 407)
+#define __NR_timer_gettime64 (__NR_Linux + 408)
+#define __NR_timer_settime64 (__NR_Linux + 409)
+#define __NR_timerfd_gettime64 (__NR_Linux + 410)
+#define __NR_timerfd_settime64 (__NR_Linux + 411)
+#define __NR_utimensat_time64 (__NR_Linux + 412)
+#define __NR_pselect6_time64 (__NR_Linux + 413)
+#define __NR_ppoll_time64 (__NR_Linux + 414)
+#define __NR_io_pgetevents_time64 (__NR_Linux + 416)
+#define __NR_recvmmsg_time64 (__NR_Linux + 417)
+#define __NR_mq_timedsend_time64 (__NR_Linux + 418)
+#define __NR_mq_timedreceive_time64 (__NR_Linux + 419)
+#define __NR_semtimedop_time64 (__NR_Linux + 420)
+#define __NR_rt_sigtimedwait_time64 (__NR_Linux + 421)
+#define __NR_futex_time64 (__NR_Linux + 422)
+#define __NR_sched_rr_get_interval_time64 (__NR_Linux + 423)
+#define __NR_pidfd_send_signal (__NR_Linux + 424)
+#define __NR_io_uring_setup (__NR_Linux + 425)
+#define __NR_io_uring_enter (__NR_Linux + 426)
+#define __NR_io_uring_register (__NR_Linux + 427)
+#define __NR_open_tree (__NR_Linux + 428)
+#define __NR_move_mount (__NR_Linux + 429)
+#define __NR_fsopen (__NR_Linux + 430)
+#define __NR_fsconfig (__NR_Linux + 431)
+#define __NR_fsmount (__NR_Linux + 432)
+#define __NR_fspick (__NR_Linux + 433)
+#define __NR_pidfd_open (__NR_Linux + 434)
+#define __NR_clone3 (__NR_Linux + 435)
+#define __NR_close_range (__NR_Linux + 436)
+#define __NR_openat2 (__NR_Linux + 437)
+#define __NR_pidfd_getfd (__NR_Linux + 438)
+#define __NR_faccessat2 (__NR_Linux + 439)
+#define __NR_process_madvise (__NR_Linux + 440)
+#define __NR_epoll_pwait2 (__NR_Linux + 441)
+#define __NR_mount_setattr (__NR_Linux + 442)
+#define __NR_landlock_create_ruleset (__NR_Linux + 444)
+#define __NR_landlock_add_rule (__NR_Linux + 445)
+#define __NR_landlock_restrict_self (__NR_Linux + 446)
 
-
-#endif /* _ASM_MIPS_UNISTD_O32_H */
+#endif /* _ASM_UNISTD_O32_H */
diff --git a/linux-headers/asm-powerpc/kvm.h b/linux-headers/asm-powerpc/kvm.h
index c3af3f324c..9f18fa090f 100644
--- a/linux-headers/asm-powerpc/kvm.h
+++ b/linux-headers/asm-powerpc/kvm.h
@@ -644,6 +644,8 @@ struct kvm_ppc_cpu_char {
 #define KVM_REG_PPC_MMCR3	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xc1)
 #define KVM_REG_PPC_SIER2	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xc2)
 #define KVM_REG_PPC_SIER3	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xc3)
+#define KVM_REG_PPC_DAWR1	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xc4)
+#define KVM_REG_PPC_DAWRX1	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xc5)
 
 /* Transactional Memory checkpointed state:
  * This is all GPRs, all VSX regs and a subset of SPRs
diff --git a/linux-headers/asm-powerpc/unistd_32.h b/linux-headers/asm-powerpc/unistd_32.h
index 4624c90043..9155778c19 100644
--- a/linux-headers/asm-powerpc/unistd_32.h
+++ b/linux-headers/asm-powerpc/unistd_32.h
@@ -1,429 +1,433 @@
-#ifndef _ASM_POWERPC_UNISTD_32_H
-#define _ASM_POWERPC_UNISTD_32_H
+#ifndef _ASM_UNISTD_32_H
+#define _ASM_UNISTD_32_H
 
-#define __NR_restart_syscall	0
-#define __NR_exit	1
-#define __NR_fork	2
-#define __NR_read	3
-#define __NR_write	4
-#define __NR_open	5
-#define __NR_close	6
-#define __NR_waitpid	7
-#define __NR_creat	8
-#define __NR_link	9
-#define __NR_unlink	10
-#define __NR_execve	11
-#define __NR_chdir	12
-#define __NR_time	13
-#define __NR_mknod	14
-#define __NR_chmod	15
-#define __NR_lchown	16
-#define __NR_break	17
-#define __NR_oldstat	18
-#define __NR_lseek	19
-#define __NR_getpid	20
-#define __NR_mount	21
-#define __NR_umount	22
-#define __NR_setuid	23
-#define __NR_getuid	24
-#define __NR_stime	25
-#define __NR_ptrace	26
-#define __NR_alarm	27
-#define __NR_oldfstat	28
-#define __NR_pause	29
-#define __NR_utime	30
-#define __NR_stty	31
-#define __NR_gtty	32
-#define __NR_access	33
-#define __NR_nice	34
-#define __NR_ftime	35
-#define __NR_sync	36
-#define __NR_kill	37
-#define __NR_rename	38
-#define __NR_mkdir	39
-#define __NR_rmdir	40
-#define __NR_dup	41
-#define __NR_pipe	42
-#define __NR_times	43
-#define __NR_prof	44
-#define __NR_brk	45
-#define __NR_setgid	46
-#define __NR_getgid	47
-#define __NR_signal	48
-#define __NR_geteuid	49
-#define __NR_getegid	50
-#define __NR_acct	51
-#define __NR_umount2	52
-#define __NR_lock	53
-#define __NR_ioctl	54
-#define __NR_fcntl	55
-#define __NR_mpx	56
-#define __NR_setpgid	57
-#define __NR_ulimit	58
-#define __NR_oldolduname	59
-#define __NR_umask	60
-#define __NR_chroot	61
-#define __NR_ustat	62
-#define __NR_dup2	63
-#define __NR_getppid	64
-#define __NR_getpgrp	65
-#define __NR_setsid	66
-#define __NR_sigaction	67
-#define __NR_sgetmask	68
-#define __NR_ssetmask	69
-#define __NR_setreuid	70
-#define __NR_setregid	71
-#define __NR_sigsuspend	72
-#define __NR_sigpending	73
-#define __NR_sethostname	74
-#define __NR_setrlimit	75
-#define __NR_getrlimit	76
-#define __NR_getrusage	77
-#define __NR_gettimeofday	78
-#define __NR_settimeofday	79
-#define __NR_getgroups	80
-#define __NR_setgroups	81
-#define __NR_select	82
-#define __NR_symlink	83
-#define __NR_oldlstat	84
-#define __NR_readlink	85
-#define __NR_uselib	86
-#define __NR_swapon	87
-#define __NR_reboot	88
-#define __NR_readdir	89
-#define __NR_mmap	90
-#define __NR_munmap	91
-#define __NR_truncate	92
-#define __NR_ftruncate	93
-#define __NR_fchmod	94
-#define __NR_fchown	95
-#define __NR_getpriority	96
-#define __NR_setpriority	97
-#define __NR_profil	98
-#define __NR_statfs	99
-#define __NR_fstatfs	100
-#define __NR_ioperm	101
-#define __NR_socketcall	102
-#define __NR_syslog	103
-#define __NR_setitimer	104
-#define __NR_getitimer	105
-#define __NR_stat	106
-#define __NR_lstat	107
-#define __NR_fstat	108
-#define __NR_olduname	109
-#define __NR_iopl	110
-#define __NR_vhangup	111
-#define __NR_idle	112
-#define __NR_vm86	113
-#define __NR_wait4	114
-#define __NR_swapoff	115
-#define __NR_sysinfo	116
-#define __NR_ipc	117
-#define __NR_fsync	118
-#define __NR_sigreturn	119
-#define __NR_clone	120
-#define __NR_setdomainname	121
-#define __NR_uname	122
-#define __NR_modify_ldt	123
-#define __NR_adjtimex	124
-#define __NR_mprotect	125
-#define __NR_sigprocmask	126
-#define __NR_create_module	127
-#define __NR_init_module	128
-#define __NR_delete_module	129
-#define __NR_get_kernel_syms	130
-#define __NR_quotactl	131
-#define __NR_getpgid	132
-#define __NR_fchdir	133
-#define __NR_bdflush	134
-#define __NR_sysfs	135
-#define __NR_personality	136
-#define __NR_afs_syscall	137
-#define __NR_setfsuid	138
-#define __NR_setfsgid	139
-#define __NR__llseek	140
-#define __NR_getdents	141
-#define __NR__newselect	142
-#define __NR_flock	143
-#define __NR_msync	144
-#define __NR_readv	145
-#define __NR_writev	146
-#define __NR_getsid	147
-#define __NR_fdatasync	148
-#define __NR__sysctl	149
-#define __NR_mlock	150
-#define __NR_munlock	151
-#define __NR_mlockall	152
-#define __NR_munlockall	153
-#define __NR_sched_setparam	154
-#define __NR_sched_getparam	155
-#define __NR_sched_setscheduler	156
-#define __NR_sched_getscheduler	157
-#define __NR_sched_yield	158
-#define __NR_sched_get_priority_max	159
-#define __NR_sched_get_priority_min	160
-#define __NR_sched_rr_get_interval	161
-#define __NR_nanosleep	162
-#define __NR_mremap	163
-#define __NR_setresuid	164
-#define __NR_getresuid	165
-#define __NR_query_module	166
-#define __NR_poll	167
-#define __NR_nfsservctl	168
-#define __NR_setresgid	169
-#define __NR_getresgid	170
-#define __NR_prctl	171
-#define __NR_rt_sigreturn	172
-#define __NR_rt_sigaction	173
-#define __NR_rt_sigprocmask	174
-#define __NR_rt_sigpending	175
-#define __NR_rt_sigtimedwait	176
-#define __NR_rt_sigqueueinfo	177
-#define __NR_rt_sigsuspend	178
-#define __NR_pread64	179
-#define __NR_pwrite64	180
-#define __NR_chown	181
-#define __NR_getcwd	182
-#define __NR_capget	183
-#define __NR_capset	184
-#define __NR_sigaltstack	185
-#define __NR_sendfile	186
-#define __NR_getpmsg	187
-#define __NR_putpmsg	188
-#define __NR_vfork	189
-#define __NR_ugetrlimit	190
-#define __NR_readahead	191
-#define __NR_mmap2	192
-#define __NR_truncate64	193
-#define __NR_ftruncate64	194
-#define __NR_stat64	195
-#define __NR_lstat64	196
-#define __NR_fstat64	197
-#define __NR_pciconfig_read	198
-#define __NR_pciconfig_write	199
-#define __NR_pciconfig_iobase	200
-#define __NR_multiplexer	201
-#define __NR_getdents64	202
-#define __NR_pivot_root	203
-#define __NR_fcntl64	204
-#define __NR_madvise	205
-#define __NR_mincore	206
-#define __NR_gettid	207
-#define __NR_tkill	208
-#define __NR_setxattr	209
-#define __NR_lsetxattr	210
-#define __NR_fsetxattr	211
-#define __NR_getxattr	212
-#define __NR_lgetxattr	213
-#define __NR_fgetxattr	214
-#define __NR_listxattr	215
-#define __NR_llistxattr	216
-#define __NR_flistxattr	217
-#define __NR_removexattr	218
-#define __NR_lremovexattr	219
-#define __NR_fremovexattr	220
-#define __NR_futex	221
-#define __NR_sched_setaffinity	222
-#define __NR_sched_getaffinity	223
-#define __NR_tuxcall	225
-#define __NR_sendfile64	226
-#define __NR_io_setup	227
-#define __NR_io_destroy	228
-#define __NR_io_getevents	229
-#define __NR_io_submit	230
-#define __NR_io_cancel	231
-#define __NR_set_tid_address	232
-#define __NR_fadvise64	233
-#define __NR_exit_group	234
-#define __NR_lookup_dcookie	235
-#define __NR_epoll_create	236
-#define __NR_epoll_ctl	237
-#define __NR_epoll_wait	238
-#define __NR_remap_file_pages	239
-#define __NR_timer_create	240
-#define __NR_timer_settime	241
-#define __NR_timer_gettime	242
-#define __NR_timer_getoverrun	243
-#define __NR_timer_delete	244
-#define __NR_clock_settime	245
-#define __NR_clock_gettime	246
-#define __NR_clock_getres	247
-#define __NR_clock_nanosleep	248
-#define __NR_swapcontext	249
-#define __NR_tgkill	250
-#define __NR_utimes	251
-#define __NR_statfs64	252
-#define __NR_fstatfs64	253
-#define __NR_fadvise64_64	254
-#define __NR_rtas	255
-#define __NR_sys_debug_setcontext	256
-#define __NR_migrate_pages	258
-#define __NR_mbind	259
-#define __NR_get_mempolicy	260
-#define __NR_set_mempolicy	261
-#define __NR_mq_open	262
-#define __NR_mq_unlink	263
-#define __NR_mq_timedsend	264
-#define __NR_mq_timedreceive	265
-#define __NR_mq_notify	266
-#define __NR_mq_getsetattr	267
-#define __NR_kexec_load	268
-#define __NR_add_key	269
-#define __NR_request_key	270
-#define __NR_keyctl	271
-#define __NR_waitid	272
-#define __NR_ioprio_set	273
-#define __NR_ioprio_get	274
-#define __NR_inotify_init	275
-#define __NR_inotify_add_watch	276
-#define __NR_inotify_rm_watch	277
-#define __NR_spu_run	278
-#define __NR_spu_create	279
-#define __NR_pselect6	280
-#define __NR_ppoll	281
-#define __NR_unshare	282
-#define __NR_splice	283
-#define __NR_tee	284
-#define __NR_vmsplice	285
-#define __NR_openat	286
-#define __NR_mkdirat	287
-#define __NR_mknodat	288
-#define __NR_fchownat	289
-#define __NR_futimesat	290
-#define __NR_fstatat64	291
-#define __NR_unlinkat	292
-#define __NR_renameat	293
-#define __NR_linkat	294
-#define __NR_symlinkat	295
-#define __NR_readlinkat	296
-#define __NR_fchmodat	297
-#define __NR_faccessat	298
-#define __NR_get_robust_list	299
-#define __NR_set_robust_list	300
-#define __NR_move_pages	301
-#define __NR_getcpu	302
-#define __NR_epoll_pwait	303
-#define __NR_utimensat	304
-#define __NR_signalfd	305
-#define __NR_timerfd_create	306
-#define __NR_eventfd	307
-#define __NR_sync_file_range2	308
-#define __NR_fallocate	309
-#define __NR_subpage_prot	310
-#define __NR_timerfd_settime	311
-#define __NR_timerfd_gettime	312
-#define __NR_signalfd4	313
-#define __NR_eventfd2	314
-#define __NR_epoll_create1	315
-#define __NR_dup3	316
-#define __NR_pipe2	317
-#define __NR_inotify_init1	318
-#define __NR_perf_event_open	319
-#define __NR_preadv	320
-#define __NR_pwritev	321
-#define __NR_rt_tgsigqueueinfo	322
-#define __NR_fanotify_init	323
-#define __NR_fanotify_mark	324
-#define __NR_prlimit64	325
-#define __NR_socket	326
-#define __NR_bind	327
-#define __NR_connect	328
-#define __NR_listen	329
-#define __NR_accept	330
-#define __NR_getsockname	331
-#define __NR_getpeername	332
-#define __NR_socketpair	333
-#define __NR_send	334
-#define __NR_sendto	335
-#define __NR_recv	336
-#define __NR_recvfrom	337
-#define __NR_shutdown	338
-#define __NR_setsockopt	339
-#define __NR_getsockopt	340
-#define __NR_sendmsg	341
-#define __NR_recvmsg	342
-#define __NR_recvmmsg	343
-#define __NR_accept4	344
-#define __NR_name_to_handle_at	345
-#define __NR_open_by_handle_at	346
-#define __NR_clock_adjtime	347
-#define __NR_syncfs	348
-#define __NR_sendmmsg	349
-#define __NR_setns	350
-#define __NR_process_vm_readv	351
-#define __NR_process_vm_writev	352
-#define __NR_finit_module	353
-#define __NR_kcmp	354
-#define __NR_sched_setattr	355
-#define __NR_sched_getattr	356
-#define __NR_renameat2	357
-#define __NR_seccomp	358
-#define __NR_getrandom	359
-#define __NR_memfd_create	360
-#define __NR_bpf	361
-#define __NR_execveat	362
-#define __NR_switch_endian	363
-#define __NR_userfaultfd	364
-#define __NR_membarrier	365
-#define __NR_mlock2	378
-#define __NR_copy_file_range	379
-#define __NR_preadv2	380
-#define __NR_pwritev2	381
-#define __NR_kexec_file_load	382
-#define __NR_statx	383
-#define __NR_pkey_alloc	384
-#define __NR_pkey_free	385
-#define __NR_pkey_mprotect	386
-#define __NR_rseq	387
-#define __NR_io_pgetevents	388
-#define __NR_semget	393
-#define __NR_semctl	394
-#define __NR_shmget	395
-#define __NR_shmctl	396
-#define __NR_shmat	397
-#define __NR_shmdt	398
-#define __NR_msgget	399
-#define __NR_msgsnd	400
-#define __NR_msgrcv	401
-#define __NR_msgctl	402
-#define __NR_clock_gettime64	403
-#define __NR_clock_settime64	404
-#define __NR_clock_adjtime64	405
-#define __NR_clock_getres_time64	406
-#define __NR_clock_nanosleep_time64	407
-#define __NR_timer_gettime64	408
-#define __NR_timer_settime64	409
-#define __NR_timerfd_gettime64	410
-#define __NR_timerfd_settime64	411
-#define __NR_utimensat_time64	412
-#define __NR_pselect6_time64	413
-#define __NR_ppoll_time64	414
-#define __NR_io_pgetevents_time64	416
-#define __NR_recvmmsg_time64	417
-#define __NR_mq_timedsend_time64	418
-#define __NR_mq_timedreceive_time64	419
-#define __NR_semtimedop_time64	420
-#define __NR_rt_sigtimedwait_time64	421
-#define __NR_futex_time64	422
-#define __NR_sched_rr_get_interval_time64	423
-#define __NR_pidfd_send_signal	424
-#define __NR_io_uring_setup	425
-#define __NR_io_uring_enter	426
-#define __NR_io_uring_register	427
-#define __NR_open_tree	428
-#define __NR_move_mount	429
-#define __NR_fsopen	430
-#define __NR_fsconfig	431
-#define __NR_fsmount	432
-#define __NR_fspick	433
-#define __NR_pidfd_open	434
-#define __NR_clone3	435
-#define __NR_close_range	436
-#define __NR_openat2	437
-#define __NR_pidfd_getfd	438
-#define __NR_faccessat2	439
-#define __NR_process_madvise	440
-#define __NR_epoll_pwait2	441
+#define __NR_restart_syscall 0
+#define __NR_exit 1
+#define __NR_fork 2
+#define __NR_read 3
+#define __NR_write 4
+#define __NR_open 5
+#define __NR_close 6
+#define __NR_waitpid 7
+#define __NR_creat 8
+#define __NR_link 9
+#define __NR_unlink 10
+#define __NR_execve 11
+#define __NR_chdir 12
+#define __NR_time 13
+#define __NR_mknod 14
+#define __NR_chmod 15
+#define __NR_lchown 16
+#define __NR_break 17
+#define __NR_oldstat 18
+#define __NR_lseek 19
+#define __NR_getpid 20
+#define __NR_mount 21
+#define __NR_umount 22
+#define __NR_setuid 23
+#define __NR_getuid 24
+#define __NR_stime 25
+#define __NR_ptrace 26
+#define __NR_alarm 27
+#define __NR_oldfstat 28
+#define __NR_pause 29
+#define __NR_utime 30
+#define __NR_stty 31
+#define __NR_gtty 32
+#define __NR_access 33
+#define __NR_nice 34
+#define __NR_ftime 35
+#define __NR_sync 36
+#define __NR_kill 37
+#define __NR_rename 38
+#define __NR_mkdir 39
+#define __NR_rmdir 40
+#define __NR_dup 41
+#define __NR_pipe 42
+#define __NR_times 43
+#define __NR_prof 44
+#define __NR_brk 45
+#define __NR_setgid 46
+#define __NR_getgid 47
+#define __NR_signal 48
+#define __NR_geteuid 49
+#define __NR_getegid 50
+#define __NR_acct 51
+#define __NR_umount2 52
+#define __NR_lock 53
+#define __NR_ioctl 54
+#define __NR_fcntl 55
+#define __NR_mpx 56
+#define __NR_setpgid 57
+#define __NR_ulimit 58
+#define __NR_oldolduname 59
+#define __NR_umask 60
+#define __NR_chroot 61
+#define __NR_ustat 62
+#define __NR_dup2 63
+#define __NR_getppid 64
+#define __NR_getpgrp 65
+#define __NR_setsid 66
+#define __NR_sigaction 67
+#define __NR_sgetmask 68
+#define __NR_ssetmask 69
+#define __NR_setreuid 70
+#define __NR_setregid 71
+#define __NR_sigsuspend 72
+#define __NR_sigpending 73
+#define __NR_sethostname 74
+#define __NR_setrlimit 75
+#define __NR_getrlimit 76
+#define __NR_getrusage 77
+#define __NR_gettimeofday 78
+#define __NR_settimeofday 79
+#define __NR_getgroups 80
+#define __NR_setgroups 81
+#define __NR_select 82
+#define __NR_symlink 83
+#define __NR_oldlstat 84
+#define __NR_readlink 85
+#define __NR_uselib 86
+#define __NR_swapon 87
+#define __NR_reboot 88
+#define __NR_readdir 89
+#define __NR_mmap 90
+#define __NR_munmap 91
+#define __NR_truncate 92
+#define __NR_ftruncate 93
+#define __NR_fchmod 94
+#define __NR_fchown 95
+#define __NR_getpriority 96
+#define __NR_setpriority 97
+#define __NR_profil 98
+#define __NR_statfs 99
+#define __NR_fstatfs 100
+#define __NR_ioperm 101
+#define __NR_socketcall 102
+#define __NR_syslog 103
+#define __NR_setitimer 104
+#define __NR_getitimer 105
+#define __NR_stat 106
+#define __NR_lstat 107
+#define __NR_fstat 108
+#define __NR_olduname 109
+#define __NR_iopl 110
+#define __NR_vhangup 111
+#define __NR_idle 112
+#define __NR_vm86 113
+#define __NR_wait4 114
+#define __NR_swapoff 115
+#define __NR_sysinfo 116
+#define __NR_ipc 117
+#define __NR_fsync 118
+#define __NR_sigreturn 119
+#define __NR_clone 120
+#define __NR_setdomainname 121
+#define __NR_uname 122
+#define __NR_modify_ldt 123
+#define __NR_adjtimex 124
+#define __NR_mprotect 125
+#define __NR_sigprocmask 126
+#define __NR_create_module 127
+#define __NR_init_module 128
+#define __NR_delete_module 129
+#define __NR_get_kernel_syms 130
+#define __NR_quotactl 131
+#define __NR_getpgid 132
+#define __NR_fchdir 133
+#define __NR_bdflush 134
+#define __NR_sysfs 135
+#define __NR_personality 136
+#define __NR_afs_syscall 137
+#define __NR_setfsuid 138
+#define __NR_setfsgid 139
+#define __NR__llseek 140
+#define __NR_getdents 141
+#define __NR__newselect 142
+#define __NR_flock 143
+#define __NR_msync 144
+#define __NR_readv 145
+#define __NR_writev 146
+#define __NR_getsid 147
+#define __NR_fdatasync 148
+#define __NR__sysctl 149
+#define __NR_mlock 150
+#define __NR_munlock 151
+#define __NR_mlockall 152
+#define __NR_munlockall 153
+#define __NR_sched_setparam 154
+#define __NR_sched_getparam 155
+#define __NR_sched_setscheduler 156
+#define __NR_sched_getscheduler 157
+#define __NR_sched_yield 158
+#define __NR_sched_get_priority_max 159
+#define __NR_sched_get_priority_min 160
+#define __NR_sched_rr_get_interval 161
+#define __NR_nanosleep 162
+#define __NR_mremap 163
+#define __NR_setresuid 164
+#define __NR_getresuid 165
+#define __NR_query_module 166
+#define __NR_poll 167
+#define __NR_nfsservctl 168
+#define __NR_setresgid 169
+#define __NR_getresgid 170
+#define __NR_prctl 171
+#define __NR_rt_sigreturn 172
+#define __NR_rt_sigaction 173
+#define __NR_rt_sigprocmask 174
+#define __NR_rt_sigpending 175
+#define __NR_rt_sigtimedwait 176
+#define __NR_rt_sigqueueinfo 177
+#define __NR_rt_sigsuspend 178
+#define __NR_pread64 179
+#define __NR_pwrite64 180
+#define __NR_chown 181
+#define __NR_getcwd 182
+#define __NR_capget 183
+#define __NR_capset 184
+#define __NR_sigaltstack 185
+#define __NR_sendfile 186
+#define __NR_getpmsg 187
+#define __NR_putpmsg 188
+#define __NR_vfork 189
+#define __NR_ugetrlimit 190
+#define __NR_readahead 191
+#define __NR_mmap2 192
+#define __NR_truncate64 193
+#define __NR_ftruncate64 194
+#define __NR_stat64 195
+#define __NR_lstat64 196
+#define __NR_fstat64 197
+#define __NR_pciconfig_read 198
+#define __NR_pciconfig_write 199
+#define __NR_pciconfig_iobase 200
+#define __NR_multiplexer 201
+#define __NR_getdents64 202
+#define __NR_pivot_root 203
+#define __NR_fcntl64 204
+#define __NR_madvise 205
+#define __NR_mincore 206
+#define __NR_gettid 207
+#define __NR_tkill 208
+#define __NR_setxattr 209
+#define __NR_lsetxattr 210
+#define __NR_fsetxattr 211
+#define __NR_getxattr 212
+#define __NR_lgetxattr 213
+#define __NR_fgetxattr 214
+#define __NR_listxattr 215
+#define __NR_llistxattr 216
+#define __NR_flistxattr 217
+#define __NR_removexattr 218
+#define __NR_lremovexattr 219
+#define __NR_fremovexattr 220
+#define __NR_futex 221
+#define __NR_sched_setaffinity 222
+#define __NR_sched_getaffinity 223
+#define __NR_tuxcall 225
+#define __NR_sendfile64 226
+#define __NR_io_setup 227
+#define __NR_io_destroy 228
+#define __NR_io_getevents 229
+#define __NR_io_submit 230
+#define __NR_io_cancel 231
+#define __NR_set_tid_address 232
+#define __NR_fadvise64 233
+#define __NR_exit_group 234
+#define __NR_lookup_dcookie 235
+#define __NR_epoll_create 236
+#define __NR_epoll_ctl 237
+#define __NR_epoll_wait 238
+#define __NR_remap_file_pages 239
+#define __NR_timer_create 240
+#define __NR_timer_settime 241
+#define __NR_timer_gettime 242
+#define __NR_timer_getoverrun 243
+#define __NR_timer_delete 244
+#define __NR_clock_settime 245
+#define __NR_clock_gettime 246
+#define __NR_clock_getres 247
+#define __NR_clock_nanosleep 248
+#define __NR_swapcontext 249
+#define __NR_tgkill 250
+#define __NR_utimes 251
+#define __NR_statfs64 252
+#define __NR_fstatfs64 253
+#define __NR_fadvise64_64 254
+#define __NR_rtas 255
+#define __NR_sys_debug_setcontext 256
+#define __NR_migrate_pages 258
+#define __NR_mbind 259
+#define __NR_get_mempolicy 260
+#define __NR_set_mempolicy 261
+#define __NR_mq_open 262
+#define __NR_mq_unlink 263
+#define __NR_mq_timedsend 264
+#define __NR_mq_timedreceive 265
+#define __NR_mq_notify 266
+#define __NR_mq_getsetattr 267
+#define __NR_kexec_load 268
+#define __NR_add_key 269
+#define __NR_request_key 270
+#define __NR_keyctl 271
+#define __NR_waitid 272
+#define __NR_ioprio_set 273
+#define __NR_ioprio_get 274
+#define __NR_inotify_init 275
+#define __NR_inotify_add_watch 276
+#define __NR_inotify_rm_watch 277
+#define __NR_spu_run 278
+#define __NR_spu_create 279
+#define __NR_pselect6 280
+#define __NR_ppoll 281
+#define __NR_unshare 282
+#define __NR_splice 283
+#define __NR_tee 284
+#define __NR_vmsplice 285
+#define __NR_openat 286
+#define __NR_mkdirat 287
+#define __NR_mknodat 288
+#define __NR_fchownat 289
+#define __NR_futimesat 290
+#define __NR_fstatat64 291
+#define __NR_unlinkat 292
+#define __NR_renameat 293
+#define __NR_linkat 294
+#define __NR_symlinkat 295
+#define __NR_readlinkat 296
+#define __NR_fchmodat 297
+#define __NR_faccessat 298
+#define __NR_get_robust_list 299
+#define __NR_set_robust_list 300
+#define __NR_move_pages 301
+#define __NR_getcpu 302
+#define __NR_epoll_pwait 303
+#define __NR_utimensat 304
+#define __NR_signalfd 305
+#define __NR_timerfd_create 306
+#define __NR_eventfd 307
+#define __NR_sync_file_range2 308
+#define __NR_fallocate 309
+#define __NR_subpage_prot 310
+#define __NR_timerfd_settime 311
+#define __NR_timerfd_gettime 312
+#define __NR_signalfd4 313
+#define __NR_eventfd2 314
+#define __NR_epoll_create1 315
+#define __NR_dup3 316
+#define __NR_pipe2 317
+#define __NR_inotify_init1 318
+#define __NR_perf_event_open 319
+#define __NR_preadv 320
+#define __NR_pwritev 321
+#define __NR_rt_tgsigqueueinfo 322
+#define __NR_fanotify_init 323
+#define __NR_fanotify_mark 324
+#define __NR_prlimit64 325
+#define __NR_socket 326
+#define __NR_bind 327
+#define __NR_connect 328
+#define __NR_listen 329
+#define __NR_accept 330
+#define __NR_getsockname 331
+#define __NR_getpeername 332
+#define __NR_socketpair 333
+#define __NR_send 334
+#define __NR_sendto 335
+#define __NR_recv 336
+#define __NR_recvfrom 337
+#define __NR_shutdown 338
+#define __NR_setsockopt 339
+#define __NR_getsockopt 340
+#define __NR_sendmsg 341
+#define __NR_recvmsg 342
+#define __NR_recvmmsg 343
+#define __NR_accept4 344
+#define __NR_name_to_handle_at 345
+#define __NR_open_by_handle_at 346
+#define __NR_clock_adjtime 347
+#define __NR_syncfs 348
+#define __NR_sendmmsg 349
+#define __NR_setns 350
+#define __NR_process_vm_readv 351
+#define __NR_process_vm_writev 352
+#define __NR_finit_module 353
+#define __NR_kcmp 354
+#define __NR_sched_setattr 355
+#define __NR_sched_getattr 356
+#define __NR_renameat2 357
+#define __NR_seccomp 358
+#define __NR_getrandom 359
+#define __NR_memfd_create 360
+#define __NR_bpf 361
+#define __NR_execveat 362
+#define __NR_switch_endian 363
+#define __NR_userfaultfd 364
+#define __NR_membarrier 365
+#define __NR_mlock2 378
+#define __NR_copy_file_range 379
+#define __NR_preadv2 380
+#define __NR_pwritev2 381
+#define __NR_kexec_file_load 382
+#define __NR_statx 383
+#define __NR_pkey_alloc 384
+#define __NR_pkey_free 385
+#define __NR_pkey_mprotect 386
+#define __NR_rseq 387
+#define __NR_io_pgetevents 388
+#define __NR_semget 393
+#define __NR_semctl 394
+#define __NR_shmget 395
+#define __NR_shmctl 396
+#define __NR_shmat 397
+#define __NR_shmdt 398
+#define __NR_msgget 399
+#define __NR_msgsnd 400
+#define __NR_msgrcv 401
+#define __NR_msgctl 402
+#define __NR_clock_gettime64 403
+#define __NR_clock_settime64 404
+#define __NR_clock_adjtime64 405
+#define __NR_clock_getres_time64 406
+#define __NR_clock_nanosleep_time64 407
+#define __NR_timer_gettime64 408
+#define __NR_timer_settime64 409
+#define __NR_timerfd_gettime64 410
+#define __NR_timerfd_settime64 411
+#define __NR_utimensat_time64 412
+#define __NR_pselect6_time64 413
+#define __NR_ppoll_time64 414
+#define __NR_io_pgetevents_time64 416
+#define __NR_recvmmsg_time64 417
+#define __NR_mq_timedsend_time64 418
+#define __NR_mq_timedreceive_time64 419
+#define __NR_semtimedop_time64 420
+#define __NR_rt_sigtimedwait_time64 421
+#define __NR_futex_time64 422
+#define __NR_sched_rr_get_interval_time64 423
+#define __NR_pidfd_send_signal 424
+#define __NR_io_uring_setup 425
+#define __NR_io_uring_enter 426
+#define __NR_io_uring_register 427
+#define __NR_open_tree 428
+#define __NR_move_mount 429
+#define __NR_fsopen 430
+#define __NR_fsconfig 431
+#define __NR_fsmount 432
+#define __NR_fspick 433
+#define __NR_pidfd_open 434
+#define __NR_clone3 435
+#define __NR_close_range 436
+#define __NR_openat2 437
+#define __NR_pidfd_getfd 438
+#define __NR_faccessat2 439
+#define __NR_process_madvise 440
+#define __NR_epoll_pwait2 441
+#define __NR_mount_setattr 442
+#define __NR_landlock_create_ruleset 444
+#define __NR_landlock_add_rule 445
+#define __NR_landlock_restrict_self 446
 
 
-#endif /* _ASM_POWERPC_UNISTD_32_H */
+#endif /* _ASM_UNISTD_32_H */
diff --git a/linux-headers/asm-powerpc/unistd_64.h b/linux-headers/asm-powerpc/unistd_64.h
index 7e851b30bb..3cefa88932 100644
--- a/linux-headers/asm-powerpc/unistd_64.h
+++ b/linux-headers/asm-powerpc/unistd_64.h
@@ -1,401 +1,405 @@
-#ifndef _ASM_POWERPC_UNISTD_64_H
-#define _ASM_POWERPC_UNISTD_64_H
+#ifndef _ASM_UNISTD_64_H
+#define _ASM_UNISTD_64_H
 
-#define __NR_restart_syscall	0
-#define __NR_exit	1
-#define __NR_fork	2
-#define __NR_read	3
-#define __NR_write	4
-#define __NR_open	5
-#define __NR_close	6
-#define __NR_waitpid	7
-#define __NR_creat	8
-#define __NR_link	9
-#define __NR_unlink	10
-#define __NR_execve	11
-#define __NR_chdir	12
-#define __NR_time	13
-#define __NR_mknod	14
-#define __NR_chmod	15
-#define __NR_lchown	16
-#define __NR_break	17
-#define __NR_oldstat	18
-#define __NR_lseek	19
-#define __NR_getpid	20
-#define __NR_mount	21
-#define __NR_umount	22
-#define __NR_setuid	23
-#define __NR_getuid	24
-#define __NR_stime	25
-#define __NR_ptrace	26
-#define __NR_alarm	27
-#define __NR_oldfstat	28
-#define __NR_pause	29
-#define __NR_utime	30
-#define __NR_stty	31
-#define __NR_gtty	32
-#define __NR_access	33
-#define __NR_nice	34
-#define __NR_ftime	35
-#define __NR_sync	36
-#define __NR_kill	37
-#define __NR_rename	38
-#define __NR_mkdir	39
-#define __NR_rmdir	40
-#define __NR_dup	41
-#define __NR_pipe	42
-#define __NR_times	43
-#define __NR_prof	44
-#define __NR_brk	45
-#define __NR_setgid	46
-#define __NR_getgid	47
-#define __NR_signal	48
-#define __NR_geteuid	49
-#define __NR_getegid	50
-#define __NR_acct	51
-#define __NR_umount2	52
-#define __NR_lock	53
-#define __NR_ioctl	54
-#define __NR_fcntl	55
-#define __NR_mpx	56
-#define __NR_setpgid	57
-#define __NR_ulimit	58
-#define __NR_oldolduname	59
-#define __NR_umask	60
-#define __NR_chroot	61
-#define __NR_ustat	62
-#define __NR_dup2	63
-#define __NR_getppid	64
-#define __NR_getpgrp	65
-#define __NR_setsid	66
-#define __NR_sigaction	67
-#define __NR_sgetmask	68
-#define __NR_ssetmask	69
-#define __NR_setreuid	70
-#define __NR_setregid	71
-#define __NR_sigsuspend	72
-#define __NR_sigpending	73
-#define __NR_sethostname	74
-#define __NR_setrlimit	75
-#define __NR_getrlimit	76
-#define __NR_getrusage	77
-#define __NR_gettimeofday	78
-#define __NR_settimeofday	79
-#define __NR_getgroups	80
-#define __NR_setgroups	81
-#define __NR_select	82
-#define __NR_symlink	83
-#define __NR_oldlstat	84
-#define __NR_readlink	85
-#define __NR_uselib	86
-#define __NR_swapon	87
-#define __NR_reboot	88
-#define __NR_readdir	89
-#define __NR_mmap	90
-#define __NR_munmap	91
-#define __NR_truncate	92
-#define __NR_ftruncate	93
-#define __NR_fchmod	94
-#define __NR_fchown	95
-#define __NR_getpriority	96
-#define __NR_setpriority	97
-#define __NR_profil	98
-#define __NR_statfs	99
-#define __NR_fstatfs	100
-#define __NR_ioperm	101
-#define __NR_socketcall	102
-#define __NR_syslog	103
-#define __NR_setitimer	104
-#define __NR_getitimer	105
-#define __NR_stat	106
-#define __NR_lstat	107
-#define __NR_fstat	108
-#define __NR_olduname	109
-#define __NR_iopl	110
-#define __NR_vhangup	111
-#define __NR_idle	112
-#define __NR_vm86	113
-#define __NR_wait4	114
-#define __NR_swapoff	115
-#define __NR_sysinfo	116
-#define __NR_ipc	117
-#define __NR_fsync	118
-#define __NR_sigreturn	119
-#define __NR_clone	120
-#define __NR_setdomainname	121
-#define __NR_uname	122
-#define __NR_modify_ldt	123
-#define __NR_adjtimex	124
-#define __NR_mprotect	125
-#define __NR_sigprocmask	126
-#define __NR_create_module	127
-#define __NR_init_module	128
-#define __NR_delete_module	129
-#define __NR_get_kernel_syms	130
-#define __NR_quotactl	131
-#define __NR_getpgid	132
-#define __NR_fchdir	133
-#define __NR_bdflush	134
-#define __NR_sysfs	135
-#define __NR_personality	136
-#define __NR_afs_syscall	137
-#define __NR_setfsuid	138
-#define __NR_setfsgid	139
-#define __NR__llseek	140
-#define __NR_getdents	141
-#define __NR__newselect	142
-#define __NR_flock	143
-#define __NR_msync	144
-#define __NR_readv	145
-#define __NR_writev	146
-#define __NR_getsid	147
-#define __NR_fdatasync	148
-#define __NR__sysctl	149
-#define __NR_mlock	150
-#define __NR_munlock	151
-#define __NR_mlockall	152
-#define __NR_munlockall	153
-#define __NR_sched_setparam	154
-#define __NR_sched_getparam	155
-#define __NR_sched_setscheduler	156
-#define __NR_sched_getscheduler	157
-#define __NR_sched_yield	158
-#define __NR_sched_get_priority_max	159
-#define __NR_sched_get_priority_min	160
-#define __NR_sched_rr_get_interval	161
-#define __NR_nanosleep	162
-#define __NR_mremap	163
-#define __NR_setresuid	164
-#define __NR_getresuid	165
-#define __NR_query_module	166
-#define __NR_poll	167
-#define __NR_nfsservctl	168
-#define __NR_setresgid	169
-#define __NR_getresgid	170
-#define __NR_prctl	171
-#define __NR_rt_sigreturn	172
-#define __NR_rt_sigaction	173
-#define __NR_rt_sigprocmask	174
-#define __NR_rt_sigpending	175
-#define __NR_rt_sigtimedwait	176
-#define __NR_rt_sigqueueinfo	177
-#define __NR_rt_sigsuspend	178
-#define __NR_pread64	179
-#define __NR_pwrite64	180
-#define __NR_chown	181
-#define __NR_getcwd	182
-#define __NR_capget	183
-#define __NR_capset	184
-#define __NR_sigaltstack	185
-#define __NR_sendfile	186
-#define __NR_getpmsg	187
-#define __NR_putpmsg	188
-#define __NR_vfork	189
-#define __NR_ugetrlimit	190
-#define __NR_readahead	191
-#define __NR_pciconfig_read	198
-#define __NR_pciconfig_write	199
-#define __NR_pciconfig_iobase	200
-#define __NR_multiplexer	201
-#define __NR_getdents64	202
-#define __NR_pivot_root	203
-#define __NR_madvise	205
-#define __NR_mincore	206
-#define __NR_gettid	207
-#define __NR_tkill	208
-#define __NR_setxattr	209
-#define __NR_lsetxattr	210
-#define __NR_fsetxattr	211
-#define __NR_getxattr	212
-#define __NR_lgetxattr	213
-#define __NR_fgetxattr	214
-#define __NR_listxattr	215
-#define __NR_llistxattr	216
-#define __NR_flistxattr	217
-#define __NR_removexattr	218
-#define __NR_lremovexattr	219
-#define __NR_fremovexattr	220
-#define __NR_futex	221
-#define __NR_sched_setaffinity	222
-#define __NR_sched_getaffinity	223
-#define __NR_tuxcall	225
-#define __NR_io_setup	227
-#define __NR_io_destroy	228
-#define __NR_io_getevents	229
-#define __NR_io_submit	230
-#define __NR_io_cancel	231
-#define __NR_set_tid_address	232
-#define __NR_fadvise64	233
-#define __NR_exit_group	234
-#define __NR_lookup_dcookie	235
-#define __NR_epoll_create	236
-#define __NR_epoll_ctl	237
-#define __NR_epoll_wait	238
-#define __NR_remap_file_pages	239
-#define __NR_timer_create	240
-#define __NR_timer_settime	241
-#define __NR_timer_gettime	242
-#define __NR_timer_getoverrun	243
-#define __NR_timer_delete	244
-#define __NR_clock_settime	245
-#define __NR_clock_gettime	246
-#define __NR_clock_getres	247
-#define __NR_clock_nanosleep	248
-#define __NR_swapcontext	249
-#define __NR_tgkill	250
-#define __NR_utimes	251
-#define __NR_statfs64	252
-#define __NR_fstatfs64	253
-#define __NR_rtas	255
-#define __NR_sys_debug_setcontext	256
-#define __NR_migrate_pages	258
-#define __NR_mbind	259
-#define __NR_get_mempolicy	260
-#define __NR_set_mempolicy	261
-#define __NR_mq_open	262
-#define __NR_mq_unlink	263
-#define __NR_mq_timedsend	264
-#define __NR_mq_timedreceive	265
-#define __NR_mq_notify	266
-#define __NR_mq_getsetattr	267
-#define __NR_kexec_load	268
-#define __NR_add_key	269
-#define __NR_request_key	270
-#define __NR_keyctl	271
-#define __NR_waitid	272
-#define __NR_ioprio_set	273
-#define __NR_ioprio_get	274
-#define __NR_inotify_init	275
-#define __NR_inotify_add_watch	276
-#define __NR_inotify_rm_watch	277
-#define __NR_spu_run	278
-#define __NR_spu_create	279
-#define __NR_pselect6	280
-#define __NR_ppoll	281
-#define __NR_unshare	282
-#define __NR_splice	283
-#define __NR_tee	284
-#define __NR_vmsplice	285
-#define __NR_openat	286
-#define __NR_mkdirat	287
-#define __NR_mknodat	288
-#define __NR_fchownat	289
-#define __NR_futimesat	290
-#define __NR_newfstatat	291
-#define __NR_unlinkat	292
-#define __NR_renameat	293
-#define __NR_linkat	294
-#define __NR_symlinkat	295
-#define __NR_readlinkat	296
-#define __NR_fchmodat	297
-#define __NR_faccessat	298
-#define __NR_get_robust_list	299
-#define __NR_set_robust_list	300
-#define __NR_move_pages	301
-#define __NR_getcpu	302
-#define __NR_epoll_pwait	303
-#define __NR_utimensat	304
-#define __NR_signalfd	305
-#define __NR_timerfd_create	306
-#define __NR_eventfd	307
-#define __NR_sync_file_range2	308
-#define __NR_fallocate	309
-#define __NR_subpage_prot	310
-#define __NR_timerfd_settime	311
-#define __NR_timerfd_gettime	312
-#define __NR_signalfd4	313
-#define __NR_eventfd2	314
-#define __NR_epoll_create1	315
-#define __NR_dup3	316
-#define __NR_pipe2	317
-#define __NR_inotify_init1	318
-#define __NR_perf_event_open	319
-#define __NR_preadv	320
-#define __NR_pwritev	321
-#define __NR_rt_tgsigqueueinfo	322
-#define __NR_fanotify_init	323
-#define __NR_fanotify_mark	324
-#define __NR_prlimit64	325
-#define __NR_socket	326
-#define __NR_bind	327
-#define __NR_connect	328
-#define __NR_listen	329
-#define __NR_accept	330
-#define __NR_getsockname	331
-#define __NR_getpeername	332
-#define __NR_socketpair	333
-#define __NR_send	334
-#define __NR_sendto	335
-#define __NR_recv	336
-#define __NR_recvfrom	337
-#define __NR_shutdown	338
-#define __NR_setsockopt	339
-#define __NR_getsockopt	340
-#define __NR_sendmsg	341
-#define __NR_recvmsg	342
-#define __NR_recvmmsg	343
-#define __NR_accept4	344
-#define __NR_name_to_handle_at	345
-#define __NR_open_by_handle_at	346
-#define __NR_clock_adjtime	347
-#define __NR_syncfs	348
-#define __NR_sendmmsg	349
-#define __NR_setns	350
-#define __NR_process_vm_readv	351
-#define __NR_process_vm_writev	352
-#define __NR_finit_module	353
-#define __NR_kcmp	354
-#define __NR_sched_setattr	355
-#define __NR_sched_getattr	356
-#define __NR_renameat2	357
-#define __NR_seccomp	358
-#define __NR_getrandom	359
-#define __NR_memfd_create	360
-#define __NR_bpf	361
-#define __NR_execveat	362
-#define __NR_switch_endian	363
-#define __NR_userfaultfd	364
-#define __NR_membarrier	365
-#define __NR_mlock2	378
-#define __NR_copy_file_range	379
-#define __NR_preadv2	380
-#define __NR_pwritev2	381
-#define __NR_kexec_file_load	382
-#define __NR_statx	383
-#define __NR_pkey_alloc	384
-#define __NR_pkey_free	385
-#define __NR_pkey_mprotect	386
-#define __NR_rseq	387
-#define __NR_io_pgetevents	388
-#define __NR_semtimedop	392
-#define __NR_semget	393
-#define __NR_semctl	394
-#define __NR_shmget	395
-#define __NR_shmctl	396
-#define __NR_shmat	397
-#define __NR_shmdt	398
-#define __NR_msgget	399
-#define __NR_msgsnd	400
-#define __NR_msgrcv	401
-#define __NR_msgctl	402
-#define __NR_pidfd_send_signal	424
-#define __NR_io_uring_setup	425
-#define __NR_io_uring_enter	426
-#define __NR_io_uring_register	427
-#define __NR_open_tree	428
-#define __NR_move_mount	429
-#define __NR_fsopen	430
-#define __NR_fsconfig	431
-#define __NR_fsmount	432
-#define __NR_fspick	433
-#define __NR_pidfd_open	434
-#define __NR_clone3	435
-#define __NR_close_range	436
-#define __NR_openat2	437
-#define __NR_pidfd_getfd	438
-#define __NR_faccessat2	439
-#define __NR_process_madvise	440
-#define __NR_epoll_pwait2	441
+#define __NR_restart_syscall 0
+#define __NR_exit 1
+#define __NR_fork 2
+#define __NR_read 3
+#define __NR_write 4
+#define __NR_open 5
+#define __NR_close 6
+#define __NR_waitpid 7
+#define __NR_creat 8
+#define __NR_link 9
+#define __NR_unlink 10
+#define __NR_execve 11
+#define __NR_chdir 12
+#define __NR_time 13
+#define __NR_mknod 14
+#define __NR_chmod 15
+#define __NR_lchown 16
+#define __NR_break 17
+#define __NR_oldstat 18
+#define __NR_lseek 19
+#define __NR_getpid 20
+#define __NR_mount 21
+#define __NR_umount 22
+#define __NR_setuid 23
+#define __NR_getuid 24
+#define __NR_stime 25
+#define __NR_ptrace 26
+#define __NR_alarm 27
+#define __NR_oldfstat 28
+#define __NR_pause 29
+#define __NR_utime 30
+#define __NR_stty 31
+#define __NR_gtty 32
+#define __NR_access 33
+#define __NR_nice 34
+#define __NR_ftime 35
+#define __NR_sync 36
+#define __NR_kill 37
+#define __NR_rename 38
+#define __NR_mkdir 39
+#define __NR_rmdir 40
+#define __NR_dup 41
+#define __NR_pipe 42
+#define __NR_times 43
+#define __NR_prof 44
+#define __NR_brk 45
+#define __NR_setgid 46
+#define __NR_getgid 47
+#define __NR_signal 48
+#define __NR_geteuid 49
+#define __NR_getegid 50
+#define __NR_acct 51
+#define __NR_umount2 52
+#define __NR_lock 53
+#define __NR_ioctl 54
+#define __NR_fcntl 55
+#define __NR_mpx 56
+#define __NR_setpgid 57
+#define __NR_ulimit 58
+#define __NR_oldolduname 59
+#define __NR_umask 60
+#define __NR_chroot 61
+#define __NR_ustat 62
+#define __NR_dup2 63
+#define __NR_getppid 64
+#define __NR_getpgrp 65
+#define __NR_setsid 66
+#define __NR_sigaction 67
+#define __NR_sgetmask 68
+#define __NR_ssetmask 69
+#define __NR_setreuid 70
+#define __NR_setregid 71
+#define __NR_sigsuspend 72
+#define __NR_sigpending 73
+#define __NR_sethostname 74
+#define __NR_setrlimit 75
+#define __NR_getrlimit 76
+#define __NR_getrusage 77
+#define __NR_gettimeofday 78
+#define __NR_settimeofday 79
+#define __NR_getgroups 80
+#define __NR_setgroups 81
+#define __NR_select 82
+#define __NR_symlink 83
+#define __NR_oldlstat 84
+#define __NR_readlink 85
+#define __NR_uselib 86
+#define __NR_swapon 87
+#define __NR_reboot 88
+#define __NR_readdir 89
+#define __NR_mmap 90
+#define __NR_munmap 91
+#define __NR_truncate 92
+#define __NR_ftruncate 93
+#define __NR_fchmod 94
+#define __NR_fchown 95
+#define __NR_getpriority 96
+#define __NR_setpriority 97
+#define __NR_profil 98
+#define __NR_statfs 99
+#define __NR_fstatfs 100
+#define __NR_ioperm 101
+#define __NR_socketcall 102
+#define __NR_syslog 103
+#define __NR_setitimer 104
+#define __NR_getitimer 105
+#define __NR_stat 106
+#define __NR_lstat 107
+#define __NR_fstat 108
+#define __NR_olduname 109
+#define __NR_iopl 110
+#define __NR_vhangup 111
+#define __NR_idle 112
+#define __NR_vm86 113
+#define __NR_wait4 114
+#define __NR_swapoff 115
+#define __NR_sysinfo 116
+#define __NR_ipc 117
+#define __NR_fsync 118
+#define __NR_sigreturn 119
+#define __NR_clone 120
+#define __NR_setdomainname 121
+#define __NR_uname 122
+#define __NR_modify_ldt 123
+#define __NR_adjtimex 124
+#define __NR_mprotect 125
+#define __NR_sigprocmask 126
+#define __NR_create_module 127
+#define __NR_init_module 128
+#define __NR_delete_module 129
+#define __NR_get_kernel_syms 130
+#define __NR_quotactl 131
+#define __NR_getpgid 132
+#define __NR_fchdir 133
+#define __NR_bdflush 134
+#define __NR_sysfs 135
+#define __NR_personality 136
+#define __NR_afs_syscall 137
+#define __NR_setfsuid 138
+#define __NR_setfsgid 139
+#define __NR__llseek 140
+#define __NR_getdents 141
+#define __NR__newselect 142
+#define __NR_flock 143
+#define __NR_msync 144
+#define __NR_readv 145
+#define __NR_writev 146
+#define __NR_getsid 147
+#define __NR_fdatasync 148
+#define __NR__sysctl 149
+#define __NR_mlock 150
+#define __NR_munlock 151
+#define __NR_mlockall 152
+#define __NR_munlockall 153
+#define __NR_sched_setparam 154
+#define __NR_sched_getparam 155
+#define __NR_sched_setscheduler 156
+#define __NR_sched_getscheduler 157
+#define __NR_sched_yield 158
+#define __NR_sched_get_priority_max 159
+#define __NR_sched_get_priority_min 160
+#define __NR_sched_rr_get_interval 161
+#define __NR_nanosleep 162
+#define __NR_mremap 163
+#define __NR_setresuid 164
+#define __NR_getresuid 165
+#define __NR_query_module 166
+#define __NR_poll 167
+#define __NR_nfsservctl 168
+#define __NR_setresgid 169
+#define __NR_getresgid 170
+#define __NR_prctl 171
+#define __NR_rt_sigreturn 172
+#define __NR_rt_sigaction 173
+#define __NR_rt_sigprocmask 174
+#define __NR_rt_sigpending 175
+#define __NR_rt_sigtimedwait 176
+#define __NR_rt_sigqueueinfo 177
+#define __NR_rt_sigsuspend 178
+#define __NR_pread64 179
+#define __NR_pwrite64 180
+#define __NR_chown 181
+#define __NR_getcwd 182
+#define __NR_capget 183
+#define __NR_capset 184
+#define __NR_sigaltstack 185
+#define __NR_sendfile 186
+#define __NR_getpmsg 187
+#define __NR_putpmsg 188
+#define __NR_vfork 189
+#define __NR_ugetrlimit 190
+#define __NR_readahead 191
+#define __NR_pciconfig_read 198
+#define __NR_pciconfig_write 199
+#define __NR_pciconfig_iobase 200
+#define __NR_multiplexer 201
+#define __NR_getdents64 202
+#define __NR_pivot_root 203
+#define __NR_madvise 205
+#define __NR_mincore 206
+#define __NR_gettid 207
+#define __NR_tkill 208
+#define __NR_setxattr 209
+#define __NR_lsetxattr 210
+#define __NR_fsetxattr 211
+#define __NR_getxattr 212
+#define __NR_lgetxattr 213
+#define __NR_fgetxattr 214
+#define __NR_listxattr 215
+#define __NR_llistxattr 216
+#define __NR_flistxattr 217
+#define __NR_removexattr 218
+#define __NR_lremovexattr 219
+#define __NR_fremovexattr 220
+#define __NR_futex 221
+#define __NR_sched_setaffinity 222
+#define __NR_sched_getaffinity 223
+#define __NR_tuxcall 225
+#define __NR_io_setup 227
+#define __NR_io_destroy 228
+#define __NR_io_getevents 229
+#define __NR_io_submit 230
+#define __NR_io_cancel 231
+#define __NR_set_tid_address 232
+#define __NR_fadvise64 233
+#define __NR_exit_group 234
+#define __NR_lookup_dcookie 235
+#define __NR_epoll_create 236
+#define __NR_epoll_ctl 237
+#define __NR_epoll_wait 238
+#define __NR_remap_file_pages 239
+#define __NR_timer_create 240
+#define __NR_timer_settime 241
+#define __NR_timer_gettime 242
+#define __NR_timer_getoverrun 243
+#define __NR_timer_delete 244
+#define __NR_clock_settime 245
+#define __NR_clock_gettime 246
+#define __NR_clock_getres 247
+#define __NR_clock_nanosleep 248
+#define __NR_swapcontext 249
+#define __NR_tgkill 250
+#define __NR_utimes 251
+#define __NR_statfs64 252
+#define __NR_fstatfs64 253
+#define __NR_rtas 255
+#define __NR_sys_debug_setcontext 256
+#define __NR_migrate_pages 258
+#define __NR_mbind 259
+#define __NR_get_mempolicy 260
+#define __NR_set_mempolicy 261
+#define __NR_mq_open 262
+#define __NR_mq_unlink 263
+#define __NR_mq_timedsend 264
+#define __NR_mq_timedreceive 265
+#define __NR_mq_notify 266
+#define __NR_mq_getsetattr 267
+#define __NR_kexec_load 268
+#define __NR_add_key 269
+#define __NR_request_key 270
+#define __NR_keyctl 271
+#define __NR_waitid 272
+#define __NR_ioprio_set 273
+#define __NR_ioprio_get 274
+#define __NR_inotify_init 275
+#define __NR_inotify_add_watch 276
+#define __NR_inotify_rm_watch 277
+#define __NR_spu_run 278
+#define __NR_spu_create 279
+#define __NR_pselect6 280
+#define __NR_ppoll 281
+#define __NR_unshare 282
+#define __NR_splice 283
+#define __NR_tee 284
+#define __NR_vmsplice 285
+#define __NR_openat 286
+#define __NR_mkdirat 287
+#define __NR_mknodat 288
+#define __NR_fchownat 289
+#define __NR_futimesat 290
+#define __NR_newfstatat 291
+#define __NR_unlinkat 292
+#define __NR_renameat 293
+#define __NR_linkat 294
+#define __NR_symlinkat 295
+#define __NR_readlinkat 296
+#define __NR_fchmodat 297
+#define __NR_faccessat 298
+#define __NR_get_robust_list 299
+#define __NR_set_robust_list 300
+#define __NR_move_pages 301
+#define __NR_getcpu 302
+#define __NR_epoll_pwait 303
+#define __NR_utimensat 304
+#define __NR_signalfd 305
+#define __NR_timerfd_create 306
+#define __NR_eventfd 307
+#define __NR_sync_file_range2 308
+#define __NR_fallocate 309
+#define __NR_subpage_prot 310
+#define __NR_timerfd_settime 311
+#define __NR_timerfd_gettime 312
+#define __NR_signalfd4 313
+#define __NR_eventfd2 314
+#define __NR_epoll_create1 315
+#define __NR_dup3 316
+#define __NR_pipe2 317
+#define __NR_inotify_init1 318
+#define __NR_perf_event_open 319
+#define __NR_preadv 320
+#define __NR_pwritev 321
+#define __NR_rt_tgsigqueueinfo 322
+#define __NR_fanotify_init 323
+#define __NR_fanotify_mark 324
+#define __NR_prlimit64 325
+#define __NR_socket 326
+#define __NR_bind 327
+#define __NR_connect 328
+#define __NR_listen 329
+#define __NR_accept 330
+#define __NR_getsockname 331
+#define __NR_getpeername 332
+#define __NR_socketpair 333
+#define __NR_send 334
+#define __NR_sendto 335
+#define __NR_recv 336
+#define __NR_recvfrom 337
+#define __NR_shutdown 338
+#define __NR_setsockopt 339
+#define __NR_getsockopt 340
+#define __NR_sendmsg 341
+#define __NR_recvmsg 342
+#define __NR_recvmmsg 343
+#define __NR_accept4 344
+#define __NR_name_to_handle_at 345
+#define __NR_open_by_handle_at 346
+#define __NR_clock_adjtime 347
+#define __NR_syncfs 348
+#define __NR_sendmmsg 349
+#define __NR_setns 350
+#define __NR_process_vm_readv 351
+#define __NR_process_vm_writev 352
+#define __NR_finit_module 353
+#define __NR_kcmp 354
+#define __NR_sched_setattr 355
+#define __NR_sched_getattr 356
+#define __NR_renameat2 357
+#define __NR_seccomp 358
+#define __NR_getrandom 359
+#define __NR_memfd_create 360
+#define __NR_bpf 361
+#define __NR_execveat 362
+#define __NR_switch_endian 363
+#define __NR_userfaultfd 364
+#define __NR_membarrier 365
+#define __NR_mlock2 378
+#define __NR_copy_file_range 379
+#define __NR_preadv2 380
+#define __NR_pwritev2 381
+#define __NR_kexec_file_load 382
+#define __NR_statx 383
+#define __NR_pkey_alloc 384
+#define __NR_pkey_free 385
+#define __NR_pkey_mprotect 386
+#define __NR_rseq 387
+#define __NR_io_pgetevents 388
+#define __NR_semtimedop 392
+#define __NR_semget 393
+#define __NR_semctl 394
+#define __NR_shmget 395
+#define __NR_shmctl 396
+#define __NR_shmat 397
+#define __NR_shmdt 398
+#define __NR_msgget 399
+#define __NR_msgsnd 400
+#define __NR_msgrcv 401
+#define __NR_msgctl 402
+#define __NR_pidfd_send_signal 424
+#define __NR_io_uring_setup 425
+#define __NR_io_uring_enter 426
+#define __NR_io_uring_register 427
+#define __NR_open_tree 428
+#define __NR_move_mount 429
+#define __NR_fsopen 430
+#define __NR_fsconfig 431
+#define __NR_fsmount 432
+#define __NR_fspick 433
+#define __NR_pidfd_open 434
+#define __NR_clone3 435
+#define __NR_close_range 436
+#define __NR_openat2 437
+#define __NR_pidfd_getfd 438
+#define __NR_faccessat2 439
+#define __NR_process_madvise 440
+#define __NR_epoll_pwait2 441
+#define __NR_mount_setattr 442
+#define __NR_landlock_create_ruleset 444
+#define __NR_landlock_add_rule 445
+#define __NR_landlock_restrict_self 446
 
 
-#endif /* _ASM_POWERPC_UNISTD_64_H */
+#endif /* _ASM_UNISTD_64_H */
diff --git a/linux-headers/asm-s390/unistd_32.h b/linux-headers/asm-s390/unistd_32.h
index c94d2c3a22..e8cd34334f 100644
--- a/linux-headers/asm-s390/unistd_32.h
+++ b/linux-headers/asm-s390/unistd_32.h
@@ -414,5 +414,9 @@
 #define __NR_faccessat2 439
 #define __NR_process_madvise 440
 #define __NR_epoll_pwait2 441
+#define __NR_mount_setattr 442
+#define __NR_landlock_create_ruleset 444
+#define __NR_landlock_add_rule 445
+#define __NR_landlock_restrict_self 446
 
 #endif /* _ASM_S390_UNISTD_32_H */
diff --git a/linux-headers/asm-s390/unistd_64.h b/linux-headers/asm-s390/unistd_64.h
index 984a06b7eb..86830e1e83 100644
--- a/linux-headers/asm-s390/unistd_64.h
+++ b/linux-headers/asm-s390/unistd_64.h
@@ -362,5 +362,9 @@
 #define __NR_faccessat2 439
 #define __NR_process_madvise 440
 #define __NR_epoll_pwait2 441
+#define __NR_mount_setattr 442
+#define __NR_landlock_create_ruleset 444
+#define __NR_landlock_add_rule 445
+#define __NR_landlock_restrict_self 446
 
 #endif /* _ASM_S390_UNISTD_64_H */
diff --git a/linux-headers/asm-x86/kvm.h b/linux-headers/asm-x86/kvm.h
index 8e76d3701d..0662f644aa 100644
--- a/linux-headers/asm-x86/kvm.h
+++ b/linux-headers/asm-x86/kvm.h
@@ -112,6 +112,7 @@ struct kvm_ioapic_state {
 #define KVM_NR_IRQCHIPS          3
 
 #define KVM_RUN_X86_SMM		 (1 << 0)
+#define KVM_RUN_X86_BUS_LOCK     (1 << 1)
 
 /* for KVM_GET_REGS and KVM_SET_REGS */
 struct kvm_regs {
@@ -436,6 +437,8 @@ struct kvm_vmx_nested_state_hdr {
 		__u16 flags;
 	} smm;
 
+	__u16 pad;
+
 	__u32 flags;
 	__u64 preemption_timer_deadline;
 };
diff --git a/linux-headers/asm-x86/unistd_32.h b/linux-headers/asm-x86/unistd_32.h
index 18fb99dfa2..8f6ac8c19f 100644
--- a/linux-headers/asm-x86/unistd_32.h
+++ b/linux-headers/asm-x86/unistd_32.h
@@ -432,6 +432,10 @@
 #define __NR_faccessat2 439
 #define __NR_process_madvise 440
 #define __NR_epoll_pwait2 441
+#define __NR_mount_setattr 442
+#define __NR_landlock_create_ruleset 444
+#define __NR_landlock_add_rule 445
+#define __NR_landlock_restrict_self 446
 
 
 #endif /* _ASM_X86_UNISTD_32_H */
diff --git a/linux-headers/asm-x86/unistd_64.h b/linux-headers/asm-x86/unistd_64.h
index bde959328d..bb187a9268 100644
--- a/linux-headers/asm-x86/unistd_64.h
+++ b/linux-headers/asm-x86/unistd_64.h
@@ -354,6 +354,10 @@
 #define __NR_faccessat2 439
 #define __NR_process_madvise 440
 #define __NR_epoll_pwait2 441
+#define __NR_mount_setattr 442
+#define __NR_landlock_create_ruleset 444
+#define __NR_landlock_add_rule 445
+#define __NR_landlock_restrict_self 446
 
 
 #endif /* _ASM_X86_UNISTD_64_H */
diff --git a/linux-headers/asm-x86/unistd_x32.h b/linux-headers/asm-x86/unistd_x32.h
index 4ff6b17d3b..4edd0103ac 100644
--- a/linux-headers/asm-x86/unistd_x32.h
+++ b/linux-headers/asm-x86/unistd_x32.h
@@ -307,6 +307,10 @@
 #define __NR_faccessat2 (__X32_SYSCALL_BIT + 439)
 #define __NR_process_madvise (__X32_SYSCALL_BIT + 440)
 #define __NR_epoll_pwait2 (__X32_SYSCALL_BIT + 441)
+#define __NR_mount_setattr (__X32_SYSCALL_BIT + 442)
+#define __NR_landlock_create_ruleset (__X32_SYSCALL_BIT + 444)
+#define __NR_landlock_add_rule (__X32_SYSCALL_BIT + 445)
+#define __NR_landlock_restrict_self (__X32_SYSCALL_BIT + 446)
 #define __NR_rt_sigaction (__X32_SYSCALL_BIT + 512)
 #define __NR_rt_sigreturn (__X32_SYSCALL_BIT + 513)
 #define __NR_ioctl (__X32_SYSCALL_BIT + 514)
diff --git a/linux-headers/linux/kvm.h b/linux-headers/linux/kvm.h
index 897f831374..20d6a263bb 100644
--- a/linux-headers/linux/kvm.h
+++ b/linux-headers/linux/kvm.h
@@ -8,6 +8,7 @@
  * Note: you must update KVM_API_VERSION if you change this interface.
  */
 
+#include <linux/const.h>
 #include <linux/types.h>
 
 #include <linux/ioctl.h>
@@ -216,6 +217,20 @@ struct kvm_hyperv_exit {
 	} u;
 };
 
+struct kvm_xen_exit {
+#define KVM_EXIT_XEN_HCALL          1
+	__u32 type;
+	union {
+		struct {
+			__u32 longmode;
+			__u32 cpl;
+			__u64 input;
+			__u64 result;
+			__u64 params[6];
+		} hcall;
+	} u;
+};
+
 #define KVM_S390_GET_SKEYS_NONE   1
 #define KVM_S390_SKEYS_MAX        1048576
 
@@ -251,6 +266,9 @@ struct kvm_hyperv_exit {
 #define KVM_EXIT_X86_RDMSR        29
 #define KVM_EXIT_X86_WRMSR        30
 #define KVM_EXIT_DIRTY_RING_FULL  31
+#define KVM_EXIT_AP_RESET_HOLD    32
+#define KVM_EXIT_X86_BUS_LOCK     33
+#define KVM_EXIT_XEN              34
 
 /* For KVM_EXIT_INTERNAL_ERROR */
 /* Emulate instruction failed. */
@@ -427,6 +445,8 @@ struct kvm_run {
 			__u32 index; /* kernel -> user */
 			__u64 data; /* kernel <-> user */
 		} msr;
+		/* KVM_EXIT_XEN */
+		struct kvm_xen_exit xen;
 		/* Fix the size of the union. */
 		char padding[256];
 	};
@@ -573,6 +593,7 @@ struct kvm_vapic_addr {
 #define KVM_MP_STATE_CHECK_STOP        6
 #define KVM_MP_STATE_OPERATING         7
 #define KVM_MP_STATE_LOAD              8
+#define KVM_MP_STATE_AP_RESET_HOLD     9
 
 struct kvm_mp_state {
 	__u32 mp_state;
@@ -1056,6 +1077,12 @@ struct kvm_ppc_resize_hpt {
 #define KVM_CAP_ENFORCE_PV_FEATURE_CPUID 190
 #define KVM_CAP_SYS_HYPERV_CPUID 191
 #define KVM_CAP_DIRTY_LOG_RING 192
+#define KVM_CAP_X86_BUS_LOCK_EXIT 193
+#define KVM_CAP_PPC_DAWR1 194
+#define KVM_CAP_SET_GUEST_DEBUG2 195
+#define KVM_CAP_SGX_ATTRIBUTE 196
+#define KVM_CAP_VM_COPY_ENC_CONTEXT_FROM 197
+#define KVM_CAP_PTP_KVM 198
 
 #ifdef KVM_CAP_IRQ_ROUTING
 
@@ -1129,6 +1156,11 @@ struct kvm_x86_mce {
 #endif
 
 #ifdef KVM_CAP_XEN_HVM
+#define KVM_XEN_HVM_CONFIG_HYPERCALL_MSR	(1 << 0)
+#define KVM_XEN_HVM_CONFIG_INTERCEPT_HCALL	(1 << 1)
+#define KVM_XEN_HVM_CONFIG_SHARED_INFO		(1 << 2)
+#define KVM_XEN_HVM_CONFIG_RUNSTATE		(1 << 3)
+
 struct kvm_xen_hvm_config {
 	__u32 flags;
 	__u32 msr;
@@ -1563,6 +1595,57 @@ struct kvm_pv_cmd {
 /* Available with KVM_CAP_DIRTY_LOG_RING */
 #define KVM_RESET_DIRTY_RINGS		_IO(KVMIO, 0xc7)
 
+/* Per-VM Xen attributes */
+#define KVM_XEN_HVM_GET_ATTR	_IOWR(KVMIO, 0xc8, struct kvm_xen_hvm_attr)
+#define KVM_XEN_HVM_SET_ATTR	_IOW(KVMIO,  0xc9, struct kvm_xen_hvm_attr)
+
+struct kvm_xen_hvm_attr {
+	__u16 type;
+	__u16 pad[3];
+	union {
+		__u8 long_mode;
+		__u8 vector;
+		struct {
+			__u64 gfn;
+		} shared_info;
+		__u64 pad[8];
+	} u;
+};
+
+/* Available with KVM_CAP_XEN_HVM / KVM_XEN_HVM_CONFIG_SHARED_INFO */
+#define KVM_XEN_ATTR_TYPE_LONG_MODE		0x0
+#define KVM_XEN_ATTR_TYPE_SHARED_INFO		0x1
+#define KVM_XEN_ATTR_TYPE_UPCALL_VECTOR		0x2
+
+/* Per-vCPU Xen attributes */
+#define KVM_XEN_VCPU_GET_ATTR	_IOWR(KVMIO, 0xca, struct kvm_xen_vcpu_attr)
+#define KVM_XEN_VCPU_SET_ATTR	_IOW(KVMIO,  0xcb, struct kvm_xen_vcpu_attr)
+
+struct kvm_xen_vcpu_attr {
+	__u16 type;
+	__u16 pad[3];
+	union {
+		__u64 gpa;
+		__u64 pad[8];
+		struct {
+			__u64 state;
+			__u64 state_entry_time;
+			__u64 time_running;
+			__u64 time_runnable;
+			__u64 time_blocked;
+			__u64 time_offline;
+		} runstate;
+	} u;
+};
+
+/* Available with KVM_CAP_XEN_HVM / KVM_XEN_HVM_CONFIG_SHARED_INFO */
+#define KVM_XEN_VCPU_ATTR_TYPE_VCPU_INFO	0x0
+#define KVM_XEN_VCPU_ATTR_TYPE_VCPU_TIME_INFO	0x1
+#define KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADDR	0x2
+#define KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_CURRENT	0x3
+#define KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_DATA	0x4
+#define KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADJUST	0x5
+
 /* Secure Encrypted Virtualization command */
 enum sev_cmd_id {
 	/* Guest initialization commands */
@@ -1593,6 +1676,8 @@ enum sev_cmd_id {
 	KVM_SEV_CERT_EXPORT,
 	/* Attestation report */
 	KVM_SEV_GET_ATTESTATION_REPORT,
+	/* Guest Migration Extension */
+	KVM_SEV_SEND_CANCEL,
 
 	KVM_SEV_NR_MAX,
 };
@@ -1651,6 +1736,45 @@ struct kvm_sev_attestation_report {
 	__u32 len;
 };
 
+struct kvm_sev_send_start {
+	__u32 policy;
+	__u64 pdh_cert_uaddr;
+	__u32 pdh_cert_len;
+	__u64 plat_certs_uaddr;
+	__u32 plat_certs_len;
+	__u64 amd_certs_uaddr;
+	__u32 amd_certs_len;
+	__u64 session_uaddr;
+	__u32 session_len;
+};
+
+struct kvm_sev_send_update_data {
+	__u64 hdr_uaddr;
+	__u32 hdr_len;
+	__u64 guest_uaddr;
+	__u32 guest_len;
+	__u64 trans_uaddr;
+	__u32 trans_len;
+};
+
+struct kvm_sev_receive_start {
+	__u32 handle;
+	__u32 policy;
+	__u64 pdh_uaddr;
+	__u32 pdh_len;
+	__u64 session_uaddr;
+	__u32 session_len;
+};
+
+struct kvm_sev_receive_update_data {
+	__u64 hdr_uaddr;
+	__u32 hdr_len;
+	__u64 guest_uaddr;
+	__u32 guest_len;
+	__u64 trans_uaddr;
+	__u32 trans_len;
+};
+
 #define KVM_DEV_ASSIGN_ENABLE_IOMMU	(1 << 0)
 #define KVM_DEV_ASSIGN_PCI_2_3		(1 << 1)
 #define KVM_DEV_ASSIGN_MASK_INTX	(1 << 2)
@@ -1756,8 +1880,8 @@ struct kvm_hyperv_eventfd {
  * conversion after harvesting an entry.  Also, it must not skip any
  * dirty bits, so that dirty bits are always harvested in sequence.
  */
-#define KVM_DIRTY_GFN_F_DIRTY           BIT(0)
-#define KVM_DIRTY_GFN_F_RESET           BIT(1)
+#define KVM_DIRTY_GFN_F_DIRTY           _BITUL(0)
+#define KVM_DIRTY_GFN_F_RESET           _BITUL(1)
 #define KVM_DIRTY_GFN_F_MASK            0x3
 
 /*
@@ -1772,4 +1896,7 @@ struct kvm_dirty_gfn {
 	__u64 offset;
 };
 
+#define KVM_BUS_LOCK_DETECTION_OFF             (1 << 0)
+#define KVM_BUS_LOCK_DETECTION_EXIT            (1 << 1)
+
 #endif /* __LINUX_KVM_H */
diff --git a/linux-headers/linux/userfaultfd.h b/linux-headers/linux/userfaultfd.h
index 1ba9a9feeb..b9ac97b70f 100644
--- a/linux-headers/linux/userfaultfd.h
+++ b/linux-headers/linux/userfaultfd.h
@@ -19,15 +19,19 @@
  * means the userland is reading).
  */
 #define UFFD_API ((__u64)0xAA)
+#define UFFD_API_REGISTER_MODES (UFFDIO_REGISTER_MODE_MISSING |	\
+				 UFFDIO_REGISTER_MODE_WP |	\
+				 UFFDIO_REGISTER_MODE_MINOR)
 #define UFFD_API_FEATURES (UFFD_FEATURE_PAGEFAULT_FLAG_WP |	\
 			   UFFD_FEATURE_EVENT_FORK |		\
 			   UFFD_FEATURE_EVENT_REMAP |		\
-			   UFFD_FEATURE_EVENT_REMOVE |	\
+			   UFFD_FEATURE_EVENT_REMOVE |		\
 			   UFFD_FEATURE_EVENT_UNMAP |		\
 			   UFFD_FEATURE_MISSING_HUGETLBFS |	\
 			   UFFD_FEATURE_MISSING_SHMEM |		\
 			   UFFD_FEATURE_SIGBUS |		\
-			   UFFD_FEATURE_THREAD_ID)
+			   UFFD_FEATURE_THREAD_ID |		\
+			   UFFD_FEATURE_MINOR_HUGETLBFS)
 #define UFFD_API_IOCTLS				\
 	((__u64)1 << _UFFDIO_REGISTER |		\
 	 (__u64)1 << _UFFDIO_UNREGISTER |	\
@@ -36,10 +40,12 @@
 	((__u64)1 << _UFFDIO_WAKE |		\
 	 (__u64)1 << _UFFDIO_COPY |		\
 	 (__u64)1 << _UFFDIO_ZEROPAGE |		\
-	 (__u64)1 << _UFFDIO_WRITEPROTECT)
+	 (__u64)1 << _UFFDIO_WRITEPROTECT |	\
+	 (__u64)1 << _UFFDIO_CONTINUE)
 #define UFFD_API_RANGE_IOCTLS_BASIC		\
 	((__u64)1 << _UFFDIO_WAKE |		\
-	 (__u64)1 << _UFFDIO_COPY)
+	 (__u64)1 << _UFFDIO_COPY |		\
+	 (__u64)1 << _UFFDIO_CONTINUE)
 
 /*
  * Valid ioctl command number range with this API is from 0x00 to
@@ -55,6 +61,7 @@
 #define _UFFDIO_COPY			(0x03)
 #define _UFFDIO_ZEROPAGE		(0x04)
 #define _UFFDIO_WRITEPROTECT		(0x06)
+#define _UFFDIO_CONTINUE		(0x07)
 #define _UFFDIO_API			(0x3F)
 
 /* userfaultfd ioctl ids */
@@ -73,6 +80,8 @@
 				      struct uffdio_zeropage)
 #define UFFDIO_WRITEPROTECT	_IOWR(UFFDIO, _UFFDIO_WRITEPROTECT, \
 				      struct uffdio_writeprotect)
+#define UFFDIO_CONTINUE		_IOR(UFFDIO, _UFFDIO_CONTINUE,	\
+				     struct uffdio_continue)
 
 /* read() structure */
 struct uffd_msg {
@@ -127,6 +136,7 @@ struct uffd_msg {
 /* flags for UFFD_EVENT_PAGEFAULT */
 #define UFFD_PAGEFAULT_FLAG_WRITE	(1<<0)	/* If this was a write fault */
 #define UFFD_PAGEFAULT_FLAG_WP		(1<<1)	/* If reason is VM_UFFD_WP */
+#define UFFD_PAGEFAULT_FLAG_MINOR	(1<<2)	/* If reason is VM_UFFD_MINOR */
 
 struct uffdio_api {
 	/* userland asks for an API number and the features to enable */
@@ -171,6 +181,10 @@ struct uffdio_api {
 	 *
 	 * UFFD_FEATURE_THREAD_ID pid of the page faulted task_struct will
 	 * be returned, if feature is not requested 0 will be returned.
+	 *
+	 * UFFD_FEATURE_MINOR_HUGETLBFS indicates that minor faults
+	 * can be intercepted (via REGISTER_MODE_MINOR) for
+	 * hugetlbfs-backed pages.
 	 */
 #define UFFD_FEATURE_PAGEFAULT_FLAG_WP		(1<<0)
 #define UFFD_FEATURE_EVENT_FORK			(1<<1)
@@ -181,6 +195,7 @@ struct uffdio_api {
 #define UFFD_FEATURE_EVENT_UNMAP		(1<<6)
 #define UFFD_FEATURE_SIGBUS			(1<<7)
 #define UFFD_FEATURE_THREAD_ID			(1<<8)
+#define UFFD_FEATURE_MINOR_HUGETLBFS		(1<<9)
 	__u64 features;
 
 	__u64 ioctls;
@@ -195,6 +210,7 @@ struct uffdio_register {
 	struct uffdio_range range;
 #define UFFDIO_REGISTER_MODE_MISSING	((__u64)1<<0)
 #define UFFDIO_REGISTER_MODE_WP		((__u64)1<<1)
+#define UFFDIO_REGISTER_MODE_MINOR	((__u64)1<<2)
 	__u64 mode;
 
 	/*
@@ -257,6 +273,18 @@ struct uffdio_writeprotect {
 	__u64 mode;
 };
 
+struct uffdio_continue {
+	struct uffdio_range range;
+#define UFFDIO_CONTINUE_MODE_DONTWAKE		((__u64)1<<0)
+	__u64 mode;
+
+	/*
+	 * Fields below here are written by the ioctl and must be at the end:
+	 * the copy_from_user will not read past here.
+	 */
+	__s64 mapped;
+};
+
 /*
  * Flags for the userfaultfd(2) system call itself.
  */
diff --git a/linux-headers/linux/vfio.h b/linux-headers/linux/vfio.h
index 609099e455..e680594f27 100644
--- a/linux-headers/linux/vfio.h
+++ b/linux-headers/linux/vfio.h
@@ -46,6 +46,12 @@
  */
 #define VFIO_NOIOMMU_IOMMU		8
 
+/* Supports VFIO_DMA_UNMAP_FLAG_ALL */
+#define VFIO_UNMAP_ALL			9
+
+/* Supports the vaddr flag for DMA map and unmap */
+#define VFIO_UPDATE_VADDR		10
+
 /*
  * The IOCTL interface is designed for extensibility by embedding the
  * structure length (argsz) and flags into structures passed between
@@ -329,6 +335,8 @@ struct vfio_region_info_cap_type {
 /* 10de vendor PCI sub-types */
 /*
  * NVIDIA GPU NVlink2 RAM is coherent RAM mapped onto the host address space.
+ *
+ * Deprecated, region no longer provided
  */
 #define VFIO_REGION_SUBTYPE_NVIDIA_NVLINK2_RAM	(1)
 
@@ -336,6 +344,8 @@ struct vfio_region_info_cap_type {
 /*
  * IBM NPU NVlink2 ATSD (Address Translation Shootdown) register of NPU
  * to do TLB invalidation on a GPU.
+ *
+ * Deprecated, region no longer provided
  */
 #define VFIO_REGION_SUBTYPE_IBM_NVLINK2_ATSD	(1)
 
@@ -635,6 +645,8 @@ struct vfio_device_migration_info {
  * Capability with compressed real address (aka SSA - small system address)
  * where GPU RAM is mapped on a system bus. Used by a GPU for DMA routing
  * and by the userspace to associate a NVLink bridge with a GPU.
+ *
+ * Deprecated, capability no longer provided
  */
 #define VFIO_REGION_INFO_CAP_NVLINK2_SSATGT	4
 
@@ -649,6 +661,8 @@ struct vfio_region_info_cap_nvlink2_ssatgt {
  * property in the device tree. The value is fixed in the hardware
  * and failing to provide the correct value results in the link
  * not working with no indication from the driver why.
+ *
+ * Deprecated, capability no longer provided
  */
 #define VFIO_REGION_INFO_CAP_NVLINK2_LNKSPD	5
 
@@ -1074,12 +1088,22 @@ struct vfio_iommu_type1_info_dma_avail {
  *
  * Map process virtual addresses to IO virtual addresses using the
  * provided struct vfio_dma_map. Caller sets argsz. READ &/ WRITE required.
+ *
+ * If flags & VFIO_DMA_MAP_FLAG_VADDR, update the base vaddr for iova, and
+ * unblock translation of host virtual addresses in the iova range.  The vaddr
+ * must have previously been invalidated with VFIO_DMA_UNMAP_FLAG_VADDR.  To
+ * maintain memory consistency within the user application, the updated vaddr
+ * must address the same memory object as originally mapped.  Failure to do so
+ * will result in user memory corruption and/or device misbehavior.  iova and
+ * size must match those in the original MAP_DMA call.  Protection is not
+ * changed, and the READ & WRITE flags must be 0.
  */
 struct vfio_iommu_type1_dma_map {
 	__u32	argsz;
 	__u32	flags;
 #define VFIO_DMA_MAP_FLAG_READ (1 << 0)		/* readable from device */
 #define VFIO_DMA_MAP_FLAG_WRITE (1 << 1)	/* writable from device */
+#define VFIO_DMA_MAP_FLAG_VADDR (1 << 2)
 	__u64	vaddr;				/* Process virtual address */
 	__u64	iova;				/* IO virtual address */
 	__u64	size;				/* Size of mapping (bytes) */
@@ -1102,6 +1126,7 @@ struct vfio_bitmap {
  * field.  No guarantee is made to the user that arbitrary unmaps of iova
  * or size different from those used in the original mapping call will
  * succeed.
+ *
  * VFIO_DMA_UNMAP_FLAG_GET_DIRTY_BITMAP should be set to get the dirty bitmap
  * before unmapping IO virtual addresses. When this flag is set, the user must
  * provide a struct vfio_bitmap in data[]. User must provide zero-allocated
@@ -1111,11 +1136,21 @@ struct vfio_bitmap {
  * indicates that the page at that offset from iova is dirty. A Bitmap of the
  * pages in the range of unmapped size is returned in the user-provided
  * vfio_bitmap.data.
+ *
+ * If flags & VFIO_DMA_UNMAP_FLAG_ALL, unmap all addresses.  iova and size
+ * must be 0.  This cannot be combined with the get-dirty-bitmap flag.
+ *
+ * If flags & VFIO_DMA_UNMAP_FLAG_VADDR, do not unmap, but invalidate host
+ * virtual addresses in the iova range.  Tasks that attempt to translate an
+ * iova's vaddr will block.  DMA to already-mapped pages continues.  This
+ * cannot be combined with the get-dirty-bitmap flag.
  */
 struct vfio_iommu_type1_dma_unmap {
 	__u32	argsz;
 	__u32	flags;
 #define VFIO_DMA_UNMAP_FLAG_GET_DIRTY_BITMAP (1 << 0)
+#define VFIO_DMA_UNMAP_FLAG_ALL		     (1 << 1)
+#define VFIO_DMA_UNMAP_FLAG_VADDR	     (1 << 2)
 	__u64	iova;				/* IO virtual address */
 	__u64	size;				/* Size of mapping (bytes) */
 	__u8    data[];
diff --git a/migration/ram.c b/migration/ram.c
index 723af67c2e..60ea913c54 100644
--- a/migration/ram.c
+++ b/migration/ram.c
@@ -3343,7 +3343,8 @@ int colo_init_ram_cache(void)
     WITH_RCU_READ_LOCK_GUARD() {
         RAMBLOCK_FOREACH_NOT_IGNORED(block) {
             block->colo_cache = qemu_anon_ram_alloc(block->used_length,
-                                                    NULL, false, false);
+                                                    NULL,
+                                                    false);
             if (!block->colo_cache) {
                 error_report("%s: Can't alloc memory for COLO cache of block %s,"
                              "size 0x" RAM_ADDR_FMT, __func__, block->idstr,
diff --git a/qapi/machine.json b/qapi/machine.json
index e4d0f9b24f..58a9c86b36 100644
--- a/qapi/machine.json
+++ b/qapi/machine.json
@@ -790,19 +790,11 @@
 #
 # @size: memory backend size
 #
-# @merge: whether memory merge support is enabled
+# @merge: enables or disables memory merge support
 #
-# @dump: whether memory backend's memory is included in a core dump
+# @dump: includes memory backend's memory in a core dump or not
 #
-# @prealloc: whether memory was preallocated
-#
-# @share: whether memory is private to QEMU or shared (since 6.1)
-#
-# @reserve: whether swap space (or huge pages) was reserved if applicable.
-#           This corresponds to the user configuration and not the actual
-#           behavior implemented in the OS to perform the reservation.
-#           For example, Linux will never reserve swap space for shared
-#           file mappings. (since 6.1)
+# @prealloc: enables or disables memory preallocation
 #
 # @host-nodes: host nodes for its memory policy
 #
@@ -817,8 +809,6 @@
     'merge':      'bool',
     'dump':       'bool',
     'prealloc':   'bool',
-    'share':      'bool',
-    '*reserve':    'bool',
     'host-nodes': ['uint16'],
     'policy':     'HostMemPolicy' }}
 
diff --git a/qapi/qom.json b/qapi/qom.json
index 652be317b8..f7ef30f940 100644
--- a/qapi/qom.json
+++ b/qapi/qom.json
@@ -545,9 +545,6 @@
 # @share: if false, the memory is private to QEMU; if true, it is shared
 #         (default: false)
 #
-# @reserve: if true, reserve swap space (or huge pages) if applicable
-#           (default: true) (since 6.1)
-#
 # @size: size of the memory region in bytes
 #
 # @x-use-canonical-path-for-ramblock-id: if true, the canoncial path is used
@@ -559,12 +556,6 @@
 #                                        false generally, but true for machine
 #                                        types <= 4.0)
 #
-# Note: prealloc=true and reserve=false cannot be set at the same time. With
-#       reserve=true, the behavior depends on the operating system: for example,
-#       Linux will not reserve swap space for shared file mappings --
-#       "not applicable". In contrast, reserve=false will bail out if it cannot
-#       be configured accordingly.
-#
 # Since: 2.1
 ##
 { 'struct': 'MemoryBackendProperties',
@@ -575,7 +566,6 @@
             '*prealloc': 'bool',
             '*prealloc-threads': 'uint32',
             '*share': 'bool',
-            '*reserve': 'bool',
             'size': 'size',
             '*x-use-canonical-path-for-ramblock-id': 'bool' } }
 
diff --git a/scripts/coccinelle/memory-region-housekeeping.cocci b/scripts/coccinelle/memory-region-housekeeping.cocci
index 29651ebde9..c768d8140a 100644
--- a/scripts/coccinelle/memory-region-housekeeping.cocci
+++ b/scripts/coccinelle/memory-region-housekeeping.cocci
@@ -127,8 +127,8 @@ static void device_fn(DeviceState *dev, ...)
 - memory_region_init_rom(E1, NULL, E2, E3, E4);
 + memory_region_init_rom(E1, obj, E2, E3, E4);
 |
-- memory_region_init_ram_flags_nomigrate(E1, NULL, E2, E3, E4, E5);
-+ memory_region_init_ram_flags_nomigrate(E1, obj, E2, E3, E4, E5);
+- memory_region_init_ram_shared_nomigrate(E1, NULL, E2, E3, E4, E5);
++ memory_region_init_ram_shared_nomigrate(E1, obj, E2, E3, E4, E5);
 )
   ...+>
 }
@@ -152,8 +152,8 @@ static void device_fn(DeviceState *dev, ...)
 - memory_region_init_rom(E1, NULL, E2, E3, E4);
 + memory_region_init_rom(E1, OBJECT(dev), E2, E3, E4);
 |
-- memory_region_init_ram_flags_nomigrate(E1, NULL, E2, E3, E4, E5);
-+ memory_region_init_ram_flags_nomigrate(E1, OBJECT(dev), E2, E3, E4, E5);
+- memory_region_init_ram_shared_nomigrate(E1, NULL, E2, E3, E4, E5);
++ memory_region_init_ram_shared_nomigrate(E1, OBJECT(dev), E2, E3, E4, E5);
 )
   ...+>
 }
diff --git a/scripts/cpu-x86-uarch-abi.py b/scripts/cpu-x86-uarch-abi.py
new file mode 100644
index 0000000000..08acc52a81
--- /dev/null
+++ b/scripts/cpu-x86-uarch-abi.py
@@ -0,0 +1,194 @@
+#!/usr/bin/python3
+#
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+# A script to generate a CSV file showing the x86_64 ABI
+# compatibility levels for each CPU model.
+#
+
+from qemu import qmp
+import sys
+
+if len(sys.argv) != 1:
+    print("syntax: %s QMP-SOCK\n\n" % __file__ +
+          "Where QMP-SOCK points to a QEMU process such as\n\n" +
+          " # qemu-system-x86_64 -qmp unix:/tmp/qmp,server,nowait " +
+          "-display none -accel kvm", file=sys.stderr)
+    sys.exit(1)
+
+# Mandatory CPUID features for each microarch ABI level
+levels = [
+    [ # x86-64 baseline
+        "cmov",
+        "cx8",
+        "fpu",
+        "fxsr",
+        "mmx",
+        "syscall",
+        "sse",
+        "sse2",
+    ],
+    [ # x86-64-v2
+        "cx16",
+        "lahf-lm",
+        "popcnt",
+        "pni",
+        "sse4.1",
+        "sse4.2",
+        "ssse3",
+    ],
+    [ # x86-64-v3
+        "avx",
+        "avx2",
+        "bmi1",
+        "bmi2",
+        "f16c",
+        "fma",
+        "abm",
+        "movbe",
+    ],
+    [ # x86-64-v4
+        "avx512f",
+        "avx512bw",
+        "avx512cd",
+        "avx512dq",
+        "avx512vl",
+    ],
+]
+
+# Assumes externally launched process such as
+#
+#   qemu-system-x86_64 -qmp unix:/tmp/qmp,server,nowait -display none -accel kvm
+#
+# Note different results will be obtained with TCG, as
+# TCG masks out certain features otherwise present in
+# the CPU model definitions, as does KVM.
+
+
+sock = sys.argv[1]
+cmd = sys.argv[2]
+shell = qmp.QEMUMonitorProtocol(sock)
+shell.connect()
+
+models = shell.cmd("query-cpu-definitions")
+
+# These QMP props don't correspond to CPUID fatures
+# so ignore them
+skip = [
+    "family",
+    "min-level",
+    "min-xlevel",
+    "vendor",
+    "model",
+    "model-id",
+    "stepping",
+]
+
+names = []
+
+for model in models["return"]:
+    if "alias-of" in model:
+        continue
+    names.append(model["name"])
+
+models = {}
+
+for name in sorted(names):
+    cpu = shell.cmd("query-cpu-model-expansion",
+                     { "type": "static",
+                       "model": { "name": name }})
+
+    got = {}
+    for (feature, present) in cpu["return"]["model"]["props"].items():
+        if present and feature not in skip:
+            got[feature] = True
+
+    if name in ["host", "max", "base"]:
+        continue
+
+    models[name] = {
+        # Dict of all present features in this CPU model
+        "features": got,
+
+        # Whether each x86-64 ABI level is satisfied
+        "levels": [False, False, False, False],
+
+        # Number of extra CPUID features compared to the x86-64 ABI level
+        "distance":[-1, -1, -1, -1],
+
+        # CPUID features present in model, but not in ABI level
+        "delta":[[], [], [], []],
+
+        # CPUID features in ABI level but not present in model
+        "missing": [[], [], [], []],
+    }
+
+
+# Calculate whether the CPU models satisfy each ABI level
+for name in models.keys():
+    for level in range(len(levels)):
+        got = set(models[name]["features"])
+        want = set(levels[level])
+        missing = want - got
+        match = True
+        if len(missing) > 0:
+            match = False
+        models[name]["levels"][level] = match
+        models[name]["missing"][level] = missing
+
+# Cache list of CPU models satisfying each ABI level
+abi_models = [
+    [],
+    [],
+    [],
+    [],
+]
+
+for name in models.keys():
+    for level in range(len(levels)):
+        if models[name]["levels"][level]:
+            abi_models[level].append(name)
+
+
+for level in range(len(abi_models)):
+    # Find the union of features in all CPU models satisfying this ABI
+    allfeatures = {}
+    for name in abi_models[level]:
+        for feat in models[name]["features"]:
+            allfeatures[feat] = True
+
+    # Find the intersection of features in all CPU models satisfying this ABI
+    commonfeatures = []
+    for feat in allfeatures:
+        present = True
+        for name in models.keys():
+            if not models[name]["levels"][level]:
+                continue
+            if feat not in models[name]["features"]:
+                present = False
+        if present:
+            commonfeatures.append(feat)
+
+    # Determine how many extra features are present compared to the lowest
+    # common denominator
+    for name in models.keys():
+        if not models[name]["levels"][level]:
+            continue
+
+        delta = set(models[name]["features"].keys()) - set(commonfeatures)
+        models[name]["distance"][level] = len(delta)
+        models[name]["delta"][level] = delta
+
+def print_uarch_abi_csv():
+    print("# Automatically generated from '%s'" % __file__)
+    print("Model,baseline,v2,v3,v4")
+    for name in models.keys():
+        print(name, end="")
+        for level in range(len(levels)):
+            if models[name]["levels"][level]:
+                print(",✅", end="")
+            else:
+                print(",", end="")
+        print()
+
+print_uarch_abi_csv()
diff --git a/softmmu/memory.c b/softmmu/memory.c
index f0161515e9..c19b0be6b1 100644
--- a/softmmu/memory.c
+++ b/softmmu/memory.c
@@ -1531,22 +1531,22 @@ void memory_region_init_ram_nomigrate(MemoryRegion *mr,
                                       uint64_t size,
                                       Error **errp)
 {
-    memory_region_init_ram_flags_nomigrate(mr, owner, name, size, 0, errp);
+    memory_region_init_ram_shared_nomigrate(mr, owner, name, size, false, errp);
 }
 
-void memory_region_init_ram_flags_nomigrate(MemoryRegion *mr,
-                                            Object *owner,
-                                            const char *name,
-                                            uint64_t size,
-                                            uint32_t ram_flags,
-                                            Error **errp)
+void memory_region_init_ram_shared_nomigrate(MemoryRegion *mr,
+                                             Object *owner,
+                                             const char *name,
+                                             uint64_t size,
+                                             bool share,
+                                             Error **errp)
 {
     Error *err = NULL;
     memory_region_init(mr, owner, name, size);
     mr->ram = true;
     mr->terminates = true;
     mr->destructor = memory_region_destructor_ram;
-    mr->ram_block = qemu_ram_alloc(size, ram_flags, mr, &err);
+    mr->ram_block = qemu_ram_alloc(size, share, mr, &err);
     if (err) {
         mr->size = int128_zero();
         object_unparent(OBJECT(mr));
@@ -1609,7 +1609,7 @@ void memory_region_init_ram_from_fd(MemoryRegion *mr,
                                     Object *owner,
                                     const char *name,
                                     uint64_t size,
-                                    uint32_t ram_flags,
+                                    bool share,
                                     int fd,
                                     ram_addr_t offset,
                                     Error **errp)
@@ -1619,8 +1619,9 @@ void memory_region_init_ram_from_fd(MemoryRegion *mr,
     mr->ram = true;
     mr->terminates = true;
     mr->destructor = memory_region_destructor_ram;
-    mr->ram_block = qemu_ram_alloc_from_fd(size, mr, ram_flags, fd, offset,
-                                           false, &err);
+    mr->ram_block = qemu_ram_alloc_from_fd(size, mr,
+                                           share ? RAM_SHARED : 0,
+                                           fd, offset, false, &err);
     if (err) {
         mr->size = int128_zero();
         object_unparent(OBJECT(mr));
@@ -1682,7 +1683,7 @@ void memory_region_init_rom_nomigrate(MemoryRegion *mr,
                                       uint64_t size,
                                       Error **errp)
 {
-    memory_region_init_ram_flags_nomigrate(mr, owner, name, size, 0, errp);
+    memory_region_init_ram_shared_nomigrate(mr, owner, name, size, false, errp);
     mr->readonly = true;
 }
 
@@ -1702,7 +1703,7 @@ void memory_region_init_rom_device_nomigrate(MemoryRegion *mr,
     mr->terminates = true;
     mr->rom_device = true;
     mr->destructor = memory_region_destructor_ram;
-    mr->ram_block = qemu_ram_alloc(size, 0, mr, &err);
+    mr->ram_block = qemu_ram_alloc(size, false,  mr, &err);
     if (err) {
         mr->size = int128_zero();
         object_unparent(OBJECT(mr));
diff --git a/softmmu/physmem.c b/softmmu/physmem.c
index 9b171c9dbe..1c8717684a 100644
--- a/softmmu/physmem.c
+++ b/softmmu/physmem.c
@@ -1540,7 +1540,6 @@ static void *file_ram_alloc(RAMBlock *block,
                             off_t offset,
                             Error **errp)
 {
-    uint32_t qemu_map_flags;
     void *area;
 
     block->page_size = qemu_fd_getpagesize(fd);
@@ -1588,11 +1587,9 @@ static void *file_ram_alloc(RAMBlock *block,
         perror("ftruncate");
     }
 
-    qemu_map_flags = readonly ? QEMU_MAP_READONLY : 0;
-    qemu_map_flags |= (block->flags & RAM_SHARED) ? QEMU_MAP_SHARED : 0;
-    qemu_map_flags |= (block->flags & RAM_PMEM) ? QEMU_MAP_SYNC : 0;
-    qemu_map_flags |= (block->flags & RAM_NORESERVE) ? QEMU_MAP_NORESERVE : 0;
-    area = qemu_ram_mmap(fd, memory, block->mr->align, qemu_map_flags, offset);
+    area = qemu_ram_mmap(fd, memory, block->mr->align, readonly,
+                         block->flags & RAM_SHARED, block->flags & RAM_PMEM,
+                         offset);
     if (area == MAP_FAILED) {
         error_setg_errno(errp, errno,
                          "unable to map backing store for guest RAM");
@@ -1717,11 +1714,6 @@ bool qemu_ram_is_shared(RAMBlock *rb)
     return rb->flags & RAM_SHARED;
 }
 
-bool qemu_ram_is_noreserve(RAMBlock *rb)
-{
-    return rb->flags & RAM_NORESERVE;
-}
-
 /* Note: Only set at the start of postcopy */
 bool qemu_ram_is_uf_zeroable(RAMBlock *rb)
 {
@@ -1954,10 +1946,8 @@ static void dirty_memory_extend(ram_addr_t old_ram_size,
     }
 }
 
-static void ram_block_add(RAMBlock *new_block, Error **errp)
+static void ram_block_add(RAMBlock *new_block, Error **errp, bool shared)
 {
-    const bool noreserve = qemu_ram_is_noreserve(new_block);
-    const bool shared = qemu_ram_is_shared(new_block);
     RAMBlock *block;
     RAMBlock *last_block = NULL;
     ram_addr_t old_ram_size, new_ram_size;
@@ -1980,7 +1970,7 @@ static void ram_block_add(RAMBlock *new_block, Error **errp)
         } else {
             new_block->host = qemu_anon_ram_alloc(new_block->max_length,
                                                   &new_block->mr->align,
-                                                  shared, noreserve);
+                                                  shared);
             if (!new_block->host) {
                 error_setg_errno(errp, errno,
                                  "cannot set up guest memory '%s'",
@@ -2052,7 +2042,7 @@ RAMBlock *qemu_ram_alloc_from_fd(ram_addr_t size, MemoryRegion *mr,
     int64_t file_size, file_align;
 
     /* Just support these ram flags by now. */
-    assert((ram_flags & ~(RAM_SHARED | RAM_PMEM | RAM_NORESERVE)) == 0);
+    assert((ram_flags & ~(RAM_SHARED | RAM_PMEM)) == 0);
 
     if (xen_enabled()) {
         error_setg(errp, "-mem-path not supported with Xen");
@@ -2094,7 +2084,7 @@ RAMBlock *qemu_ram_alloc_from_fd(ram_addr_t size, MemoryRegion *mr,
         return NULL;
     }
 
-    ram_block_add(new_block, &local_err);
+    ram_block_add(new_block, &local_err, ram_flags & RAM_SHARED);
     if (local_err) {
         g_free(new_block);
         error_propagate(errp, local_err);
@@ -2137,17 +2127,12 @@ RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
                                   void (*resized)(const char*,
                                                   uint64_t length,
                                                   void *host),
-                                  void *host, uint32_t ram_flags,
+                                  void *host, bool resizeable, bool share,
                                   MemoryRegion *mr, Error **errp)
 {
     RAMBlock *new_block;
     Error *local_err = NULL;
 
-    assert((ram_flags & ~(RAM_SHARED | RAM_RESIZEABLE | RAM_PREALLOC)) == 0);
-    assert((ram_flags & ~(RAM_SHARED | RAM_RESIZEABLE | RAM_PREALLOC |
-                          RAM_NORESERVE)) == 0);
-    assert(!host ^ (ram_flags & RAM_PREALLOC));
-
     size = HOST_PAGE_ALIGN(size);
     max_size = HOST_PAGE_ALIGN(max_size);
     new_block = g_malloc0(sizeof(*new_block));
@@ -2159,8 +2144,13 @@ RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
     new_block->fd = -1;
     new_block->page_size = qemu_real_host_page_size;
     new_block->host = host;
-    new_block->flags = ram_flags;
-    ram_block_add(new_block, &local_err);
+    if (host) {
+        new_block->flags |= RAM_PREALLOC;
+    }
+    if (resizeable) {
+        new_block->flags |= RAM_RESIZEABLE;
+    }
+    ram_block_add(new_block, &local_err, share);
     if (local_err) {
         g_free(new_block);
         error_propagate(errp, local_err);
@@ -2172,15 +2162,15 @@ RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
 RAMBlock *qemu_ram_alloc_from_ptr(ram_addr_t size, void *host,
                                    MemoryRegion *mr, Error **errp)
 {
-    return qemu_ram_alloc_internal(size, size, NULL, host, RAM_PREALLOC, mr,
-                                   errp);
+    return qemu_ram_alloc_internal(size, size, NULL, host, false,
+                                   false, mr, errp);
 }
 
-RAMBlock *qemu_ram_alloc(ram_addr_t size, uint32_t ram_flags,
+RAMBlock *qemu_ram_alloc(ram_addr_t size, bool share,
                          MemoryRegion *mr, Error **errp)
 {
-    assert((ram_flags & ~(RAM_SHARED | RAM_NORESERVE)) == 0);
-    return qemu_ram_alloc_internal(size, size, NULL, NULL, ram_flags, mr, errp);
+    return qemu_ram_alloc_internal(size, size, NULL, NULL, false,
+                                   share, mr, errp);
 }
 
 RAMBlock *qemu_ram_alloc_resizeable(ram_addr_t size, ram_addr_t maxsz,
@@ -2189,8 +2179,8 @@ RAMBlock *qemu_ram_alloc_resizeable(ram_addr_t size, ram_addr_t maxsz,
                                                      void *host),
                                      MemoryRegion *mr, Error **errp)
 {
-    return qemu_ram_alloc_internal(size, maxsz, resized, NULL,
-                                   RAM_RESIZEABLE, mr, errp);
+    return qemu_ram_alloc_internal(size, maxsz, resized, NULL, true,
+                                   false, mr, errp);
 }
 
 static void reclaim_ramblock(RAMBlock *block)
@@ -2249,14 +2239,13 @@ void qemu_ram_remap(ram_addr_t addr, ram_addr_t length)
                 abort();
             } else {
                 flags = MAP_FIXED;
-                flags |= block->flags & RAM_SHARED ?
-                         MAP_SHARED : MAP_PRIVATE;
-                flags |= block->flags & RAM_NORESERVE ? MAP_NORESERVE : 0;
                 if (block->fd >= 0) {
+                    flags |= (block->flags & RAM_SHARED ?
+                              MAP_SHARED : MAP_PRIVATE);
                     area = mmap(vaddr, length, PROT_READ | PROT_WRITE,
                                 flags, block->fd, offset);
                 } else {
-                    flags |= MAP_ANONYMOUS;
+                    flags |= MAP_PRIVATE | MAP_ANONYMOUS;
                     area = mmap(vaddr, length, PROT_READ | PROT_WRITE,
                                 flags, -1, 0);
                 }
@@ -3534,7 +3523,6 @@ int ram_block_discard_range(RAMBlock *rb, uint64_t start, size_t length)
         /* The logic here is messy;
          *    madvise DONTNEED fails for hugepages
          *    fallocate works on hugepages and shmem
-         *    shared anonymous memory requires madvise REMOVE
          */
         need_madvise = (rb->page_size == qemu_host_page_size);
         need_fallocate = rb->fd != -1;
@@ -3568,11 +3556,7 @@ int ram_block_discard_range(RAMBlock *rb, uint64_t start, size_t length)
              * fallocate'd away).
              */
 #if defined(CONFIG_MADVISE)
-            if (qemu_ram_is_shared(rb) && rb->fd < 0) {
-                ret = madvise(host_startaddr, length, QEMU_MADV_REMOVE);
-            } else {
-                ret = madvise(host_startaddr, length, QEMU_MADV_DONTNEED);
-            }
+            ret =  madvise(host_startaddr, length, MADV_DONTNEED);
             if (ret) {
                 ret = -errno;
                 error_report("ram_block_discard_range: Failed to discard range "
diff --git a/softmmu/runstate.c b/softmmu/runstate.c
index 10d9b7365a..15640572c0 100644
--- a/softmmu/runstate.c
+++ b/softmmu/runstate.c
@@ -747,7 +747,7 @@ static void qemu_run_exit_notifiers(void)
 
 void qemu_init_subsystems(void)
 {
-    Error *err = NULL;
+    Error *err;
 
     os_set_line_buffering();
 
diff --git a/softmmu/vl.c b/softmmu/vl.c
index feb4d201f3..326c1e9080 100644
--- a/softmmu/vl.c
+++ b/softmmu/vl.c
@@ -2522,7 +2522,7 @@ static void qemu_process_help_options(void)
 
 static void qemu_maybe_daemonize(const char *pid_file)
 {
-    Error *err = NULL;
+    Error *err;
 
     os_daemonize();
     rcu_disable_atfork();
diff --git a/target/i386/cpu.h b/target/i386/cpu.h
index 1e11071d81..ac3abea97c 100644
--- a/target/i386/cpu.h
+++ b/target/i386/cpu.h
@@ -224,8 +224,6 @@ typedef enum X86Seg {
 #define CR0_NE_MASK  (1U << 5)
 #define CR0_WP_MASK  (1U << 16)
 #define CR0_AM_MASK  (1U << 18)
-#define CR0_NW_MASK  (1U << 29)
-#define CR0_CD_MASK  (1U << 30)
 #define CR0_PG_MASK  (1U << 31)
 
 #define CR4_VME_MASK  (1U << 0)
@@ -2151,13 +2149,9 @@ static inline void
 cpu_svm_check_intercept_param(CPUX86State *env1, uint32_t type,
                               uint64_t param, uintptr_t retaddr)
 { /* no-op */ }
-static inline bool
-cpu_svm_has_intercept(CPUX86State *env, uint32_t type)
-{ return false; }
 #else
 void cpu_svm_check_intercept_param(CPUX86State *env1, uint32_t type,
                                    uint64_t param, uintptr_t retaddr);
-bool cpu_svm_has_intercept(CPUX86State *env, uint32_t type);
 #endif
 
 /* apic.c */
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index c676ee8b38..ad950c3c27 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -132,6 +132,9 @@ static struct kvm_cpuid2 *cpuid_cache;
 static struct kvm_cpuid2 *hv_cpuid_cache;
 static struct kvm_msr_list *kvm_feature_msrs;
 
+#define BUS_LOCK_SLICE_TIME 1000000000ULL /* ns */
+static RateLimit bus_lock_ratelimit_ctrl;
+
 int kvm_has_pit_state2(void)
 {
     return has_pit_state2;
@@ -2312,6 +2315,28 @@ int kvm_arch_init(MachineState *ms, KVMState *s)
         }
     }
 
+    if (object_dynamic_cast(OBJECT(ms), TYPE_X86_MACHINE)) {
+        X86MachineState *x86ms = X86_MACHINE(ms);
+
+        if (x86ms->bus_lock_ratelimit > 0) {
+            ret = kvm_check_extension(s, KVM_CAP_X86_BUS_LOCK_EXIT);
+            if (!(ret & KVM_BUS_LOCK_DETECTION_EXIT)) {
+                error_report("kvm: bus lock detection unsupported");
+                return -ENOTSUP;
+            }
+            ret = kvm_vm_enable_cap(s, KVM_CAP_X86_BUS_LOCK_EXIT, 0,
+                                    KVM_BUS_LOCK_DETECTION_EXIT);
+            if (ret < 0) {
+                error_report("kvm: Failed to enable bus lock detection cap: %s",
+                             strerror(-ret));
+                return ret;
+            }
+            ratelimit_init(&bus_lock_ratelimit_ctrl);
+            ratelimit_set_speed(&bus_lock_ratelimit_ctrl,
+                                x86ms->bus_lock_ratelimit, BUS_LOCK_SLICE_TIME);
+        }
+    }
+
     return 0;
 }
 
@@ -4266,6 +4291,15 @@ void kvm_arch_pre_run(CPUState *cpu, struct kvm_run *run)
     }
 }
 
+static void kvm_rate_limit_on_bus_lock(void)
+{
+    uint64_t delay_ns = ratelimit_calculate_delay(&bus_lock_ratelimit_ctrl, 1);
+
+    if (delay_ns) {
+        g_usleep(delay_ns / SCALE_US);
+    }
+}
+
 MemTxAttrs kvm_arch_post_run(CPUState *cpu, struct kvm_run *run)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
@@ -4281,6 +4315,9 @@ MemTxAttrs kvm_arch_post_run(CPUState *cpu, struct kvm_run *run)
     } else {
         env->eflags &= ~IF_MASK;
     }
+    if (run->flags & KVM_RUN_X86_BUS_LOCK) {
+        kvm_rate_limit_on_bus_lock();
+    }
 
     /* We need to protect the apic state against concurrent accesses from
      * different threads in case the userspace irqchip is used. */
@@ -4639,6 +4676,10 @@ int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)
         ioapic_eoi_broadcast(run->eoi.vector);
         ret = 0;
         break;
+    case KVM_EXIT_X86_BUS_LOCK:
+        /* already handled in kvm_arch_post_run */
+        ret = 0;
+        break;
     default:
         fprintf(stderr, "KVM: unknown exit reason %d\n", run->exit_reason);
         ret = -1;
diff --git a/target/i386/svm.h b/target/i386/svm.h
index 5098733053..87965e5bc2 100644
--- a/target/i386/svm.h
+++ b/target/i386/svm.h
@@ -135,8 +135,6 @@
 #define SVM_NPTEXIT_GPA     (1ULL << 32)
 #define SVM_NPTEXIT_GPT     (1ULL << 33)
 
-#define SVM_CR0_RESERVED_MASK 0xffffffff00000000U
-
 struct QEMU_PACKED vmcb_control_area {
 	uint16_t intercept_cr_read;
 	uint16_t intercept_cr_write;
diff --git a/target/i386/tcg/sysemu/misc_helper.c b/target/i386/tcg/sysemu/misc_helper.c
index db0d8a9d79..0cef2f1a4c 100644
--- a/target/i386/tcg/sysemu/misc_helper.c
+++ b/target/i386/tcg/sysemu/misc_helper.c
@@ -84,15 +84,6 @@ void helper_write_crN(CPUX86State *env, int reg, target_ulong t0)
 {
     switch (reg) {
     case 0:
-        /*
-        * If we reach this point, the CR0 write intercept is disabled.
-        * But we could still exit if the hypervisor has requested the selective
-        * intercept for bits other than TS and MP
-        */
-        if (cpu_svm_has_intercept(env, SVM_EXIT_CR0_SEL_WRITE) &&
-            ((env->cr[0] ^ t0) & ~(CR0_TS_MASK | CR0_MP_MASK))) {
-            cpu_vmexit(env, SVM_EXIT_CR0_SEL_WRITE, 0, GETPC());
-        }
         cpu_x86_update_cr0(env, t0);
         break;
     case 3:
diff --git a/target/i386/tcg/sysemu/svm_helper.c b/target/i386/tcg/sysemu/svm_helper.c
index 1c2dbc1862..9d671297cf 100644
--- a/target/i386/tcg/sysemu/svm_helper.c
+++ b/target/i386/tcg/sysemu/svm_helper.c
@@ -72,8 +72,6 @@ void helper_vmrun(CPUX86State *env, int aflag, int next_eip_addend)
     uint64_t nested_ctl;
     uint32_t event_inj;
     uint32_t int_ctl;
-    uint32_t asid;
-    uint64_t new_cr0;
 
     cpu_svm_check_intercept_param(env, SVM_EXIT_VMRUN, 0, GETPC());
 
@@ -156,18 +154,9 @@ void helper_vmrun(CPUX86State *env, int aflag, int next_eip_addend)
 
     nested_ctl = x86_ldq_phys(cs, env->vm_vmcb + offsetof(struct vmcb,
                                                           control.nested_ctl));
-    asid = x86_ldq_phys(cs, env->vm_vmcb + offsetof(struct vmcb,
-                                                          control.asid));
 
     env->nested_pg_mode = 0;
 
-    if (!cpu_svm_has_intercept(env, SVM_EXIT_VMRUN)) {
-        cpu_vmexit(env, SVM_EXIT_ERR, 0, GETPC());
-    }
-    if (asid == 0) {
-        cpu_vmexit(env, SVM_EXIT_ERR, 0, GETPC());
-    }
-
     if (nested_ctl & SVM_NPT_ENABLED) {
         env->nested_cr3 = x86_ldq_phys(cs,
                                 env->vm_vmcb + offsetof(struct vmcb,
@@ -193,18 +182,13 @@ void helper_vmrun(CPUX86State *env, int aflag, int next_eip_addend)
     env->idt.limit = x86_ldl_phys(cs, env->vm_vmcb + offsetof(struct vmcb,
                                                       save.idtr.limit));
 
-    new_cr0 = x86_ldq_phys(cs, env->vm_vmcb + offsetof(struct vmcb, save.cr0));
-    if (new_cr0 & SVM_CR0_RESERVED_MASK) {
-        cpu_vmexit(env, SVM_EXIT_ERR, 0, GETPC());
-    }
-    if ((new_cr0 & CR0_NW_MASK) && !(new_cr0 & CR0_CD_MASK)) {
-        cpu_vmexit(env, SVM_EXIT_ERR, 0, GETPC());
-    }
     /* clear exit_info_2 so we behave like the real hardware */
     x86_stq_phys(cs,
              env->vm_vmcb + offsetof(struct vmcb, control.exit_info_2), 0);
 
-    cpu_x86_update_cr0(env, new_cr0);
+    cpu_x86_update_cr0(env, x86_ldq_phys(cs,
+                                     env->vm_vmcb + offsetof(struct vmcb,
+                                                             save.cr0)));
     cpu_x86_update_cr4(env, x86_ldq_phys(cs,
                                      env->vm_vmcb + offsetof(struct vmcb,
                                                              save.cr4)));
@@ -428,91 +412,80 @@ void helper_clgi(CPUX86State *env)
     env->hflags2 &= ~HF2_GIF_MASK;
 }
 
-bool cpu_svm_has_intercept(CPUX86State *env, uint32_t type)
+void cpu_svm_check_intercept_param(CPUX86State *env, uint32_t type,
+                                   uint64_t param, uintptr_t retaddr)
 {
+    CPUState *cs = env_cpu(env);
+
+    if (likely(!(env->hflags & HF_GUEST_MASK))) {
+        return;
+    }
     switch (type) {
     case SVM_EXIT_READ_CR0 ... SVM_EXIT_READ_CR0 + 8:
         if (env->intercept_cr_read & (1 << (type - SVM_EXIT_READ_CR0))) {
-            return true;
+            cpu_vmexit(env, type, param, retaddr);
         }
         break;
     case SVM_EXIT_WRITE_CR0 ... SVM_EXIT_WRITE_CR0 + 8:
         if (env->intercept_cr_write & (1 << (type - SVM_EXIT_WRITE_CR0))) {
-            return true;
+            cpu_vmexit(env, type, param, retaddr);
         }
         break;
     case SVM_EXIT_READ_DR0 ... SVM_EXIT_READ_DR0 + 7:
         if (env->intercept_dr_read & (1 << (type - SVM_EXIT_READ_DR0))) {
-            return true;
+            cpu_vmexit(env, type, param, retaddr);
         }
         break;
     case SVM_EXIT_WRITE_DR0 ... SVM_EXIT_WRITE_DR0 + 7:
         if (env->intercept_dr_write & (1 << (type - SVM_EXIT_WRITE_DR0))) {
-            return true;
+            cpu_vmexit(env, type, param, retaddr);
         }
         break;
     case SVM_EXIT_EXCP_BASE ... SVM_EXIT_EXCP_BASE + 31:
         if (env->intercept_exceptions & (1 << (type - SVM_EXIT_EXCP_BASE))) {
-            return true;
+            cpu_vmexit(env, type, param, retaddr);
         }
         break;
-    default:
-        if (env->intercept & (1ULL << (type - SVM_EXIT_INTR))) {
-            return true;
+    case SVM_EXIT_MSR:
+        if (env->intercept & (1ULL << (SVM_EXIT_MSR - SVM_EXIT_INTR))) {
+            /* FIXME: this should be read in at vmrun (faster this way?) */
+            uint64_t addr = x86_ldq_phys(cs, env->vm_vmcb +
+                                     offsetof(struct vmcb,
+                                              control.msrpm_base_pa));
+            uint32_t t0, t1;
+
+            switch ((uint32_t)env->regs[R_ECX]) {
+            case 0 ... 0x1fff:
+                t0 = (env->regs[R_ECX] * 2) % 8;
+                t1 = (env->regs[R_ECX] * 2) / 8;
+                break;
+            case 0xc0000000 ... 0xc0001fff:
+                t0 = (8192 + env->regs[R_ECX] - 0xc0000000) * 2;
+                t1 = (t0 / 8);
+                t0 %= 8;
+                break;
+            case 0xc0010000 ... 0xc0011fff:
+                t0 = (16384 + env->regs[R_ECX] - 0xc0010000) * 2;
+                t1 = (t0 / 8);
+                t0 %= 8;
+                break;
+            default:
+                cpu_vmexit(env, type, param, retaddr);
+                t0 = 0;
+                t1 = 0;
+                break;
+            }
+            if (x86_ldub_phys(cs, addr + t1) & ((1 << param) << t0)) {
+                cpu_vmexit(env, type, param, retaddr);
+            }
         }
         break;
-    }
-    return false;
-}
-
-void cpu_svm_check_intercept_param(CPUX86State *env, uint32_t type,
-                                   uint64_t param, uintptr_t retaddr)
-{
-    CPUState *cs = env_cpu(env);
-
-    if (likely(!(env->hflags & HF_GUEST_MASK))) {
-        return;
-    }
-
-    if (!cpu_svm_has_intercept(env, type)) {
-        return;
-    }
-
-    if (type == SVM_EXIT_MSR) {
-        /* FIXME: this should be read in at vmrun (faster this way?) */
-        uint64_t addr = x86_ldq_phys(cs, env->vm_vmcb +
-                                    offsetof(struct vmcb,
-                                            control.msrpm_base_pa));
-        uint32_t t0, t1;
-
-        switch ((uint32_t)env->regs[R_ECX]) {
-        case 0 ... 0x1fff:
-            t0 = (env->regs[R_ECX] * 2) % 8;
-            t1 = (env->regs[R_ECX] * 2) / 8;
-            break;
-        case 0xc0000000 ... 0xc0001fff:
-            t0 = (8192 + env->regs[R_ECX] - 0xc0000000) * 2;
-            t1 = (t0 / 8);
-            t0 %= 8;
-            break;
-        case 0xc0010000 ... 0xc0011fff:
-            t0 = (16384 + env->regs[R_ECX] - 0xc0010000) * 2;
-            t1 = (t0 / 8);
-            t0 %= 8;
-            break;
-        default:
-            cpu_vmexit(env, type, param, retaddr);
-            t0 = 0;
-            t1 = 0;
-            break;
-        }
-        if (x86_ldub_phys(cs, addr + t1) & ((1 << param) << t0)) {
+    default:
+        if (env->intercept & (1ULL << (type - SVM_EXIT_INTR))) {
             cpu_vmexit(env, type, param, retaddr);
         }
-        return;
+        break;
     }
-
-    cpu_vmexit(env, type, param, retaddr);
 }
 
 void helper_svm_check_intercept(CPUX86State *env, uint32_t type)
diff --git a/tests/qtest/fuzz-sb16-test.c b/tests/qtest/fuzz-sb16-test.c
deleted file mode 100644
index 51030cd7dc..0000000000
--- a/tests/qtest/fuzz-sb16-test.c
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * QTest fuzzer-generated testcase for sb16 audio device
- *
- * Copyright (c) 2021 Philippe Mathieu-Daudé <f4bug@amsat.org>
- *
- * SPDX-License-Identifier: GPL-2.0-or-later
- */
-
-#include "qemu/osdep.h"
-#include "libqos/libqtest.h"
-
-/*
- * This used to trigger the assert in audio_calloc
- * https://bugs.launchpad.net/qemu/+bug/1910603
- */
-static void test_fuzz_sb16_0x1c(void)
-{
-    QTestState *s = qtest_init("-M q35 -display none "
-                               "-device sb16,audiodev=snd0 "
-                               "-audiodev none,id=snd0");
-    qtest_outw(s, 0x22c, 0x41);
-    qtest_outb(s, 0x22c, 0x00);
-    qtest_outw(s, 0x22c, 0x1004);
-    qtest_outw(s, 0x22c, 0x001c);
-    qtest_quit(s);
-}
-
-static void test_fuzz_sb16_0x91(void)
-{
-    QTestState *s = qtest_init("-M pc -display none "
-                               "-device sb16,audiodev=none "
-                               "-audiodev id=none,driver=none");
-    qtest_outw(s, 0x22c, 0xf141);
-    qtest_outb(s, 0x22c, 0x00);
-    qtest_outb(s, 0x22c, 0x24);
-    qtest_outb(s, 0x22c, 0x91);
-    qtest_quit(s);
-}
-
-int main(int argc, char **argv)
-{
-    const char *arch = qtest_get_arch();
-
-    g_test_init(&argc, &argv, NULL);
-
-   if (strcmp(arch, "i386") == 0) {
-        qtest_add_func("fuzz/test_fuzz_sb16/1c", test_fuzz_sb16_0x1c);
-        qtest_add_func("fuzz/test_fuzz_sb16/91", test_fuzz_sb16_0x91);
-   }
-
-   return g_test_run();
-}
diff --git a/tests/qtest/meson.build b/tests/qtest/meson.build
index b03e854170..c3a223a83d 100644
--- a/tests/qtest/meson.build
+++ b/tests/qtest/meson.build
@@ -20,7 +20,6 @@ slow_qtests = {
 qtests_generic = \
   (config_all_devices.has_key('CONFIG_MEGASAS_SCSI_PCI') ? ['fuzz-megasas-test'] : []) + \
   (config_all_devices.has_key('CONFIG_VIRTIO_SCSI') ? ['fuzz-virtio-scsi-test'] : []) + \
-  (config_all_devices.has_key('CONFIG_SB16') ? ['fuzz-sb16-test'] : []) + \
   [
   'cdrom-test',
   'device-introspect-test',
diff --git a/ui/vnc-auth-sasl.c b/ui/vnc-auth-sasl.c
index 47fdae5b21..df7dc08e9f 100644
--- a/ui/vnc-auth-sasl.c
+++ b/ui/vnc-auth-sasl.c
@@ -28,30 +28,10 @@
 #include "vnc.h"
 #include "trace.h"
 
-/*
- * Apple has deprecated sasl.h functions in OS X 10.11.  Therefore,
- * files that use SASL API need to disable -Wdeprecated-declarations.
- */
-#ifdef CONFIG_DARWIN
-#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-#endif
-
 /* Max amount of data we send/recv for SASL steps to prevent DOS */
 #define SASL_DATA_MAX_LEN (1024 * 1024)
 
 
-bool vnc_sasl_server_init(Error **errp)
-{
-    int saslErr = sasl_server_init(NULL, "qemu");
-
-    if (saslErr != SASL_OK) {
-        error_setg(errp, "Failed to initialize SASL auth: %s",
-                   sasl_errstring(saslErr, NULL, NULL));
-        return false;
-    }
-    return true;
-}
-
 void vnc_sasl_client_cleanup(VncState *vs)
 {
     if (vs->sasl.conn) {
diff --git a/ui/vnc-auth-sasl.h b/ui/vnc-auth-sasl.h
index 367b8672cc..1bfb86c6f5 100644
--- a/ui/vnc-auth-sasl.h
+++ b/ui/vnc-auth-sasl.h
@@ -63,7 +63,6 @@ struct VncDisplaySASL {
     char *authzid;
 };
 
-bool vnc_sasl_server_init(Error **errp);
 void vnc_sasl_client_cleanup(VncState *vs);
 
 size_t vnc_client_read_sasl(VncState *vs);
diff --git a/ui/vnc.c b/ui/vnc.c
index f0a1550d58..b3d4d7b9a5 100644
--- a/ui/vnc.c
+++ b/ui/vnc.c
@@ -4154,8 +4154,14 @@ void vnc_display_open(const char *id, Error **errp)
     trace_vnc_auth_init(vd, 1, vd->ws_auth, vd->ws_subauth);
 
 #ifdef CONFIG_VNC_SASL
-    if (sasl && !vnc_sasl_server_init(errp)) {
-        goto fail;
+    if (sasl) {
+        int saslErr = sasl_server_init(NULL, "qemu");
+
+        if (saslErr != SASL_OK) {
+            error_setg(errp, "Failed to initialize SASL auth: %s",
+                       sasl_errstring(saslErr, NULL, NULL));
+            goto fail;
+        }
     }
 #endif
     vd->lock_key_sync = lock_key_sync;
diff --git a/util/mmap-alloc.c b/util/mmap-alloc.c
index 838e286ce5..e6fa8b598b 100644
--- a/util/mmap-alloc.c
+++ b/util/mmap-alloc.c
@@ -20,8 +20,6 @@
 #include "qemu/osdep.h"
 #include "qemu/mmap-alloc.h"
 #include "qemu/host-utils.h"
-#include "qemu/cutils.h"
-#include "qemu/error-report.h"
 
 #define HUGETLBFS_MAGIC       0x958458f6
 
@@ -84,81 +82,32 @@ size_t qemu_mempath_getpagesize(const char *mem_path)
     return qemu_real_host_page_size;
 }
 
-#define OVERCOMMIT_MEMORY_PATH "/proc/sys/vm/overcommit_memory"
-static bool map_noreserve_effective(int fd, uint32_t qemu_map_flags)
+void *qemu_ram_mmap(int fd,
+                    size_t size,
+                    size_t align,
+                    bool readonly,
+                    bool shared,
+                    bool is_pmem,
+                    off_t map_offset)
 {
-#if defined(__linux__)
-    const bool readonly = qemu_map_flags & QEMU_MAP_READONLY;
-    const bool shared = qemu_map_flags & QEMU_MAP_SHARED;
-    gchar *content = NULL;
-    const char *endptr;
-    unsigned int tmp;
-
-    /*
-     * hugeltb accounting is different than ordinary swap reservation:
-     * a) Hugetlb pages from the pool are reserved for both private and
-     *    shared mappings. For shared mappings, all mappers have to specify
-     *    MAP_NORESERVE.
-     * b) MAP_NORESERVE is not affected by /proc/sys/vm/overcommit_memory.
-     */
-    if (qemu_fd_getpagesize(fd) != qemu_real_host_page_size) {
-        return true;
-    }
-
-    /*
-     * Accountable mappings in the kernel that can be affected by MAP_NORESEVE
-     * are private writable mappings (see mm/mmap.c:accountable_mapping() in
-     * Linux). For all shared or readonly mappings, MAP_NORESERVE is always
-     * implicitly active -- no reservation; this includes shmem. The only
-     * exception is shared anonymous memory, it is accounted like private
-     * anonymous memory.
-     */
-    if (readonly || (shared && fd >= 0)) {
-        return true;
-    }
+    int prot;
+    int flags;
+    int map_sync_flags = 0;
+    int guardfd;
+    size_t offset;
+    size_t pagesize;
+    size_t total;
+    void *guardptr;
+    void *ptr;
 
     /*
-     * MAP_NORESERVE is globally ignored for applicable !hugetlb mappings when
-     * memory overcommit is set to "never". Sparse memory regions aren't really
-     * possible in this system configuration.
-     *
-     * Bail out now instead of silently committing way more memory than
-     * currently desired by the user.
-     */
-    if (g_file_get_contents(OVERCOMMIT_MEMORY_PATH, &content, NULL, NULL) &&
-        !qemu_strtoui(content, &endptr, 0, &tmp) &&
-        (!endptr || *endptr == '\n')) {
-        if (tmp == 2) {
-            error_report("Skipping reservation of swap space is not supported:"
-                         " \"" OVERCOMMIT_MEMORY_PATH "\" is \"2\"");
-            return false;
-        }
-        return true;
-    }
-    /* this interface has been around since Linux 2.6 */
-    error_report("Skipping reservation of swap space is not supported:"
-                 " Could not read: \"" OVERCOMMIT_MEMORY_PATH "\"");
-    return false;
-#endif
-    /*
-     * E.g., FreeBSD used to define MAP_NORESERVE, never implemented it,
-     * and removed it a while ago.
+     * Note: this always allocates at least one extra page of virtual address
+     * space, even if size is already aligned.
      */
-    error_report("Skipping reservation of swap space is not supported");
-    return false;
-}
-
-/*
- * Reserve a new memory region of the requested size to be used for mapping
- * from the given fd (if any).
- */
-static void *mmap_reserve(size_t size, int fd)
-{
-    int flags = MAP_PRIVATE;
+    total = size + align;
 
 #if defined(__powerpc64__) && defined(__linux__)
-    /*
-     * On ppc64 mappings in the same segment (aka slice) must share the same
+    /* On ppc64 mappings in the same segment (aka slice) must share the same
      * page size. Since we will be re-allocating part of this segment
      * from the supplied fd, we should make sure to use the same page size, to
      * this end we mmap the supplied fd.  In this case, set MAP_NORESERVE to
@@ -166,55 +115,52 @@ static void *mmap_reserve(size_t size, int fd)
      * We do this unless we are using the system page size, in which case
      * anonymous memory is OK.
      */
-    if (fd == -1 || qemu_fd_getpagesize(fd) == qemu_real_host_page_size) {
-        fd = -1;
+    flags = MAP_PRIVATE;
+    pagesize = qemu_fd_getpagesize(fd);
+    if (fd == -1 || pagesize == qemu_real_host_page_size) {
+        guardfd = -1;
         flags |= MAP_ANONYMOUS;
     } else {
+        guardfd = fd;
         flags |= MAP_NORESERVE;
     }
 #else
-    fd = -1;
-    flags |= MAP_ANONYMOUS;
+    guardfd = -1;
+    pagesize = qemu_real_host_page_size;
+    flags = MAP_PRIVATE | MAP_ANONYMOUS;
 #endif
 
-    return mmap(0, size, PROT_NONE, flags, fd, 0);
-}
+    guardptr = mmap(0, total, PROT_NONE, flags, guardfd, 0);
 
-/*
- * Activate memory in a reserved region from the given fd (if any), to make
- * it accessible.
- */
-static void *mmap_activate(void *ptr, size_t size, int fd,
-                           uint32_t qemu_map_flags, off_t map_offset)
-{
-    const bool noreserve = qemu_map_flags & QEMU_MAP_NORESERVE;
-    const bool readonly = qemu_map_flags & QEMU_MAP_READONLY;
-    const bool shared = qemu_map_flags & QEMU_MAP_SHARED;
-    const bool sync = qemu_map_flags & QEMU_MAP_SYNC;
-    const int prot = PROT_READ | (readonly ? 0 : PROT_WRITE);
-    int map_sync_flags = 0;
-    int flags = MAP_FIXED;
-    void *activated_ptr;
-
-    if (noreserve && !map_noreserve_effective(fd, qemu_map_flags)) {
+    if (guardptr == MAP_FAILED) {
         return MAP_FAILED;
     }
 
+    assert(is_power_of_2(align));
+    /* Always align to host page size */
+    assert(align >= pagesize);
+
+    flags = MAP_FIXED;
     flags |= fd == -1 ? MAP_ANONYMOUS : 0;
     flags |= shared ? MAP_SHARED : MAP_PRIVATE;
-    flags |= noreserve ? MAP_NORESERVE : 0;
-    if (shared && sync) {
+    if (shared && is_pmem) {
         map_sync_flags = MAP_SYNC | MAP_SHARED_VALIDATE;
     }
 
-    activated_ptr = mmap(ptr, size, prot, flags | map_sync_flags, fd,
-                         map_offset);
-    if (activated_ptr == MAP_FAILED && map_sync_flags) {
-        if (errno == ENOTSUP) {
-            char *proc_link = g_strdup_printf("/proc/self/fd/%d", fd);
-            char *file_name = g_malloc0(PATH_MAX);
-            int len = readlink(proc_link, file_name, PATH_MAX - 1);
+    offset = QEMU_ALIGN_UP((uintptr_t)guardptr, align) - (uintptr_t)guardptr;
+
+    prot = PROT_READ | (readonly ? 0 : PROT_WRITE);
+
+    ptr = mmap(guardptr + offset, size, prot,
+               flags | map_sync_flags, fd, map_offset);
 
+    if (ptr == MAP_FAILED && map_sync_flags) {
+        if (errno == ENOTSUP) {
+            char *proc_link, *file_name;
+            int len;
+            proc_link = g_strdup_printf("/proc/self/fd/%d", fd);
+            file_name = g_malloc0(PATH_MAX);
+            len = readlink(proc_link, file_name, PATH_MAX - 1);
             if (len < 0) {
                 len = 0;
             }
@@ -227,53 +173,12 @@ static void *mmap_activate(void *ptr, size_t size, int fd,
             g_free(file_name);
         }
         /*
-         * If mmap failed with MAP_SHARED_VALIDATE | MAP_SYNC, we will try
-         * again without these flags to handle backwards compatibility.
+         * if map failed with MAP_SHARED_VALIDATE | MAP_SYNC,
+         * we will remove these flags to handle compatibility.
          */
-        activated_ptr = mmap(ptr, size, prot, flags, fd, map_offset);
+        ptr = mmap(guardptr + offset, size, prot, flags, fd, map_offset);
     }
-    return activated_ptr;
-}
 
-static inline size_t mmap_guard_pagesize(int fd)
-{
-#if defined(__powerpc64__) && defined(__linux__)
-    /* Mappings in the same segment must share the same page size */
-    return qemu_fd_getpagesize(fd);
-#else
-    return qemu_real_host_page_size;
-#endif
-}
-
-void *qemu_ram_mmap(int fd,
-                    size_t size,
-                    size_t align,
-                    uint32_t qemu_map_flags,
-                    off_t map_offset)
-{
-    const size_t guard_pagesize = mmap_guard_pagesize(fd);
-    size_t offset, total;
-    void *ptr, *guardptr;
-
-    /*
-     * Note: this always allocates at least one extra page of virtual address
-     * space, even if size is already aligned.
-     */
-    total = size + align;
-
-    guardptr = mmap_reserve(total, fd);
-    if (guardptr == MAP_FAILED) {
-        return MAP_FAILED;
-    }
-
-    assert(is_power_of_2(align));
-    /* Always align to host page size */
-    assert(align >= guard_pagesize);
-
-    offset = QEMU_ALIGN_UP((uintptr_t)guardptr, align) - (uintptr_t)guardptr;
-
-    ptr = mmap_activate(guardptr + offset, size, fd, qemu_map_flags,
-                        map_offset);
     if (ptr == MAP_FAILED) {
         munmap(guardptr, total);
         return MAP_FAILED;
@@ -288,8 +193,8 @@ void *qemu_ram_mmap(int fd,
      * a guard page guarding against potential buffer overflows.
      */
     total -= offset;
-    if (total > size + guard_pagesize) {
-        munmap(ptr + size + guard_pagesize, total - size - guard_pagesize);
+    if (total > size + pagesize) {
+        munmap(ptr + size + pagesize, total - size - pagesize);
     }
 
     return ptr;
@@ -297,8 +202,15 @@ void *qemu_ram_mmap(int fd,
 
 void qemu_ram_munmap(int fd, void *ptr, size_t size)
 {
+    size_t pagesize;
+
     if (ptr) {
         /* Unmap both the RAM block and the guard page */
-        munmap(ptr, size + mmap_guard_pagesize(fd));
+#if defined(__powerpc64__) && defined(__linux__)
+        pagesize = qemu_fd_getpagesize(fd);
+#else
+        pagesize = qemu_real_host_page_size;
+#endif
+        munmap(ptr, size + pagesize);
     }
 }
diff --git a/util/oslib-posix.c b/util/oslib-posix.c
index e8bdb02e1d..7b4bec1402 100644
--- a/util/oslib-posix.c
+++ b/util/oslib-posix.c
@@ -227,13 +227,10 @@ void *qemu_memalign(size_t alignment, size_t size)
 }
 
 /* alloc shared memory pages */
-void *qemu_anon_ram_alloc(size_t size, uint64_t *alignment, bool shared,
-                          bool noreserve)
+void *qemu_anon_ram_alloc(size_t size, uint64_t *alignment, bool shared)
 {
-    const uint32_t qemu_map_flags = (shared ? QEMU_MAP_SHARED : 0) |
-                                    (noreserve ? QEMU_MAP_NORESERVE : 0);
     size_t align = QEMU_VMALLOC_ALIGN;
-    void *ptr = qemu_ram_mmap(-1, size, align, qemu_map_flags, 0);
+    void *ptr = qemu_ram_mmap(-1, size, align, false, shared, false, 0);
 
     if (ptr == MAP_FAILED) {
         return NULL;
diff --git a/util/oslib-win32.c b/util/oslib-win32.c
index ee3a3692d8..ca99356fdf 100644
--- a/util/oslib-win32.c
+++ b/util/oslib-win32.c
@@ -38,7 +38,6 @@
 #include "trace.h"
 #include "qemu/sockets.h"
 #include "qemu/cutils.h"
-#include "qemu/error-report.h"
 #include <malloc.h>
 
 /* this must come after including "trace.h" */
@@ -77,20 +76,10 @@ static int get_allocation_granularity(void)
     return system_info.dwAllocationGranularity;
 }
 
-void *qemu_anon_ram_alloc(size_t size, uint64_t *align, bool shared,
-                          bool noreserve)
+void *qemu_anon_ram_alloc(size_t size, uint64_t *align, bool shared)
 {
     void *ptr;
 
-    if (noreserve) {
-        /*
-         * We need a MEM_COMMIT before accessing any memory in a MEM_RESERVE
-         * area; we cannot easily mimic POSIX MAP_NORESERVE semantics.
-         */
-        error_report("Skipping reservation of swap space is not supported.");
-        return NULL;
-    }
-
     ptr = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);
     trace_qemu_anon_ram_alloc(size, ptr);
 
diff --git a/util/qemu-config.c b/util/qemu-config.c
index 84ee6dc4ea..374f3bc460 100644
--- a/util/qemu-config.c
+++ b/util/qemu-config.c
@@ -429,14 +429,29 @@ out:
 void qemu_config_do_parse(const char *group, QDict *qdict, void *opaque, Error **errp)
 {
     QemuOptsList **lists = opaque;
+    const char *id = qdict_get_try_str(qdict, "id");
     QemuOptsList *list;
+    QemuOpts *opts;
+    const QDictEntry *unrecognized;
 
     list = find_list(lists, group, errp);
     if (!list) {
         return;
     }
 
-    qemu_opts_from_qdict(list, qdict, errp);
+    opts = qemu_opts_create(list, id, 1, errp);
+    if (!opts) {
+        return;
+    }
+    if (!qemu_opts_absorb_qdict(opts, qdict, errp)) {
+        qemu_opts_del(opts);
+        return;
+    }
+    unrecognized = qdict_first(qdict);
+    if (unrecognized) {
+        error_setg(errp, QERR_INVALID_PARAMETER, unrecognized->key);
+        qemu_opts_del(opts);
+    }
 }
 
 int qemu_config_parse(FILE *fp, QemuOptsList **lists, const char *fname, Error **errp)