diff --git a/backends/hostmem-file.c b/backends/hostmem-file.c
index 9b1b9f0a56..cd038024fa 100644
--- a/backends/hostmem-file.c
+++ b/backends/hostmem-file.c
@@ -39,6 +39,7 @@ file_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
                object_get_typename(OBJECT(backend)));
 #else
     HostMemoryBackendFile *fb = MEMORY_BACKEND_FILE(backend);
+    uint32_t ram_flags;
     gchar *name;
 
     if (!backend->size) {
@@ -51,11 +52,11 @@ file_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
     }
 
     name = host_memory_backend_get_name(backend);
-    memory_region_init_ram_from_file(&backend->mr, OBJECT(backend),
-                                     name,
-                                     backend->size, fb->align,
-                                     (backend->share ? RAM_SHARED : 0) |
-                                     (fb->is_pmem ? RAM_PMEM : 0),
+    ram_flags = backend->share ? RAM_SHARED : 0;
+    ram_flags |= backend->reserve ? 0 : RAM_NORESERVE;
+    ram_flags |= fb->is_pmem ? RAM_PMEM : 0;
+    memory_region_init_ram_from_file(&backend->mr, OBJECT(backend), name,
+                                     backend->size, fb->align, ram_flags,
                                      fb->mem_path, fb->readonly, errp);
     g_free(name);
 #endif
diff --git a/backends/hostmem-memfd.c b/backends/hostmem-memfd.c
index da75e27057..3fc85c3db8 100644
--- a/backends/hostmem-memfd.c
+++ b/backends/hostmem-memfd.c
@@ -35,6 +35,7 @@ static void
 memfd_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
 {
     HostMemoryBackendMemfd *m = MEMORY_BACKEND_MEMFD(backend);
+    uint32_t ram_flags;
     char *name;
     int fd;
 
@@ -52,9 +53,10 @@ memfd_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
     }
 
     name = host_memory_backend_get_name(backend);
-    memory_region_init_ram_from_fd(&backend->mr, OBJECT(backend),
-                                   name, backend->size,
-                                   backend->share, fd, 0, errp);
+    ram_flags = backend->share ? RAM_SHARED : 0;
+    ram_flags |= backend->reserve ? 0 : RAM_NORESERVE;
+    memory_region_init_ram_from_fd(&backend->mr, OBJECT(backend), name,
+                                   backend->size, ram_flags, fd, 0, errp);
     g_free(name);
 }
 
diff --git a/backends/hostmem-ram.c b/backends/hostmem-ram.c
index 5cc53e76c9..b8e55cdbd0 100644
--- a/backends/hostmem-ram.c
+++ b/backends/hostmem-ram.c
@@ -19,6 +19,7 @@
 static void
 ram_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
 {
+    uint32_t ram_flags;
     char *name;
 
     if (!backend->size) {
@@ -27,8 +28,10 @@ ram_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
     }
 
     name = host_memory_backend_get_name(backend);
-    memory_region_init_ram_shared_nomigrate(&backend->mr, OBJECT(backend), name,
-                           backend->size, backend->share, errp);
+    ram_flags = backend->share ? RAM_SHARED : 0;
+    ram_flags |= backend->reserve ? 0 : RAM_NORESERVE;
+    memory_region_init_ram_flags_nomigrate(&backend->mr, OBJECT(backend), name,
+                                           backend->size, ram_flags, errp);
     g_free(name);
 }
 
diff --git a/backends/hostmem.c b/backends/hostmem.c
index aab3de8408..4c05862ed5 100644
--- a/backends/hostmem.c
+++ b/backends/hostmem.c
@@ -216,6 +216,11 @@ static void host_memory_backend_set_prealloc(Object *obj, bool value,
     Error *local_err = NULL;
     HostMemoryBackend *backend = MEMORY_BACKEND(obj);
 
+    if (!backend->reserve && value) {
+        error_setg(errp, "'prealloc=on' and 'reserve=off' are incompatible");
+        return;
+    }
+
     if (!host_memory_backend_mr_inited(backend)) {
         backend->prealloc = value;
         return;
@@ -267,6 +272,7 @@ static void host_memory_backend_init(Object *obj)
     /* TODO: convert access to globals to compat properties */
     backend->merge = machine_mem_merge(machine);
     backend->dump = machine_dump_guest_core(machine);
+    backend->reserve = true;
     backend->prealloc_threads = 1;
 }
 
@@ -425,6 +431,30 @@ static void host_memory_backend_set_share(Object *o, bool value, Error **errp)
     backend->share = value;
 }
 
+#ifdef CONFIG_LINUX
+static bool host_memory_backend_get_reserve(Object *o, Error **errp)
+{
+    HostMemoryBackend *backend = MEMORY_BACKEND(o);
+
+    return backend->reserve;
+}
+
+static void host_memory_backend_set_reserve(Object *o, bool value, Error **errp)
+{
+    HostMemoryBackend *backend = MEMORY_BACKEND(o);
+
+    if (host_memory_backend_mr_inited(backend)) {
+        error_setg(errp, "cannot change property value");
+        return;
+    }
+    if (backend->prealloc && !value) {
+        error_setg(errp, "'prealloc=on' and 'reserve=off' are incompatible");
+        return;
+    }
+    backend->reserve = value;
+}
+#endif /* CONFIG_LINUX */
+
 static bool
 host_memory_backend_get_use_canonical_path(Object *obj, Error **errp)
 {
@@ -493,6 +523,12 @@ host_memory_backend_class_init(ObjectClass *oc, void *data)
         host_memory_backend_get_share, host_memory_backend_set_share);
     object_class_property_set_description(oc, "share",
         "Mark the memory as private to QEMU or shared");
+#ifdef CONFIG_LINUX
+    object_class_property_add_bool(oc, "reserve",
+        host_memory_backend_get_reserve, host_memory_backend_set_reserve);
+    object_class_property_set_description(oc, "reserve",
+        "Reserve swap space (or huge pages) if applicable");
+#endif /* CONFIG_LINUX */
     /*
      * Do not delete/rename option. This option must be considered stable
      * (as if it didn't have the 'x-' prefix including deprecation period) as
diff --git a/configure b/configure
index debd50c085..262ab71802 100755
--- a/configure
+++ b/configure
@@ -6366,7 +6366,7 @@ if test "$skip_meson" = no; then
         i386)
             echo "cpu_family = 'x86'" >> $cross
             ;;
-        x86_64)
+        x86_64|x32)
             echo "cpu_family = 'x86_64'" >> $cross
             ;;
         ppc64le)
diff --git a/hw/core/machine-hmp-cmds.c b/hw/core/machine-hmp-cmds.c
index 58248cffa3..76b22b00d6 100644
--- a/hw/core/machine-hmp-cmds.c
+++ b/hw/core/machine-hmp-cmds.c
@@ -110,6 +110,12 @@ void hmp_info_memdev(Monitor *mon, const QDict *qdict)
                        m->value->dump ? "true" : "false");
         monitor_printf(mon, "  prealloc: %s\n",
                        m->value->prealloc ? "true" : "false");
+        monitor_printf(mon, "  share: %s\n",
+                       m->value->share ? "true" : "false");
+        if (m->value->has_reserve) {
+            monitor_printf(mon, "  reserve: %s\n",
+                           m->value->reserve ? "true" : "false");
+        }
         monitor_printf(mon, "  policy: %s\n",
                        HostMemPolicy_str(m->value->policy));
         visit_complete(v, &str);
diff --git a/hw/core/machine-qmp-cmds.c b/hw/core/machine-qmp-cmds.c
index a36c96608f..216fdfaf3a 100644
--- a/hw/core/machine-qmp-cmds.c
+++ b/hw/core/machine-qmp-cmds.c
@@ -157,6 +157,7 @@ void qmp_set_numa_node(NumaOptions *cmd, Error **errp)
 
 static int query_memdev(Object *obj, void *opaque)
 {
+    Error *err = NULL;
     MemdevList **list = opaque;
     Memdev *m;
     QObject *host_nodes;
@@ -172,6 +173,13 @@ static int query_memdev(Object *obj, void *opaque)
         m->merge = object_property_get_bool(obj, "merge", &error_abort);
         m->dump = object_property_get_bool(obj, "dump", &error_abort);
         m->prealloc = object_property_get_bool(obj, "prealloc", &error_abort);
+        m->share = object_property_get_bool(obj, "share", &error_abort);
+        m->reserve = object_property_get_bool(obj, "reserve", &err);
+        if (err) {
+            error_free_or_abort(&err);
+        } else {
+            m->has_reserve = true;
+        }
         m->policy = object_property_get_enum(obj, "policy", "HostMemPolicy",
                                              &error_abort);
         host_nodes = object_property_get_qobject(obj,
diff --git a/hw/m68k/next-cube.c b/hw/m68k/next-cube.c
index de951ffe5d..e0d4a94f9d 100644
--- a/hw/m68k/next-cube.c
+++ b/hw/m68k/next-cube.c
@@ -984,8 +984,8 @@ static void next_cube_init(MachineState *machine)
     sysbus_mmio_map(SYS_BUS_DEVICE(pcdev), 1, 0x02100000);
 
     /* BMAP memory */
-    memory_region_init_ram_shared_nomigrate(bmapm1, NULL, "next.bmapmem", 64,
-                                            true, &error_fatal);
+    memory_region_init_ram_flags_nomigrate(bmapm1, NULL, "next.bmapmem", 64,
+                                           RAM_SHARED, &error_fatal);
     memory_region_add_subregion(sysmem, 0x020c0000, bmapm1);
     /* The Rev_2.5_v66.bin firmware accesses it at 0x820c0020, too */
     memory_region_init_alias(bmapm2, NULL, "next.bmapmem2", bmapm1, 0x0, 64);
diff --git a/hw/misc/ivshmem.c b/hw/misc/ivshmem.c
index a1fa4878be..1ba4a98377 100644
--- a/hw/misc/ivshmem.c
+++ b/hw/misc/ivshmem.c
@@ -493,9 +493,8 @@ static void process_msg_shmem(IVShmemState *s, int fd, Error **errp)
     size = buf.st_size;
 
     /* mmap the region and map into the BAR2 */
-    memory_region_init_ram_from_fd(&s->server_bar2, OBJECT(s),
-                                   "ivshmem.bar2", size, true, fd, 0,
-                                   &local_err);
+    memory_region_init_ram_from_fd(&s->server_bar2, OBJECT(s), "ivshmem.bar2",
+                                   size, RAM_SHARED, fd, 0, &local_err);
     if (local_err) {
         error_propagate(errp, local_err);
         return;
diff --git a/hw/scsi/esp.c b/hw/scsi/esp.c
index b668acef82..4ac2114788 100644
--- a/hw/scsi/esp.c
+++ b/hw/scsi/esp.c
@@ -213,7 +213,7 @@ static int esp_select(ESPState *s)
     if (!s->current_dev) {
         /* No such drive */
         s->rregs[ESP_RSTAT] = 0;
-        s->rregs[ESP_RINTR] |= INTR_DC;
+        s->rregs[ESP_RINTR] = INTR_DC;
         s->rregs[ESP_RSEQ] = SEQ_0;
         esp_raise_irq(s);
         return -1;
@@ -221,7 +221,7 @@ static int esp_select(ESPState *s)
 
     /*
      * Note that we deliberately don't raise the IRQ here: this will be done
-     * either in do_busid_cmd() for DATA OUT transfers or by the deferred
+     * either in do_command_phase() for DATA OUT transfers or by the deferred
      * IRQ mechanism in esp_transfer_data() for DATA IN transfers
      */
     s->rregs[ESP_RINTR] |= INTR_FC;
@@ -260,9 +260,6 @@ static uint32_t get_cmd(ESPState *s, uint32_t maxlen)
             return 0;
         }
         n = esp_fifo_pop_buf(&s->fifo, buf, dmalen);
-        if (n >= 3) {
-            buf[0] = buf[2] >> 5;
-        }
         n = MIN(fifo8_num_free(&s->cmdfifo), n);
         fifo8_push_all(&s->cmdfifo, buf, n);
     }
@@ -275,24 +272,22 @@ static uint32_t get_cmd(ESPState *s, uint32_t maxlen)
     return dmalen;
 }
 
-static void do_busid_cmd(ESPState *s, uint8_t busid)
+static void do_command_phase(ESPState *s)
 {
     uint32_t cmdlen;
     int32_t datalen;
-    int lun;
     SCSIDevice *current_lun;
     uint8_t buf[ESP_CMDFIFO_SZ];
 
-    trace_esp_do_busid_cmd(busid);
-    lun = busid & 7;
+    trace_esp_do_command_phase(s->lun);
     cmdlen = fifo8_num_used(&s->cmdfifo);
     if (!cmdlen || !s->current_dev) {
         return;
     }
     esp_fifo_pop_buf(&s->cmdfifo, buf, cmdlen);
 
-    current_lun = scsi_device_find(&s->bus, 0, s->current_dev->id, lun);
-    s->current_req = scsi_req_new(current_lun, 0, lun, buf, s);
+    current_lun = scsi_device_find(&s->bus, 0, s->current_dev->id, s->lun);
+    s->current_req = scsi_req_new(current_lun, 0, s->lun, buf, s);
     datalen = scsi_req_enqueue(s->current_req);
     s->ti_size = datalen;
     fifo8_reset(&s->cmdfifo);
@@ -319,28 +314,36 @@ static void do_busid_cmd(ESPState *s, uint8_t busid)
     }
 }
 
-static void do_cmd(ESPState *s)
+static void do_message_phase(ESPState *s)
 {
-    uint8_t busid = esp_fifo_pop(&s->cmdfifo);
-    int len;
+    if (s->cmdfifo_cdb_offset) {
+        uint8_t message = esp_fifo_pop(&s->cmdfifo);
 
-    s->cmdfifo_cdb_offset--;
+        trace_esp_do_identify(message);
+        s->lun = message & 7;
+        s->cmdfifo_cdb_offset--;
+    }
 
     /* Ignore extended messages for now */
     if (s->cmdfifo_cdb_offset) {
-        len = MIN(s->cmdfifo_cdb_offset, fifo8_num_used(&s->cmdfifo));
+        int len = MIN(s->cmdfifo_cdb_offset, fifo8_num_used(&s->cmdfifo));
         esp_fifo_pop_buf(&s->cmdfifo, NULL, len);
         s->cmdfifo_cdb_offset = 0;
     }
+}
 
-    do_busid_cmd(s, busid);
+static void do_cmd(ESPState *s)
+{
+    do_message_phase(s);
+    assert(s->cmdfifo_cdb_offset == 0);
+    do_command_phase(s);
 }
 
 static void satn_pdma_cb(ESPState *s)
 {
-    s->do_cmd = 0;
-    if (!fifo8_is_empty(&s->cmdfifo)) {
+    if (!esp_get_tc(s) && !fifo8_is_empty(&s->cmdfifo)) {
         s->cmdfifo_cdb_offset = 1;
+        s->do_cmd = 0;
         do_cmd(s);
     }
 }
@@ -369,13 +372,10 @@ static void handle_satn(ESPState *s)
 
 static void s_without_satn_pdma_cb(ESPState *s)
 {
-    uint32_t len;
-
-    s->do_cmd = 0;
-    len = fifo8_num_used(&s->cmdfifo);
-    if (len) {
+    if (!esp_get_tc(s) && !fifo8_is_empty(&s->cmdfifo)) {
         s->cmdfifo_cdb_offset = 0;
-        do_busid_cmd(s, 0);
+        s->do_cmd = 0;
+        do_cmd(s);
     }
 }
 
@@ -392,7 +392,7 @@ static void handle_s_without_atn(ESPState *s)
     if (cmdlen > 0) {
         s->cmdfifo_cdb_offset = 0;
         s->do_cmd = 0;
-        do_busid_cmd(s, 0);
+        do_cmd(s);
     } else if (cmdlen == 0) {
         s->do_cmd = 1;
         /* Target present, but no cmd yet - switch to command phase */
@@ -403,8 +403,7 @@ static void handle_s_without_atn(ESPState *s)
 
 static void satn_stop_pdma_cb(ESPState *s)
 {
-    s->do_cmd = 0;
-    if (!fifo8_is_empty(&s->cmdfifo)) {
+    if (!esp_get_tc(s) && !fifo8_is_empty(&s->cmdfifo)) {
         trace_esp_handle_satn_stop(fifo8_num_used(&s->cmdfifo));
         s->do_cmd = 1;
         s->cmdfifo_cdb_offset = 1;
@@ -481,7 +480,6 @@ static void esp_dma_done(ESPState *s)
 {
     s->rregs[ESP_RSTAT] |= STAT_TC;
     s->rregs[ESP_RINTR] |= INTR_BS;
-    s->rregs[ESP_RSEQ] = 0;
     s->rregs[ESP_RFLAGS] = 0;
     esp_set_tc(s, 0);
     esp_raise_irq(s);
@@ -494,10 +492,32 @@ static void do_dma_pdma_cb(ESPState *s)
     uint32_t n;
 
     if (s->do_cmd) {
+        /* Ensure we have received complete command after SATN and stop */
+        if (esp_get_tc(s) || fifo8_is_empty(&s->cmdfifo)) {
+            return;
+        }
+
         s->ti_size = 0;
-        s->do_cmd = 0;
-        do_cmd(s);
-        esp_lower_drq(s);
+        if ((s->rregs[ESP_RSTAT] & 7) == STAT_CD) {
+            /* No command received */
+            if (s->cmdfifo_cdb_offset == fifo8_num_used(&s->cmdfifo)) {
+                return;
+            }
+
+            /* Command has been received */
+            s->do_cmd = 0;
+            do_cmd(s);
+        } else {
+            /*
+             * Extra message out bytes received: update cmdfifo_cdb_offset
+             * and then switch to commmand phase
+             */
+            s->cmdfifo_cdb_offset = fifo8_num_used(&s->cmdfifo);
+            s->rregs[ESP_RSTAT] = STAT_TC | STAT_CD;
+            s->rregs[ESP_RSEQ] = SEQ_CD;
+            s->rregs[ESP_RINTR] |= INTR_BS;
+            esp_raise_irq(s);
+        }
         return;
     }
 
@@ -740,20 +760,17 @@ static void esp_do_nodma(ESPState *s)
         s->async_len -= len;
         s->ti_size += len;
     } else {
-        len = MIN(s->ti_size, s->async_len);
-        len = MIN(len, fifo8_num_free(&s->fifo));
-        fifo8_push_all(&s->fifo, s->async_buf, len);
-        s->async_buf += len;
-        s->async_len -= len;
-        s->ti_size -= len;
+        if (fifo8_is_empty(&s->fifo)) {
+            fifo8_push(&s->fifo, s->async_buf[0]);
+            s->async_buf++;
+            s->async_len--;
+            s->ti_size--;
+        }
     }
 
     if (s->async_len == 0) {
         scsi_req_continue(s->current_req);
-
-        if (to_device || s->ti_size == 0) {
-            return;
-        }
+        return;
     }
 
     s->rregs[ESP_RINTR] |= INTR_BS;
@@ -763,20 +780,37 @@ static void esp_do_nodma(ESPState *s)
 void esp_command_complete(SCSIRequest *req, size_t resid)
 {
     ESPState *s = req->hba_private;
+    int to_device = ((s->rregs[ESP_RSTAT] & 7) == STAT_DO);
 
     trace_esp_command_complete();
-    if (s->ti_size != 0) {
-        trace_esp_command_complete_unexpected();
+
+    /*
+     * Non-DMA transfers from the target will leave the last byte in
+     * the FIFO so don't reset ti_size in this case
+     */
+    if (s->dma || to_device) {
+        if (s->ti_size != 0) {
+            trace_esp_command_complete_unexpected();
+        }
+        s->ti_size = 0;
     }
-    s->ti_size = 0;
+
     s->async_len = 0;
     if (req->status) {
         trace_esp_command_complete_fail();
     }
     s->status = req->status;
-    s->rregs[ESP_RSTAT] = STAT_ST;
-    esp_dma_done(s);
-    esp_lower_drq(s);
+
+    /*
+     * If the transfer is finished, switch to status phase. For non-DMA
+     * transfers from the target the last byte is still in the FIFO
+     */
+    if (s->ti_size == 0) {
+        s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;
+        esp_dma_done(s);
+        esp_lower_drq(s);
+    }
+
     if (s->current_req) {
         scsi_req_unref(s->current_req);
         s->current_req = NULL;
@@ -804,16 +838,6 @@ void esp_transfer_data(SCSIRequest *req, uint32_t len)
         s->rregs[ESP_RSTAT] |= STAT_TC;
         s->rregs[ESP_RINTR] |= INTR_BS;
         esp_raise_irq(s);
-
-        /*
-         * If data is ready to transfer and the TI command has already
-         * been executed, start DMA immediately. Otherwise DMA will start
-         * when host sends the TI command
-         */
-        if (s->ti_size && (s->rregs[ESP_CMD] == (CMD_TI | CMD_DMA))) {
-            esp_do_dma(s);
-        }
-        return;
     }
 
     if (s->ti_cmd == 0) {
@@ -827,7 +851,7 @@ void esp_transfer_data(SCSIRequest *req, uint32_t len)
         return;
     }
 
-    if (s->ti_cmd & CMD_DMA) {
+    if (s->ti_cmd == (CMD_TI | CMD_DMA)) {
         if (dmalen) {
             esp_do_dma(s);
         } else if (s->ti_size <= 0) {
@@ -838,7 +862,7 @@ void esp_transfer_data(SCSIRequest *req, uint32_t len)
             esp_dma_done(s);
             esp_lower_drq(s);
         }
-    } else {
+    } else if (s->ti_cmd == CMD_TI) {
         esp_do_nodma(s);
     }
 }
@@ -905,6 +929,17 @@ uint64_t esp_reg_read(ESPState *s, uint32_t saddr)
             qemu_log_mask(LOG_UNIMP, "esp: PIO data read not implemented\n");
             s->rregs[ESP_FIFO] = 0;
         } else {
+            if ((s->rregs[ESP_RSTAT] & 0x7) == STAT_DI) {
+                if (s->ti_size) {
+                    esp_do_nodma(s);
+                } else {
+                    /*
+                     * The last byte of a non-DMA transfer has been read out
+                     * of the FIFO so switch to status phase
+                     */
+                    s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;
+                }
+            }
             s->rregs[ESP_FIFO] = esp_fifo_pop(&s->fifo);
         }
         val = s->rregs[ESP_FIFO];
@@ -917,7 +952,15 @@ uint64_t esp_reg_read(ESPState *s, uint32_t saddr)
         val = s->rregs[ESP_RINTR];
         s->rregs[ESP_RINTR] = 0;
         s->rregs[ESP_RSTAT] &= ~STAT_TC;
-        s->rregs[ESP_RSEQ] = SEQ_0;
+        /*
+         * According to the datasheet ESP_RSEQ should be cleared, but as the
+         * emulation currently defers information transfers to the next TI
+         * command leave it for now so that pedantic guests such as the old
+         * Linux 2.6 driver see the correct flags before the next SCSI phase
+         * transition.
+         *
+         * s->rregs[ESP_RSEQ] = SEQ_0;
+         */
         esp_lower_irq(s);
         break;
     case ESP_TCHI:
@@ -955,15 +998,18 @@ void esp_reg_write(ESPState *s, uint32_t saddr, uint64_t val)
     case ESP_FIFO:
         if (s->do_cmd) {
             esp_fifo_push(&s->cmdfifo, val);
+
+            /*
+             * If any unexpected message out/command phase data is
+             * transferred using non-DMA, raise the interrupt
+             */
+            if (s->rregs[ESP_CMD] == CMD_TI) {
+                s->rregs[ESP_RINTR] |= INTR_BS;
+                esp_raise_irq(s);
+            }
         } else {
             esp_fifo_push(&s->fifo, val);
         }
-
-        /* Non-DMA transfers raise an interrupt after every byte */
-        if (s->rregs[ESP_CMD] == CMD_TI) {
-            s->rregs[ESP_RINTR] |= INTR_FC | INTR_BS;
-            esp_raise_irq(s);
-        }
         break;
     case ESP_CMD:
         s->rregs[saddr] = val;
@@ -1088,7 +1134,15 @@ static bool esp_is_version_5(void *opaque, int version_id)
     ESPState *s = ESP(opaque);
 
     version_id = MIN(version_id, s->mig_version_id);
-    return version_id == 5;
+    return version_id >= 5;
+}
+
+static bool esp_is_version_6(void *opaque, int version_id)
+{
+    ESPState *s = ESP(opaque);
+
+    version_id = MIN(version_id, s->mig_version_id);
+    return version_id >= 6;
 }
 
 int esp_pre_save(void *opaque)
@@ -1128,7 +1182,7 @@ static int esp_post_load(void *opaque, int version_id)
 
 const VMStateDescription vmstate_esp = {
     .name = "esp",
-    .version_id = 5,
+    .version_id = 6,
     .minimum_version_id = 3,
     .post_load = esp_post_load,
     .fields = (VMStateField[]) {
@@ -1157,6 +1211,7 @@ const VMStateDescription vmstate_esp = {
         VMSTATE_FIFO8_TEST(fifo, ESPState, esp_is_version_5),
         VMSTATE_FIFO8_TEST(cmdfifo, ESPState, esp_is_version_5),
         VMSTATE_UINT8_TEST(ti_cmd, ESPState, esp_is_version_5),
+        VMSTATE_UINT8_TEST(lun, ESPState, esp_is_version_6),
         VMSTATE_END_OF_LIST()
     },
 };
@@ -1195,7 +1250,6 @@ static void sysbus_esp_pdma_write(void *opaque, hwaddr addr,
 {
     SysBusESPState *sysbus = opaque;
     ESPState *s = ESP(&sysbus->esp);
-    uint32_t dmalen;
 
     trace_esp_pdma_write(size);
 
@@ -1208,10 +1262,7 @@ static void sysbus_esp_pdma_write(void *opaque, hwaddr addr,
         esp_pdma_write(s, val);
         break;
     }
-    dmalen = esp_get_tc(s);
-    if (dmalen == 0 || fifo8_num_free(&s->fifo) < 2) {
-        s->pdma_cb(s);
-    }
+    s->pdma_cb(s);
 }
 
 static uint64_t sysbus_esp_pdma_read(void *opaque, hwaddr addr,
diff --git a/hw/scsi/scsi-generic.c b/hw/scsi/scsi-generic.c
index 98c30c5d5c..40e039864f 100644
--- a/hw/scsi/scsi-generic.c
+++ b/hw/scsi/scsi-generic.c
@@ -147,7 +147,7 @@ static int execute_command(BlockBackend *blk,
     return 0;
 }
 
-static void scsi_handle_inquiry_reply(SCSIGenericReq *r, SCSIDevice *s)
+static int scsi_handle_inquiry_reply(SCSIGenericReq *r, SCSIDevice *s, int len)
 {
     uint8_t page, page_idx;
 
@@ -213,8 +213,13 @@ static void scsi_handle_inquiry_reply(SCSIGenericReq *r, SCSIDevice *s)
                 r->buf[page_idx] = 0xb0;
             }
             stw_be_p(r->buf + 2, lduw_be_p(r->buf + 2) + 1);
+
+            if (len < r->buflen) {
+                len++;
+            }
         }
     }
+    return len;
 }
 
 static int scsi_generic_emulate_block_limits(SCSIGenericReq *r, SCSIDevice *s)
@@ -332,7 +337,7 @@ static void scsi_read_complete(void * opaque, int ret)
         }
     }
     if (r->req.cmd.buf[0] == INQUIRY) {
-        scsi_handle_inquiry_reply(r, s);
+        len = scsi_handle_inquiry_reply(r, s, len);
     }
 
 req_complete:
diff --git a/hw/scsi/trace-events b/hw/scsi/trace-events
index 1a27e141ae..92d5b40f89 100644
--- a/hw/scsi/trace-events
+++ b/hw/scsi/trace-events
@@ -166,7 +166,8 @@ esp_dma_disable(void) "Lower enable"
 esp_pdma_read(int size) "pDMA read %u bytes"
 esp_pdma_write(int size) "pDMA write %u bytes"
 esp_get_cmd(uint32_t dmalen, int target) "len %d target %d"
-esp_do_busid_cmd(uint8_t busid) "busid 0x%x"
+esp_do_command_phase(uint8_t busid) "busid 0x%x"
+esp_do_identify(uint8_t byte) "0x%x"
 esp_handle_satn_stop(uint32_t cmdlen) "cmdlen %d"
 esp_write_response(uint32_t status) "Transfer status (status=%d)"
 esp_do_dma(uint32_t cmdlen, uint32_t len) "command len %d + %d"
diff --git a/include/exec/cpu-common.h b/include/exec/cpu-common.h
index ccabed4003..039d422bf4 100644
--- a/include/exec/cpu-common.h
+++ b/include/exec/cpu-common.h
@@ -59,6 +59,7 @@ ram_addr_t qemu_ram_get_offset(RAMBlock *rb);
 ram_addr_t qemu_ram_get_used_length(RAMBlock *rb);
 ram_addr_t qemu_ram_get_max_length(RAMBlock *rb);
 bool qemu_ram_is_shared(RAMBlock *rb);
+bool qemu_ram_is_noreserve(RAMBlock *rb);
 bool qemu_ram_is_uf_zeroable(RAMBlock *rb);
 void qemu_ram_set_uf_zeroable(RAMBlock *rb);
 bool qemu_ram_is_migratable(RAMBlock *rb);
diff --git a/include/exec/memory.h b/include/exec/memory.h
index b114f5454b..b116f7c64e 100644
--- a/include/exec/memory.h
+++ b/include/exec/memory.h
@@ -155,6 +155,13 @@ typedef struct IOMMUTLBEvent {
  */
 #define RAM_UF_WRITEPROTECT (1 << 6)
 
+/*
+ * RAM is mmap-ed with MAP_NORESERVE. When set, reserving swap space (or huge
+ * pages if applicable) is skipped: will bail out if not supported. When not
+ * set, the OS will do the reservation, if supported for the memory type.
+ */
+#define RAM_NORESERVE (1 << 7)
+
 static inline void iommu_notifier_init(IOMMUNotifier *n, IOMMUNotify fn,
                                        IOMMUNotifierFlag flags,
                                        hwaddr start, hwaddr end,
@@ -940,27 +947,27 @@ void memory_region_init_ram_nomigrate(MemoryRegion *mr,
                                       Error **errp);
 
 /**
- * memory_region_init_ram_shared_nomigrate:  Initialize RAM memory region.
- *                                           Accesses into the region will
- *                                           modify memory directly.
+ * memory_region_init_ram_flags_nomigrate:  Initialize RAM memory region.
+ *                                          Accesses into the region will
+ *                                          modify memory directly.
  *
  * @mr: the #MemoryRegion to be initialized.
  * @owner: the object that tracks the region's reference count
  * @name: Region name, becomes part of RAMBlock name used in migration stream
  *        must be unique within any device
  * @size: size of the region.
- * @share: allow remapping RAM to different addresses
+ * @ram_flags: RamBlock flags. Supported flags: RAM_SHARED, RAM_NORESERVE.
  * @errp: pointer to Error*, to store an error if it happens.
  *
- * Note that this function is similar to memory_region_init_ram_nomigrate.
- * The only difference is part of the RAM region can be remapped.
+ * Note that this function does not do anything to cause the data in the
+ * RAM memory region to be migrated; that is the responsibility of the caller.
  */
-void memory_region_init_ram_shared_nomigrate(MemoryRegion *mr,
-                                             Object *owner,
-                                             const char *name,
-                                             uint64_t size,
-                                             bool share,
-                                             Error **errp);
+void memory_region_init_ram_flags_nomigrate(MemoryRegion *mr,
+                                            Object *owner,
+                                            const char *name,
+                                            uint64_t size,
+                                            uint32_t ram_flags,
+                                            Error **errp);
 
 /**
  * memory_region_init_resizeable_ram:  Initialize memory region with resizeable
@@ -1005,10 +1012,8 @@ void memory_region_init_resizeable_ram(MemoryRegion *mr,
  * @size: size of the region.
  * @align: alignment of the region base address; if 0, the default alignment
  *         (getpagesize()) will be used.
- * @ram_flags: Memory region features:
- *             - RAM_SHARED: memory must be mmaped with the MAP_SHARED flag
- *             - RAM_PMEM: the memory is persistent memory
- *             Other bits are ignored now.
+ * @ram_flags: RamBlock flags. Supported flags: RAM_SHARED, RAM_PMEM,
+ *             RAM_NORESERVE,
  * @path: the path in which to allocate the RAM.
  * @readonly: true to open @path for reading, false for read/write.
  * @errp: pointer to Error*, to store an error if it happens.
@@ -1034,7 +1039,8 @@ void memory_region_init_ram_from_file(MemoryRegion *mr,
  * @owner: the object that tracks the region's reference count
  * @name: the name of the region.
  * @size: size of the region.
- * @share: %true if memory must be mmaped with the MAP_SHARED flag
+ * @ram_flags: RamBlock flags. Supported flags: RAM_SHARED, RAM_PMEM,
+ *             RAM_NORESERVE.
  * @fd: the fd to mmap.
  * @offset: offset within the file referenced by fd
  * @errp: pointer to Error*, to store an error if it happens.
@@ -1046,7 +1052,7 @@ void memory_region_init_ram_from_fd(MemoryRegion *mr,
                                     Object *owner,
                                     const char *name,
                                     uint64_t size,
-                                    bool share,
+                                    uint32_t ram_flags,
                                     int fd,
                                     ram_addr_t offset,
                                     Error **errp);
diff --git a/include/exec/ram_addr.h b/include/exec/ram_addr.h
index 3cb9791df3..551876bed0 100644
--- a/include/exec/ram_addr.h
+++ b/include/exec/ram_addr.h
@@ -104,11 +104,8 @@ long qemu_maxrampagesize(void);
  * Parameters:
  *  @size: the size in bytes of the ram block
  *  @mr: the memory region where the ram block is
- *  @ram_flags: specify the properties of the ram block, which can be one
- *              or bit-or of following values
- *              - RAM_SHARED: mmap the backing file or device with MAP_SHARED
- *              - RAM_PMEM: the backend @mem_path or @fd is persistent memory
- *              Other bits are ignored.
+ *  @ram_flags: RamBlock flags. Supported flags: RAM_SHARED, RAM_PMEM,
+ *              RAM_NORESERVE.
  *  @mem_path or @fd: specify the backing file or device
  *  @readonly: true to open @path for reading, false for read/write.
  *  @errp: pointer to Error*, to store an error if it happens
@@ -126,7 +123,7 @@ RAMBlock *qemu_ram_alloc_from_fd(ram_addr_t size, MemoryRegion *mr,
 
 RAMBlock *qemu_ram_alloc_from_ptr(ram_addr_t size, void *host,
                                   MemoryRegion *mr, Error **errp);
-RAMBlock *qemu_ram_alloc(ram_addr_t size, bool share, MemoryRegion *mr,
+RAMBlock *qemu_ram_alloc(ram_addr_t size, uint32_t ram_flags, MemoryRegion *mr,
                          Error **errp);
 RAMBlock *qemu_ram_alloc_resizeable(ram_addr_t size, ram_addr_t max_size,
                                     void (*resized)(const char*,
diff --git a/include/hw/scsi/esp.h b/include/hw/scsi/esp.h
index aada3680b7..b1ec27612f 100644
--- a/include/hw/scsi/esp.h
+++ b/include/hw/scsi/esp.h
@@ -37,6 +37,7 @@ struct ESPState {
     SCSIRequest *current_req;
     Fifo8 cmdfifo;
     uint8_t cmdfifo_cdb_offset;
+    uint8_t lun;
     uint32_t do_cmd;
 
     bool data_in_ready;
diff --git a/include/qemu/mmap-alloc.h b/include/qemu/mmap-alloc.h
index 456ff87df1..90d0eee705 100644
--- a/include/qemu/mmap-alloc.h
+++ b/include/qemu/mmap-alloc.h
@@ -7,18 +7,22 @@ size_t qemu_fd_getpagesize(int fd);
 size_t qemu_mempath_getpagesize(const char *mem_path);
 
 /**
- * qemu_ram_mmap: mmap the specified file or device.
+ * qemu_ram_mmap: mmap anonymous memory, the specified file or device.
+ *
+ * mmap() abstraction to map guest RAM, simplifying flag handling, taking
+ * care of alignment requirements and installing guard pages.
  *
  * Parameters:
  *  @fd: the file or the device to mmap
  *  @size: the number of bytes to be mmaped
  *  @align: if not zero, specify the alignment of the starting mapping address;
  *          otherwise, the alignment in use will be determined by QEMU.
- *  @readonly: true for a read-only mapping, false for read/write.
- *  @shared: map has RAM_SHARED flag.
- *  @is_pmem: map has RAM_PMEM flag.
+ *  @qemu_map_flags: QEMU_MAP_* flags
  *  @map_offset: map starts at offset of map_offset from the start of fd
  *
+ * Internally, MAP_PRIVATE, MAP_ANONYMOUS and MAP_SHARED_VALIDATE are set
+ * implicitly based on other parameters.
+ *
  * Return:
  *  On success, return a pointer to the mapped area.
  *  On failure, return MAP_FAILED.
@@ -26,9 +30,7 @@ size_t qemu_mempath_getpagesize(const char *mem_path);
 void *qemu_ram_mmap(int fd,
                     size_t size,
                     size_t align,
-                    bool readonly,
-                    bool shared,
-                    bool is_pmem,
+                    uint32_t qemu_map_flags,
                     off_t map_offset);
 
 void qemu_ram_munmap(int fd, void *ptr, size_t size);
diff --git a/include/qemu/osdep.h b/include/qemu/osdep.h
index 236a045671..0a54bf7be8 100644
--- a/include/qemu/osdep.h
+++ b/include/qemu/osdep.h
@@ -195,6 +195,9 @@ extern "C" {
 #ifndef MAP_FIXED_NOREPLACE
 #define MAP_FIXED_NOREPLACE 0
 #endif
+#ifndef MAP_NORESERVE
+#define MAP_NORESERVE 0
+#endif
 #ifndef ENOMEDIUM
 #define ENOMEDIUM ENODEV
 #endif
@@ -362,10 +365,35 @@ extern "C" {
 int qemu_daemon(int nochdir, int noclose);
 void *qemu_try_memalign(size_t alignment, size_t size);
 void *qemu_memalign(size_t alignment, size_t size);
-void *qemu_anon_ram_alloc(size_t size, uint64_t *align, bool shared);
+void *qemu_anon_ram_alloc(size_t size, uint64_t *align, bool shared,
+                          bool noreserve);
 void qemu_vfree(void *ptr);
 void qemu_anon_ram_free(void *ptr, size_t size);
 
+/*
+ * Abstraction of PROT_ and MAP_ flags as passed to mmap(), for example,
+ * consumed by qemu_ram_mmap().
+ */
+
+/* Map PROT_READ instead of PROT_READ | PROT_WRITE. */
+#define QEMU_MAP_READONLY   (1 << 0)
+
+/* Use MAP_SHARED instead of MAP_PRIVATE. */
+#define QEMU_MAP_SHARED     (1 << 1)
+
+/*
+ * Use MAP_SYNC | MAP_SHARED_VALIDATE if supported. Ignored without
+ * QEMU_MAP_SHARED. If mapping fails, warn and fallback to !QEMU_MAP_SYNC.
+ */
+#define QEMU_MAP_SYNC       (1 << 2)
+
+/*
+ * Use MAP_NORESERVE to skip reservation of swap space (or huge pages if
+ * applicable). Bail out if not supported/effective.
+ */
+#define QEMU_MAP_NORESERVE  (1 << 3)
+
+
 #define QEMU_MADV_INVALID -1
 
 #if defined(CONFIG_MADVISE)
@@ -410,7 +438,7 @@ void qemu_anon_ram_free(void *ptr, size_t size);
 #ifdef MADV_REMOVE
 #define QEMU_MADV_REMOVE MADV_REMOVE
 #else
-#define QEMU_MADV_REMOVE QEMU_MADV_INVALID
+#define QEMU_MADV_REMOVE QEMU_MADV_DONTNEED
 #endif
 
 #elif defined(CONFIG_POSIX_MADVISE)
@@ -424,7 +452,7 @@ void qemu_anon_ram_free(void *ptr, size_t size);
 #define QEMU_MADV_DONTDUMP QEMU_MADV_INVALID
 #define QEMU_MADV_HUGEPAGE  QEMU_MADV_INVALID
 #define QEMU_MADV_NOHUGEPAGE  QEMU_MADV_INVALID
-#define QEMU_MADV_REMOVE QEMU_MADV_INVALID
+#define QEMU_MADV_REMOVE QEMU_MADV_DONTNEED
 
 #else /* no-op */
 
diff --git a/include/standard-headers/drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.h b/include/standard-headers/drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.h
index 94d41b202c..1677208a41 100644
--- a/include/standard-headers/drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.h
+++ b/include/standard-headers/drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.h
@@ -70,6 +70,30 @@ enum pvrdma_mtu {
 	PVRDMA_MTU_4096 = 5,
 };
 
+static inline int pvrdma_mtu_enum_to_int(enum pvrdma_mtu mtu)
+{
+	switch (mtu) {
+	case PVRDMA_MTU_256:	return  256;
+	case PVRDMA_MTU_512:	return  512;
+	case PVRDMA_MTU_1024:	return 1024;
+	case PVRDMA_MTU_2048:	return 2048;
+	case PVRDMA_MTU_4096:	return 4096;
+	default:		return   -1;
+	}
+}
+
+static inline enum pvrdma_mtu pvrdma_mtu_int_to_enum(int mtu)
+{
+	switch (mtu) {
+	case 256:	return PVRDMA_MTU_256;
+	case 512:	return PVRDMA_MTU_512;
+	case 1024:	return PVRDMA_MTU_1024;
+	case 2048:	return PVRDMA_MTU_2048;
+	case 4096:
+	default:	return PVRDMA_MTU_4096;
+	}
+}
+
 enum pvrdma_port_state {
 	PVRDMA_PORT_NOP			= 0,
 	PVRDMA_PORT_DOWN		= 1,
@@ -114,6 +138,17 @@ enum pvrdma_port_width {
 	PVRDMA_WIDTH_12X	= 8,
 };
 
+static inline int pvrdma_width_enum_to_int(enum pvrdma_port_width width)
+{
+	switch (width) {
+	case PVRDMA_WIDTH_1X:	return  1;
+	case PVRDMA_WIDTH_4X:	return  4;
+	case PVRDMA_WIDTH_8X:	return  8;
+	case PVRDMA_WIDTH_12X:	return 12;
+	default:		return -1;
+	}
+}
+
 enum pvrdma_port_speed {
 	PVRDMA_SPEED_SDR	= 1,
 	PVRDMA_SPEED_DDR	= 2,
diff --git a/include/standard-headers/drm/drm_fourcc.h b/include/standard-headers/drm/drm_fourcc.h
index a61ae520c2..c47e19810c 100644
--- a/include/standard-headers/drm/drm_fourcc.h
+++ b/include/standard-headers/drm/drm_fourcc.h
@@ -526,25 +526,6 @@ extern "C" {
  */
 #define I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS fourcc_mod_code(INTEL, 7)
 
-/*
- * Intel Color Control Surface with Clear Color (CCS) for Gen-12 render
- * compression.
- *
- * The main surface is Y-tiled and is at plane index 0 whereas CCS is linear
- * and at index 1. The clear color is stored at index 2, and the pitch should
- * be ignored. The clear color structure is 256 bits. The first 128 bits
- * represents Raw Clear Color Red, Green, Blue and Alpha color each represented
- * by 32 bits. The raw clear color is consumed by the 3d engine and generates
- * the converted clear color of size 64 bits. The first 32 bits store the Lower
- * Converted Clear Color value and the next 32 bits store the Higher Converted
- * Clear Color value when applicable. The Converted Clear Color values are
- * consumed by the DE. The last 64 bits are used to store Color Discard Enable
- * and Depth Clear Value Valid which are ignored by the DE. A CCS cache line
- * corresponds to an area of 4x1 tiles in the main surface. The main surface
- * pitch is required to be a multiple of 4 tile widths.
- */
-#define I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS_CC fourcc_mod_code(INTEL, 8)
-
 /*
  * Tiled, NV12MT, grouped in 64 (pixels) x 32 (lines) -sized macroblocks
  *
@@ -1054,9 +1035,9 @@ drm_fourcc_canonicalize_nvidia_format_mod(uint64_t modifier)
  * Not all combinations are valid, and different SoCs may support different
  * combinations of layout and options.
  */
-#define __fourcc_mod_amlogic_layout_mask 0xff
+#define __fourcc_mod_amlogic_layout_mask 0xf
 #define __fourcc_mod_amlogic_options_shift 8
-#define __fourcc_mod_amlogic_options_mask 0xff
+#define __fourcc_mod_amlogic_options_mask 0xf
 
 #define DRM_FORMAT_MOD_AMLOGIC_FBC(__layout, __options) \
 	fourcc_mod_code(AMLOGIC, \
diff --git a/include/standard-headers/linux/ethtool.h b/include/standard-headers/linux/ethtool.h
index 218d944a17..8bfd01d230 100644
--- a/include/standard-headers/linux/ethtool.h
+++ b/include/standard-headers/linux/ethtool.h
@@ -26,14 +26,6 @@
  * have the same layout for 32-bit and 64-bit userland.
  */
 
-/* Note on reserved space.
- * Reserved fields must not be accessed directly by user space because
- * they may be replaced by a different field in the future. They must
- * be initialized to zero before making the request, e.g. via memset
- * of the entire structure or implicitly by not being set in a structure
- * initializer.
- */
-
 /**
  * struct ethtool_cmd - DEPRECATED, link control and status
  * This structure is DEPRECATED, please use struct ethtool_link_settings.
@@ -75,7 +67,6 @@
  *	and other link features that the link partner advertised
  *	through autonegotiation; 0 if unknown or not applicable.
  *	Read-only.
- * @reserved: Reserved for future use; see the note on reserved space.
  *
  * The link speed in Mbps is split between @speed and @speed_hi.  Use
  * the ethtool_cmd_speed() and ethtool_cmd_speed_set() functions to
@@ -164,7 +155,6 @@ static inline uint32_t ethtool_cmd_speed(const struct ethtool_cmd *ep)
  * @bus_info: Device bus address.  This should match the dev_name()
  *	string for the underlying bus device, if there is one.  May be
  *	an empty string.
- * @reserved2: Reserved for future use; see the note on reserved space.
  * @n_priv_flags: Number of flags valid for %ETHTOOL_GPFLAGS and
  *	%ETHTOOL_SPFLAGS commands; also the number of strings in the
  *	%ETH_SS_PRIV_FLAGS set
@@ -366,7 +356,6 @@ struct ethtool_eeprom {
  * @tx_lpi_timer: Time in microseconds the interface delays prior to asserting
  *	its tx lpi (after reaching 'idle' state). Effective only when eee
  *	was negotiated and tx_lpi_enabled was set.
- * @reserved: Reserved for future use; see the note on reserved space.
  */
 struct ethtool_eee {
 	uint32_t	cmd;
@@ -385,7 +374,6 @@ struct ethtool_eee {
  * @cmd: %ETHTOOL_GMODULEINFO
  * @type: Standard the module information conforms to %ETH_MODULE_SFF_xxxx
  * @eeprom_len: Length of the eeprom
- * @reserved: Reserved for future use; see the note on reserved space.
  *
  * This structure is used to return the information to
  * properly size memory for a subsequent call to %ETHTOOL_GMODULEEEPROM.
@@ -591,7 +579,9 @@ struct ethtool_pauseparam {
 	uint32_t	tx_pause;
 };
 
-/* Link extended state */
+/**
+ * enum ethtool_link_ext_state - link extended state
+ */
 enum ethtool_link_ext_state {
 	ETHTOOL_LINK_EXT_STATE_AUTONEG,
 	ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE,
@@ -605,7 +595,10 @@ enum ethtool_link_ext_state {
 	ETHTOOL_LINK_EXT_STATE_OVERHEAT,
 };
 
-/* More information in addition to ETHTOOL_LINK_EXT_STATE_AUTONEG. */
+/**
+ * enum ethtool_link_ext_substate_autoneg - more information in addition to
+ * ETHTOOL_LINK_EXT_STATE_AUTONEG.
+ */
 enum ethtool_link_ext_substate_autoneg {
 	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED = 1,
 	ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED,
@@ -615,7 +608,9 @@ enum ethtool_link_ext_substate_autoneg {
 	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD,
 };
 
-/* More information in addition to ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE.
+/**
+ * enum ethtool_link_ext_substate_link_training - more information in addition to
+ * ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE.
  */
 enum ethtool_link_ext_substate_link_training {
 	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED = 1,
@@ -624,7 +619,9 @@ enum ethtool_link_ext_substate_link_training {
 	ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT,
 };
 
-/* More information in addition to ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH.
+/**
+ * enum ethtool_link_ext_substate_logical_mismatch - more information in addition
+ * to ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH.
  */
 enum ethtool_link_ext_substate_link_logical_mismatch {
 	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK = 1,
@@ -634,14 +631,19 @@ enum ethtool_link_ext_substate_link_logical_mismatch {
 	ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED,
 };
 
-/* More information in addition to ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY.
+/**
+ * enum ethtool_link_ext_substate_bad_signal_integrity - more information in
+ * addition to ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY.
  */
 enum ethtool_link_ext_substate_bad_signal_integrity {
 	ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS = 1,
 	ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE,
 };
 
-/* More information in addition to ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE. */
+/**
+ * enum ethtool_link_ext_substate_cable_issue - more information in
+ * addition to ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE.
+ */
 enum ethtool_link_ext_substate_cable_issue {
 	ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE = 1,
 	ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE,
@@ -659,7 +661,6 @@ enum ethtool_link_ext_substate_cable_issue {
  *	now deprecated
  * @ETH_SS_FEATURES: Device feature names
  * @ETH_SS_RSS_HASH_FUNCS: RSS hush function names
- * @ETH_SS_TUNABLES: tunable names
  * @ETH_SS_PHY_STATS: Statistic names, for use with %ETHTOOL_GPHYSTATS
  * @ETH_SS_PHY_TUNABLES: PHY tunable names
  * @ETH_SS_LINK_MODES: link mode names
@@ -669,13 +670,6 @@ enum ethtool_link_ext_substate_cable_issue {
  * @ETH_SS_TS_TX_TYPES: timestamping Tx types
  * @ETH_SS_TS_RX_FILTERS: timestamping Rx filters
  * @ETH_SS_UDP_TUNNEL_TYPES: UDP tunnel types
- * @ETH_SS_STATS_STD: standardized stats
- * @ETH_SS_STATS_ETH_PHY: names of IEEE 802.3 PHY statistics
- * @ETH_SS_STATS_ETH_MAC: names of IEEE 802.3 MAC statistics
- * @ETH_SS_STATS_ETH_CTRL: names of IEEE 802.3 MAC Control statistics
- * @ETH_SS_STATS_RMON: names of RMON statistics
- *
- * @ETH_SS_COUNT: number of defined string sets
  */
 enum ethtool_stringset {
 	ETH_SS_TEST		= 0,
@@ -694,11 +688,6 @@ enum ethtool_stringset {
 	ETH_SS_TS_TX_TYPES,
 	ETH_SS_TS_RX_FILTERS,
 	ETH_SS_UDP_TUNNEL_TYPES,
-	ETH_SS_STATS_STD,
-	ETH_SS_STATS_ETH_PHY,
-	ETH_SS_STATS_ETH_MAC,
-	ETH_SS_STATS_ETH_CTRL,
-	ETH_SS_STATS_RMON,
 
 	/* add new constants above here */
 	ETH_SS_COUNT
@@ -726,7 +715,6 @@ struct ethtool_gstrings {
 /**
  * struct ethtool_sset_info - string set information
  * @cmd: Command number = %ETHTOOL_GSSET_INFO
- * @reserved: Reserved for future use; see the note on reserved space.
  * @sset_mask: On entry, a bitmask of string sets to query, with bits
  *	numbered according to &enum ethtool_stringset.  On return, a
  *	bitmask of those string sets queried that are supported.
@@ -771,7 +759,6 @@ enum ethtool_test_flags {
  * @flags: A bitmask of flags from &enum ethtool_test_flags.  Some
  *	flags may be set by the user on entry; others may be set by
  *	the driver on return.
- * @reserved: Reserved for future use; see the note on reserved space.
  * @len: On return, the number of test results
  * @data: Array of test results
  *
@@ -972,7 +959,6 @@ union ethtool_flow_union {
  * @vlan_etype: VLAN EtherType
  * @vlan_tci: VLAN tag control information
  * @data: user defined data
- * @padding: Reserved for future use; see the note on reserved space.
  *
  * Note, @vlan_etype, @vlan_tci, and @data are only valid if %FLOW_EXT
  * is set in &struct ethtool_rx_flow_spec @flow_type.
@@ -1148,8 +1134,7 @@ struct ethtool_rxfh_indir {
  *	hardware hash key.
  * @hfunc: Defines the current RSS hash function used by HW (or to be set to).
  *	Valid values are one of the %ETH_RSS_HASH_*.
- * @rsvd8: Reserved for future use; see the note on reserved space.
- * @rsvd32: Reserved for future use; see the note on reserved space.
+ * @rsvd:	Reserved for future extensions.
  * @rss_config: RX ring/queue index for each hash value i.e., indirection table
  *	of @indir_size uint32_t elements, followed by hash key of @key_size
  *	bytes.
@@ -1317,9 +1302,7 @@ struct ethtool_sfeatures {
  * @so_timestamping: bit mask of the sum of the supported SO_TIMESTAMPING flags
  * @phc_index: device index of the associated PHC, or -1 if there is none
  * @tx_types: bit mask of the supported hwtstamp_tx_types enumeration values
- * @tx_reserved: Reserved for future use; see the note on reserved space.
  * @rx_filters: bit mask of the supported hwtstamp_rx_filters enumeration values
- * @rx_reserved: Reserved for future use; see the note on reserved space.
  *
  * The bits in the 'tx_types' and 'rx_filters' fields correspond to
  * the 'hwtstamp_tx_types' and 'hwtstamp_rx_filters' enumeration values,
@@ -1393,33 +1376,15 @@ struct ethtool_per_queue_op {
 };
 
 /**
- * struct ethtool_fecparam - Ethernet Forward Error Correction parameters
+ * struct ethtool_fecparam - Ethernet forward error correction(fec) parameters
  * @cmd: Command number = %ETHTOOL_GFECPARAM or %ETHTOOL_SFECPARAM
- * @active_fec: FEC mode which is active on the port, single bit set, GET only.
- * @fec: Bitmask of configured FEC modes.
- * @reserved: Reserved for future extensions, ignore on GET, write 0 for SET.
- *
- * Note that @reserved was never validated on input and ethtool user space
- * left it uninitialized when calling SET. Hence going forward it can only be
- * used to return a value to userspace with GET.
+ * @active_fec: FEC mode which is active on porte
+ * @fec: Bitmask of supported/configured FEC modes
+ * @rsvd: Reserved for future extensions. i.e FEC bypass feature.
  *
- * FEC modes supported by the device can be read via %ETHTOOL_GLINKSETTINGS.
- * FEC settings are configured by link autonegotiation whenever it's enabled.
- * With autoneg on %ETHTOOL_GFECPARAM can be used to read the current mode.
- *
- * When autoneg is disabled %ETHTOOL_SFECPARAM controls the FEC settings.
- * It is recommended that drivers only accept a single bit set in @fec.
- * When multiple bits are set in @fec drivers may pick mode in an implementation
- * dependent way. Drivers should reject mixing %ETHTOOL_FEC_AUTO_BIT with other
- * FEC modes, because it's unclear whether in this case other modes constrain
- * AUTO or are independent choices.
- * Drivers must reject SET requests if they support none of the requested modes.
- *
- * If device does not support FEC drivers may use %ETHTOOL_FEC_NONE instead
- * of returning %EOPNOTSUPP from %ETHTOOL_GFECPARAM.
+ * Drivers should reject a non-zero setting of @autoneg when
+ * autoneogotiation is disabled (or not supported) for the link.
  *
- * See enum ethtool_fec_config_bits for definition of valid bits for both
- * @fec and @active_fec.
  */
 struct ethtool_fecparam {
 	uint32_t   cmd;
@@ -1431,16 +1396,11 @@ struct ethtool_fecparam {
 
 /**
  * enum ethtool_fec_config_bits - flags definition of ethtool_fec_configuration
- * @ETHTOOL_FEC_NONE_BIT: FEC mode configuration is not supported. Should not
- *			be used together with other bits. GET only.
- * @ETHTOOL_FEC_AUTO_BIT: Select default/best FEC mode automatically, usually
- *			based link mode and SFP parameters read from module's
- *			EEPROM. This bit does _not_ mean autonegotiation.
- * @ETHTOOL_FEC_OFF_BIT: No FEC Mode
- * @ETHTOOL_FEC_RS_BIT: Reed-Solomon FEC Mode
- * @ETHTOOL_FEC_BASER_BIT: Base-R/Reed-Solomon FEC Mode
- * @ETHTOOL_FEC_LLRS_BIT: Low Latency Reed Solomon FEC Mode (25G/50G Ethernet
- *			Consortium)
+ * @ETHTOOL_FEC_NONE: FEC mode configuration is not supported
+ * @ETHTOOL_FEC_AUTO: Default/Best FEC mode provided by driver
+ * @ETHTOOL_FEC_OFF: No FEC Mode
+ * @ETHTOOL_FEC_RS: Reed-Solomon Forward Error Detection mode
+ * @ETHTOOL_FEC_BASER: Base-R/Reed-Solomon Forward Error Detection mode
  */
 enum ethtool_fec_config_bits {
 	ETHTOOL_FEC_NONE_BIT,
@@ -1998,11 +1958,6 @@ enum ethtool_reset_flags {
  *	autonegotiation; 0 if unknown or not applicable.  Read-only.
  * @transceiver: Used to distinguish different possible PHY types,
  *	reported consistently by PHYLIB.  Read-only.
- * @master_slave_cfg: Master/slave port mode.
- * @master_slave_state: Master/slave port state.
- * @reserved: Reserved for future use; see the note on reserved space.
- * @reserved1: Reserved for future use; see the note on reserved space.
- * @link_mode_masks: Variable length bitmaps.
  *
  * If autonegotiation is disabled, the speed and @duplex represent the
  * fixed link mode and are writable if the driver supports multiple
diff --git a/include/standard-headers/linux/fuse.h b/include/standard-headers/linux/fuse.h
index cce105bfba..950d7edb7e 100644
--- a/include/standard-headers/linux/fuse.h
+++ b/include/standard-headers/linux/fuse.h
@@ -179,8 +179,6 @@
  *  7.33
  *  - add FUSE_HANDLE_KILLPRIV_V2, FUSE_WRITE_KILL_SUIDGID, FATTR_KILL_SUIDGID
  *  - add FUSE_OPEN_KILL_SUIDGID
- *  - extend fuse_setxattr_in, add FUSE_SETXATTR_EXT
- *  - add FUSE_SETXATTR_ACL_KILL_SGID
  */
 
 #ifndef _LINUX_FUSE_H
@@ -328,7 +326,6 @@ struct fuse_file_lock {
  *			does not have CAP_FSETID. Additionally upon
  *			write/truncate sgid is killed only if file has group
  *			execute permission. (Same as Linux VFS behavior).
- * FUSE_SETXATTR_EXT:	Server supports extended struct fuse_setxattr_in
  */
 #define FUSE_ASYNC_READ		(1 << 0)
 #define FUSE_POSIX_LOCKS	(1 << 1)
@@ -359,7 +356,6 @@ struct fuse_file_lock {
 #define FUSE_MAP_ALIGNMENT	(1 << 26)
 #define FUSE_SUBMOUNTS		(1 << 27)
 #define FUSE_HANDLE_KILLPRIV_V2	(1 << 28)
-#define FUSE_SETXATTR_EXT	(1 << 29)
 
 /**
  * CUSE INIT request/reply flags
@@ -451,12 +447,6 @@ struct fuse_file_lock {
  */
 #define FUSE_OPEN_KILL_SUIDGID	(1 << 0)
 
-/**
- * setxattr flags
- * FUSE_SETXATTR_ACL_KILL_SGID: Clear SGID when system.posix_acl_access is set
- */
-#define FUSE_SETXATTR_ACL_KILL_SGID	(1 << 0)
-
 enum fuse_opcode {
 	FUSE_LOOKUP		= 1,
 	FUSE_FORGET		= 2,  /* no reply */
@@ -687,13 +677,9 @@ struct fuse_fsync_in {
 	uint32_t	padding;
 };
 
-#define FUSE_COMPAT_SETXATTR_IN_SIZE 8
-
 struct fuse_setxattr_in {
 	uint32_t	size;
 	uint32_t	flags;
-	uint32_t	setxattr_flags;
-	uint32_t	padding;
 };
 
 struct fuse_getxattr_in {
@@ -913,8 +899,7 @@ struct fuse_notify_retrieve_in {
 };
 
 /* Device ioctls: */
-#define FUSE_DEV_IOC_MAGIC		229
-#define FUSE_DEV_IOC_CLONE		_IOR(FUSE_DEV_IOC_MAGIC, 0, uint32_t)
+#define FUSE_DEV_IOC_CLONE	_IOR(229, 0, uint32_t)
 
 struct fuse_lseek_in {
 	uint64_t	fh;
diff --git a/include/standard-headers/linux/input.h b/include/standard-headers/linux/input.h
index 7822c24178..f89c986190 100644
--- a/include/standard-headers/linux/input.h
+++ b/include/standard-headers/linux/input.h
@@ -81,7 +81,7 @@ struct input_id {
  * in units per radian.
  * When INPUT_PROP_ACCELEROMETER is set the resolution changes.
  * The main axes (ABS_X, ABS_Y, ABS_Z) are then reported in
- * units per g (units/g) and in units per degree per second
+ * in units per g (units/g) and in units per degree per second
  * (units/deg/s) for rotational axes (ABS_RX, ABS_RY, ABS_RZ).
  */
 struct input_absinfo {
diff --git a/include/standard-headers/linux/virtio_bt.h b/include/standard-headers/linux/virtio_bt.h
deleted file mode 100644
index 245e1eff4b..0000000000
--- a/include/standard-headers/linux/virtio_bt.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/* SPDX-License-Identifier: BSD-3-Clause */
-
-#ifndef _LINUX_VIRTIO_BT_H
-#define _LINUX_VIRTIO_BT_H
-
-#include "standard-headers/linux/virtio_types.h"
-
-/* Feature bits */
-#define VIRTIO_BT_F_VND_HCI	0	/* Indicates vendor command support */
-#define VIRTIO_BT_F_MSFT_EXT	1	/* Indicates MSFT vendor support */
-#define VIRTIO_BT_F_AOSP_EXT	2	/* Indicates AOSP vendor support */
-
-enum virtio_bt_config_type {
-	VIRTIO_BT_CONFIG_TYPE_PRIMARY	= 0,
-	VIRTIO_BT_CONFIG_TYPE_AMP	= 1,
-};
-
-enum virtio_bt_config_vendor {
-	VIRTIO_BT_CONFIG_VENDOR_NONE	= 0,
-	VIRTIO_BT_CONFIG_VENDOR_ZEPHYR	= 1,
-	VIRTIO_BT_CONFIG_VENDOR_INTEL	= 2,
-	VIRTIO_BT_CONFIG_VENDOR_REALTEK	= 3,
-};
-
-struct virtio_bt_config {
-	uint8_t  type;
-	uint16_t vendor;
-	uint16_t msft_opcode;
-} QEMU_PACKED;
-
-#endif /* _LINUX_VIRTIO_BT_H */
diff --git a/include/standard-headers/linux/virtio_ids.h b/include/standard-headers/linux/virtio_ids.h
index f0c35ce862..bc1c0621f5 100644
--- a/include/standard-headers/linux/virtio_ids.h
+++ b/include/standard-headers/linux/virtio_ids.h
@@ -51,10 +51,8 @@
 #define VIRTIO_ID_PSTORE		22 /* virtio pstore device */
 #define VIRTIO_ID_IOMMU			23 /* virtio IOMMU */
 #define VIRTIO_ID_MEM			24 /* virtio mem */
-#define VIRTIO_ID_SOUND			25 /* virtio sound */
 #define VIRTIO_ID_FS			26 /* virtio filesystem */
 #define VIRTIO_ID_PMEM			27 /* virtio pmem */
-#define VIRTIO_ID_BT			28 /* virtio bluetooth */
 #define VIRTIO_ID_MAC80211_HWSIM	29 /* virtio mac80211-hwsim */
 
 #endif /* _LINUX_VIRTIO_IDS_H */
diff --git a/include/standard-headers/linux/virtio_snd.h b/include/standard-headers/linux/virtio_snd.h
deleted file mode 100644
index 1af96b9fc6..0000000000
--- a/include/standard-headers/linux/virtio_snd.h
+++ /dev/null
@@ -1,334 +0,0 @@
-/* SPDX-License-Identifier: BSD-3-Clause */
-/*
- * Copyright (C) 2021 OpenSynergy GmbH
- */
-#ifndef VIRTIO_SND_IF_H
-#define VIRTIO_SND_IF_H
-
-#include "standard-headers/linux/virtio_types.h"
-
-/*******************************************************************************
- * CONFIGURATION SPACE
- */
-struct virtio_snd_config {
-	/* # of available physical jacks */
-	uint32_t jacks;
-	/* # of available PCM streams */
-	uint32_t streams;
-	/* # of available channel maps */
-	uint32_t chmaps;
-};
-
-enum {
-	/* device virtqueue indexes */
-	VIRTIO_SND_VQ_CONTROL = 0,
-	VIRTIO_SND_VQ_EVENT,
-	VIRTIO_SND_VQ_TX,
-	VIRTIO_SND_VQ_RX,
-	/* # of device virtqueues */
-	VIRTIO_SND_VQ_MAX
-};
-
-/*******************************************************************************
- * COMMON DEFINITIONS
- */
-
-/* supported dataflow directions */
-enum {
-	VIRTIO_SND_D_OUTPUT = 0,
-	VIRTIO_SND_D_INPUT
-};
-
-enum {
-	/* jack control request types */
-	VIRTIO_SND_R_JACK_INFO = 1,
-	VIRTIO_SND_R_JACK_REMAP,
-
-	/* PCM control request types */
-	VIRTIO_SND_R_PCM_INFO = 0x0100,
-	VIRTIO_SND_R_PCM_SET_PARAMS,
-	VIRTIO_SND_R_PCM_PREPARE,
-	VIRTIO_SND_R_PCM_RELEASE,
-	VIRTIO_SND_R_PCM_START,
-	VIRTIO_SND_R_PCM_STOP,
-
-	/* channel map control request types */
-	VIRTIO_SND_R_CHMAP_INFO = 0x0200,
-
-	/* jack event types */
-	VIRTIO_SND_EVT_JACK_CONNECTED = 0x1000,
-	VIRTIO_SND_EVT_JACK_DISCONNECTED,
-
-	/* PCM event types */
-	VIRTIO_SND_EVT_PCM_PERIOD_ELAPSED = 0x1100,
-	VIRTIO_SND_EVT_PCM_XRUN,
-
-	/* common status codes */
-	VIRTIO_SND_S_OK = 0x8000,
-	VIRTIO_SND_S_BAD_MSG,
-	VIRTIO_SND_S_NOT_SUPP,
-	VIRTIO_SND_S_IO_ERR
-};
-
-/* common header */
-struct virtio_snd_hdr {
-	uint32_t code;
-};
-
-/* event notification */
-struct virtio_snd_event {
-	/* VIRTIO_SND_EVT_XXX */
-	struct virtio_snd_hdr hdr;
-	/* optional event data */
-	uint32_t data;
-};
-
-/* common control request to query an item information */
-struct virtio_snd_query_info {
-	/* VIRTIO_SND_R_XXX_INFO */
-	struct virtio_snd_hdr hdr;
-	/* item start identifier */
-	uint32_t start_id;
-	/* item count to query */
-	uint32_t count;
-	/* item information size in bytes */
-	uint32_t size;
-};
-
-/* common item information header */
-struct virtio_snd_info {
-	/* function group node id (High Definition Audio Specification 7.1.2) */
-	uint32_t hda_fn_nid;
-};
-
-/*******************************************************************************
- * JACK CONTROL MESSAGES
- */
-struct virtio_snd_jack_hdr {
-	/* VIRTIO_SND_R_JACK_XXX */
-	struct virtio_snd_hdr hdr;
-	/* 0 ... virtio_snd_config::jacks - 1 */
-	uint32_t jack_id;
-};
-
-/* supported jack features */
-enum {
-	VIRTIO_SND_JACK_F_REMAP = 0
-};
-
-struct virtio_snd_jack_info {
-	/* common header */
-	struct virtio_snd_info hdr;
-	/* supported feature bit map (1 << VIRTIO_SND_JACK_F_XXX) */
-	uint32_t features;
-	/* pin configuration (High Definition Audio Specification 7.3.3.31) */
-	uint32_t hda_reg_defconf;
-	/* pin capabilities (High Definition Audio Specification 7.3.4.9) */
-	uint32_t hda_reg_caps;
-	/* current jack connection status (0: disconnected, 1: connected) */
-	uint8_t connected;
-
-	uint8_t padding[7];
-};
-
-/* jack remapping control request */
-struct virtio_snd_jack_remap {
-	/* .code = VIRTIO_SND_R_JACK_REMAP */
-	struct virtio_snd_jack_hdr hdr;
-	/* selected association number */
-	uint32_t association;
-	/* selected sequence number */
-	uint32_t sequence;
-};
-
-/*******************************************************************************
- * PCM CONTROL MESSAGES
- */
-struct virtio_snd_pcm_hdr {
-	/* VIRTIO_SND_R_PCM_XXX */
-	struct virtio_snd_hdr hdr;
-	/* 0 ... virtio_snd_config::streams - 1 */
-	uint32_t stream_id;
-};
-
-/* supported PCM stream features */
-enum {
-	VIRTIO_SND_PCM_F_SHMEM_HOST = 0,
-	VIRTIO_SND_PCM_F_SHMEM_GUEST,
-	VIRTIO_SND_PCM_F_MSG_POLLING,
-	VIRTIO_SND_PCM_F_EVT_SHMEM_PERIODS,
-	VIRTIO_SND_PCM_F_EVT_XRUNS
-};
-
-/* supported PCM sample formats */
-enum {
-	/* analog formats (width / physical width) */
-	VIRTIO_SND_PCM_FMT_IMA_ADPCM = 0,	/*  4 /  4 bits */
-	VIRTIO_SND_PCM_FMT_MU_LAW,		/*  8 /  8 bits */
-	VIRTIO_SND_PCM_FMT_A_LAW,		/*  8 /  8 bits */
-	VIRTIO_SND_PCM_FMT_S8,			/*  8 /  8 bits */
-	VIRTIO_SND_PCM_FMT_U8,			/*  8 /  8 bits */
-	VIRTIO_SND_PCM_FMT_S16,			/* 16 / 16 bits */
-	VIRTIO_SND_PCM_FMT_U16,			/* 16 / 16 bits */
-	VIRTIO_SND_PCM_FMT_S18_3,		/* 18 / 24 bits */
-	VIRTIO_SND_PCM_FMT_U18_3,		/* 18 / 24 bits */
-	VIRTIO_SND_PCM_FMT_S20_3,		/* 20 / 24 bits */
-	VIRTIO_SND_PCM_FMT_U20_3,		/* 20 / 24 bits */
-	VIRTIO_SND_PCM_FMT_S24_3,		/* 24 / 24 bits */
-	VIRTIO_SND_PCM_FMT_U24_3,		/* 24 / 24 bits */
-	VIRTIO_SND_PCM_FMT_S20,			/* 20 / 32 bits */
-	VIRTIO_SND_PCM_FMT_U20,			/* 20 / 32 bits */
-	VIRTIO_SND_PCM_FMT_S24,			/* 24 / 32 bits */
-	VIRTIO_SND_PCM_FMT_U24,			/* 24 / 32 bits */
-	VIRTIO_SND_PCM_FMT_S32,			/* 32 / 32 bits */
-	VIRTIO_SND_PCM_FMT_U32,			/* 32 / 32 bits */
-	VIRTIO_SND_PCM_FMT_FLOAT,		/* 32 / 32 bits */
-	VIRTIO_SND_PCM_FMT_FLOAT64,		/* 64 / 64 bits */
-	/* digital formats (width / physical width) */
-	VIRTIO_SND_PCM_FMT_DSD_U8,		/*  8 /  8 bits */
-	VIRTIO_SND_PCM_FMT_DSD_U16,		/* 16 / 16 bits */
-	VIRTIO_SND_PCM_FMT_DSD_U32,		/* 32 / 32 bits */
-	VIRTIO_SND_PCM_FMT_IEC958_SUBFRAME	/* 32 / 32 bits */
-};
-
-/* supported PCM frame rates */
-enum {
-	VIRTIO_SND_PCM_RATE_5512 = 0,
-	VIRTIO_SND_PCM_RATE_8000,
-	VIRTIO_SND_PCM_RATE_11025,
-	VIRTIO_SND_PCM_RATE_16000,
-	VIRTIO_SND_PCM_RATE_22050,
-	VIRTIO_SND_PCM_RATE_32000,
-	VIRTIO_SND_PCM_RATE_44100,
-	VIRTIO_SND_PCM_RATE_48000,
-	VIRTIO_SND_PCM_RATE_64000,
-	VIRTIO_SND_PCM_RATE_88200,
-	VIRTIO_SND_PCM_RATE_96000,
-	VIRTIO_SND_PCM_RATE_176400,
-	VIRTIO_SND_PCM_RATE_192000,
-	VIRTIO_SND_PCM_RATE_384000
-};
-
-struct virtio_snd_pcm_info {
-	/* common header */
-	struct virtio_snd_info hdr;
-	/* supported feature bit map (1 << VIRTIO_SND_PCM_F_XXX) */
-	uint32_t features;
-	/* supported sample format bit map (1 << VIRTIO_SND_PCM_FMT_XXX) */
-	uint64_t formats;
-	/* supported frame rate bit map (1 << VIRTIO_SND_PCM_RATE_XXX) */
-	uint64_t rates;
-	/* dataflow direction (VIRTIO_SND_D_XXX) */
-	uint8_t direction;
-	/* minimum # of supported channels */
-	uint8_t channels_min;
-	/* maximum # of supported channels */
-	uint8_t channels_max;
-
-	uint8_t padding[5];
-};
-
-/* set PCM stream format */
-struct virtio_snd_pcm_set_params {
-	/* .code = VIRTIO_SND_R_PCM_SET_PARAMS */
-	struct virtio_snd_pcm_hdr hdr;
-	/* size of the hardware buffer */
-	uint32_t buffer_bytes;
-	/* size of the hardware period */
-	uint32_t period_bytes;
-	/* selected feature bit map (1 << VIRTIO_SND_PCM_F_XXX) */
-	uint32_t features;
-	/* selected # of channels */
-	uint8_t channels;
-	/* selected sample format (VIRTIO_SND_PCM_FMT_XXX) */
-	uint8_t format;
-	/* selected frame rate (VIRTIO_SND_PCM_RATE_XXX) */
-	uint8_t rate;
-
-	uint8_t padding;
-};
-
-/*******************************************************************************
- * PCM I/O MESSAGES
- */
-
-/* I/O request header */
-struct virtio_snd_pcm_xfer {
-	/* 0 ... virtio_snd_config::streams - 1 */
-	uint32_t stream_id;
-};
-
-/* I/O request status */
-struct virtio_snd_pcm_status {
-	/* VIRTIO_SND_S_XXX */
-	uint32_t status;
-	/* current device latency */
-	uint32_t latency_bytes;
-};
-
-/*******************************************************************************
- * CHANNEL MAP CONTROL MESSAGES
- */
-struct virtio_snd_chmap_hdr {
-	/* VIRTIO_SND_R_CHMAP_XXX */
-	struct virtio_snd_hdr hdr;
-	/* 0 ... virtio_snd_config::chmaps - 1 */
-	uint32_t chmap_id;
-};
-
-/* standard channel position definition */
-enum {
-	VIRTIO_SND_CHMAP_NONE = 0,	/* undefined */
-	VIRTIO_SND_CHMAP_NA,		/* silent */
-	VIRTIO_SND_CHMAP_MONO,		/* mono stream */
-	VIRTIO_SND_CHMAP_FL,		/* front left */
-	VIRTIO_SND_CHMAP_FR,		/* front right */
-	VIRTIO_SND_CHMAP_RL,		/* rear left */
-	VIRTIO_SND_CHMAP_RR,		/* rear right */
-	VIRTIO_SND_CHMAP_FC,		/* front center */
-	VIRTIO_SND_CHMAP_LFE,		/* low frequency (LFE) */
-	VIRTIO_SND_CHMAP_SL,		/* side left */
-	VIRTIO_SND_CHMAP_SR,		/* side right */
-	VIRTIO_SND_CHMAP_RC,		/* rear center */
-	VIRTIO_SND_CHMAP_FLC,		/* front left center */
-	VIRTIO_SND_CHMAP_FRC,		/* front right center */
-	VIRTIO_SND_CHMAP_RLC,		/* rear left center */
-	VIRTIO_SND_CHMAP_RRC,		/* rear right center */
-	VIRTIO_SND_CHMAP_FLW,		/* front left wide */
-	VIRTIO_SND_CHMAP_FRW,		/* front right wide */
-	VIRTIO_SND_CHMAP_FLH,		/* front left high */
-	VIRTIO_SND_CHMAP_FCH,		/* front center high */
-	VIRTIO_SND_CHMAP_FRH,		/* front right high */
-	VIRTIO_SND_CHMAP_TC,		/* top center */
-	VIRTIO_SND_CHMAP_TFL,		/* top front left */
-	VIRTIO_SND_CHMAP_TFR,		/* top front right */
-	VIRTIO_SND_CHMAP_TFC,		/* top front center */
-	VIRTIO_SND_CHMAP_TRL,		/* top rear left */
-	VIRTIO_SND_CHMAP_TRR,		/* top rear right */
-	VIRTIO_SND_CHMAP_TRC,		/* top rear center */
-	VIRTIO_SND_CHMAP_TFLC,		/* top front left center */
-	VIRTIO_SND_CHMAP_TFRC,		/* top front right center */
-	VIRTIO_SND_CHMAP_TSL,		/* top side left */
-	VIRTIO_SND_CHMAP_TSR,		/* top side right */
-	VIRTIO_SND_CHMAP_LLFE,		/* left LFE */
-	VIRTIO_SND_CHMAP_RLFE,		/* right LFE */
-	VIRTIO_SND_CHMAP_BC,		/* bottom center */
-	VIRTIO_SND_CHMAP_BLC,		/* bottom left center */
-	VIRTIO_SND_CHMAP_BRC		/* bottom right center */
-};
-
-/* maximum possible number of channels */
-#define VIRTIO_SND_CHMAP_MAX_SIZE	18
-
-struct virtio_snd_chmap_info {
-	/* common header */
-	struct virtio_snd_info hdr;
-	/* dataflow direction (VIRTIO_SND_D_XXX) */
-	uint8_t direction;
-	/* # of valid channel position values */
-	uint8_t channels;
-	/* channel position values (VIRTIO_SND_CHMAP_XXX) */
-	uint8_t positions[VIRTIO_SND_CHMAP_MAX_SIZE];
-};
-
-#endif /* VIRTIO_SND_IF_H */
diff --git a/include/standard-headers/rdma/vmw_pvrdma-abi.h b/include/standard-headers/rdma/vmw_pvrdma-abi.h
index c30182a7ae..0989426a3f 100644
--- a/include/standard-headers/rdma/vmw_pvrdma-abi.h
+++ b/include/standard-headers/rdma/vmw_pvrdma-abi.h
@@ -133,13 +133,6 @@ enum pvrdma_wc_flags {
 	PVRDMA_WC_FLAGS_MAX		= PVRDMA_WC_WITH_NETWORK_HDR_TYPE,
 };
 
-enum pvrdma_network_type {
-	PVRDMA_NETWORK_IB,
-	PVRDMA_NETWORK_ROCE_V1 = PVRDMA_NETWORK_IB,
-	PVRDMA_NETWORK_IPV4,
-	PVRDMA_NETWORK_IPV6
-};
-
 struct pvrdma_alloc_ucontext_resp {
 	uint32_t qp_tab_size;
 	uint32_t reserved;
diff --git a/include/sysemu/hostmem.h b/include/sysemu/hostmem.h
index df5644723a..9ff5c16963 100644
--- a/include/sysemu/hostmem.h
+++ b/include/sysemu/hostmem.h
@@ -64,7 +64,7 @@ struct HostMemoryBackend {
     /* protected */
     uint64_t size;
     bool merge, dump, use_canonical_path;
-    bool prealloc, is_mapped, share;
+    bool prealloc, is_mapped, share, reserve;
     uint32_t prealloc_threads;
     DECLARE_BITMAP(host_nodes, MAX_NODES + 1);
     HostMemPolicy policy;
diff --git a/linux-headers/asm-generic/unistd.h b/linux-headers/asm-generic/unistd.h
index 6de5a7fc06..7287529177 100644
--- a/linux-headers/asm-generic/unistd.h
+++ b/linux-headers/asm-generic/unistd.h
@@ -861,20 +861,9 @@ __SYSCALL(__NR_faccessat2, sys_faccessat2)
 __SYSCALL(__NR_process_madvise, sys_process_madvise)
 #define __NR_epoll_pwait2 441
 __SC_COMP(__NR_epoll_pwait2, sys_epoll_pwait2, compat_sys_epoll_pwait2)
-#define __NR_mount_setattr 442
-__SYSCALL(__NR_mount_setattr, sys_mount_setattr)
-#define __NR_quotactl_path 443
-__SYSCALL(__NR_quotactl_path, sys_quotactl_path)
-
-#define __NR_landlock_create_ruleset 444
-__SYSCALL(__NR_landlock_create_ruleset, sys_landlock_create_ruleset)
-#define __NR_landlock_add_rule 445
-__SYSCALL(__NR_landlock_add_rule, sys_landlock_add_rule)
-#define __NR_landlock_restrict_self 446
-__SYSCALL(__NR_landlock_restrict_self, sys_landlock_restrict_self)
 
 #undef __NR_syscalls
-#define __NR_syscalls 447
+#define __NR_syscalls 442
 
 /*
  * 32 bit systems traditionally used different
diff --git a/linux-headers/asm-mips/unistd_n32.h b/linux-headers/asm-mips/unistd_n32.h
index fce51fee09..59e53b6e07 100644
--- a/linux-headers/asm-mips/unistd_n32.h
+++ b/linux-headers/asm-mips/unistd_n32.h
@@ -1,379 +1,376 @@
-#ifndef _ASM_UNISTD_N32_H
-#define _ASM_UNISTD_N32_H
+#ifndef _ASM_MIPS_UNISTD_N32_H
+#define _ASM_MIPS_UNISTD_N32_H
 
-#define __NR_read (__NR_Linux + 0)
-#define __NR_write (__NR_Linux + 1)
-#define __NR_open (__NR_Linux + 2)
-#define __NR_close (__NR_Linux + 3)
-#define __NR_stat (__NR_Linux + 4)
-#define __NR_fstat (__NR_Linux + 5)
-#define __NR_lstat (__NR_Linux + 6)
-#define __NR_poll (__NR_Linux + 7)
-#define __NR_lseek (__NR_Linux + 8)
-#define __NR_mmap (__NR_Linux + 9)
-#define __NR_mprotect (__NR_Linux + 10)
-#define __NR_munmap (__NR_Linux + 11)
-#define __NR_brk (__NR_Linux + 12)
-#define __NR_rt_sigaction (__NR_Linux + 13)
-#define __NR_rt_sigprocmask (__NR_Linux + 14)
-#define __NR_ioctl (__NR_Linux + 15)
-#define __NR_pread64 (__NR_Linux + 16)
-#define __NR_pwrite64 (__NR_Linux + 17)
-#define __NR_readv (__NR_Linux + 18)
-#define __NR_writev (__NR_Linux + 19)
-#define __NR_access (__NR_Linux + 20)
-#define __NR_pipe (__NR_Linux + 21)
-#define __NR__newselect (__NR_Linux + 22)
-#define __NR_sched_yield (__NR_Linux + 23)
-#define __NR_mremap (__NR_Linux + 24)
-#define __NR_msync (__NR_Linux + 25)
-#define __NR_mincore (__NR_Linux + 26)
-#define __NR_madvise (__NR_Linux + 27)
-#define __NR_shmget (__NR_Linux + 28)
-#define __NR_shmat (__NR_Linux + 29)
-#define __NR_shmctl (__NR_Linux + 30)
-#define __NR_dup (__NR_Linux + 31)
-#define __NR_dup2 (__NR_Linux + 32)
-#define __NR_pause (__NR_Linux + 33)
-#define __NR_nanosleep (__NR_Linux + 34)
-#define __NR_getitimer (__NR_Linux + 35)
-#define __NR_setitimer (__NR_Linux + 36)
-#define __NR_alarm (__NR_Linux + 37)
-#define __NR_getpid (__NR_Linux + 38)
-#define __NR_sendfile (__NR_Linux + 39)
-#define __NR_socket (__NR_Linux + 40)
-#define __NR_connect (__NR_Linux + 41)
-#define __NR_accept (__NR_Linux + 42)
-#define __NR_sendto (__NR_Linux + 43)
-#define __NR_recvfrom (__NR_Linux + 44)
-#define __NR_sendmsg (__NR_Linux + 45)
-#define __NR_recvmsg (__NR_Linux + 46)
-#define __NR_shutdown (__NR_Linux + 47)
-#define __NR_bind (__NR_Linux + 48)
-#define __NR_listen (__NR_Linux + 49)
-#define __NR_getsockname (__NR_Linux + 50)
-#define __NR_getpeername (__NR_Linux + 51)
-#define __NR_socketpair (__NR_Linux + 52)
-#define __NR_setsockopt (__NR_Linux + 53)
-#define __NR_getsockopt (__NR_Linux + 54)
-#define __NR_clone (__NR_Linux + 55)
-#define __NR_fork (__NR_Linux + 56)
-#define __NR_execve (__NR_Linux + 57)
-#define __NR_exit (__NR_Linux + 58)
-#define __NR_wait4 (__NR_Linux + 59)
-#define __NR_kill (__NR_Linux + 60)
-#define __NR_uname (__NR_Linux + 61)
-#define __NR_semget (__NR_Linux + 62)
-#define __NR_semop (__NR_Linux + 63)
-#define __NR_semctl (__NR_Linux + 64)
-#define __NR_shmdt (__NR_Linux + 65)
-#define __NR_msgget (__NR_Linux + 66)
-#define __NR_msgsnd (__NR_Linux + 67)
-#define __NR_msgrcv (__NR_Linux + 68)
-#define __NR_msgctl (__NR_Linux + 69)
-#define __NR_fcntl (__NR_Linux + 70)
-#define __NR_flock (__NR_Linux + 71)
-#define __NR_fsync (__NR_Linux + 72)
-#define __NR_fdatasync (__NR_Linux + 73)
-#define __NR_truncate (__NR_Linux + 74)
-#define __NR_ftruncate (__NR_Linux + 75)
-#define __NR_getdents (__NR_Linux + 76)
-#define __NR_getcwd (__NR_Linux + 77)
-#define __NR_chdir (__NR_Linux + 78)
-#define __NR_fchdir (__NR_Linux + 79)
-#define __NR_rename (__NR_Linux + 80)
-#define __NR_mkdir (__NR_Linux + 81)
-#define __NR_rmdir (__NR_Linux + 82)
-#define __NR_creat (__NR_Linux + 83)
-#define __NR_link (__NR_Linux + 84)
-#define __NR_unlink (__NR_Linux + 85)
-#define __NR_symlink (__NR_Linux + 86)
-#define __NR_readlink (__NR_Linux + 87)
-#define __NR_chmod (__NR_Linux + 88)
-#define __NR_fchmod (__NR_Linux + 89)
-#define __NR_chown (__NR_Linux + 90)
-#define __NR_fchown (__NR_Linux + 91)
-#define __NR_lchown (__NR_Linux + 92)
-#define __NR_umask (__NR_Linux + 93)
-#define __NR_gettimeofday (__NR_Linux + 94)
-#define __NR_getrlimit (__NR_Linux + 95)
-#define __NR_getrusage (__NR_Linux + 96)
-#define __NR_sysinfo (__NR_Linux + 97)
-#define __NR_times (__NR_Linux + 98)
-#define __NR_ptrace (__NR_Linux + 99)
-#define __NR_getuid (__NR_Linux + 100)
-#define __NR_syslog (__NR_Linux + 101)
-#define __NR_getgid (__NR_Linux + 102)
-#define __NR_setuid (__NR_Linux + 103)
-#define __NR_setgid (__NR_Linux + 104)
-#define __NR_geteuid (__NR_Linux + 105)
-#define __NR_getegid (__NR_Linux + 106)
-#define __NR_setpgid (__NR_Linux + 107)
-#define __NR_getppid (__NR_Linux + 108)
-#define __NR_getpgrp (__NR_Linux + 109)
-#define __NR_setsid (__NR_Linux + 110)
-#define __NR_setreuid (__NR_Linux + 111)
-#define __NR_setregid (__NR_Linux + 112)
-#define __NR_getgroups (__NR_Linux + 113)
-#define __NR_setgroups (__NR_Linux + 114)
-#define __NR_setresuid (__NR_Linux + 115)
-#define __NR_getresuid (__NR_Linux + 116)
-#define __NR_setresgid (__NR_Linux + 117)
-#define __NR_getresgid (__NR_Linux + 118)
-#define __NR_getpgid (__NR_Linux + 119)
-#define __NR_setfsuid (__NR_Linux + 120)
-#define __NR_setfsgid (__NR_Linux + 121)
-#define __NR_getsid (__NR_Linux + 122)
-#define __NR_capget (__NR_Linux + 123)
-#define __NR_capset (__NR_Linux + 124)
-#define __NR_rt_sigpending (__NR_Linux + 125)
-#define __NR_rt_sigtimedwait (__NR_Linux + 126)
-#define __NR_rt_sigqueueinfo (__NR_Linux + 127)
-#define __NR_rt_sigsuspend (__NR_Linux + 128)
-#define __NR_sigaltstack (__NR_Linux + 129)
-#define __NR_utime (__NR_Linux + 130)
-#define __NR_mknod (__NR_Linux + 131)
-#define __NR_personality (__NR_Linux + 132)
-#define __NR_ustat (__NR_Linux + 133)
-#define __NR_statfs (__NR_Linux + 134)
-#define __NR_fstatfs (__NR_Linux + 135)
-#define __NR_sysfs (__NR_Linux + 136)
-#define __NR_getpriority (__NR_Linux + 137)
-#define __NR_setpriority (__NR_Linux + 138)
-#define __NR_sched_setparam (__NR_Linux + 139)
-#define __NR_sched_getparam (__NR_Linux + 140)
-#define __NR_sched_setscheduler (__NR_Linux + 141)
-#define __NR_sched_getscheduler (__NR_Linux + 142)
-#define __NR_sched_get_priority_max (__NR_Linux + 143)
-#define __NR_sched_get_priority_min (__NR_Linux + 144)
-#define __NR_sched_rr_get_interval (__NR_Linux + 145)
-#define __NR_mlock (__NR_Linux + 146)
-#define __NR_munlock (__NR_Linux + 147)
-#define __NR_mlockall (__NR_Linux + 148)
-#define __NR_munlockall (__NR_Linux + 149)
-#define __NR_vhangup (__NR_Linux + 150)
-#define __NR_pivot_root (__NR_Linux + 151)
-#define __NR__sysctl (__NR_Linux + 152)
-#define __NR_prctl (__NR_Linux + 153)
-#define __NR_adjtimex (__NR_Linux + 154)
-#define __NR_setrlimit (__NR_Linux + 155)
-#define __NR_chroot (__NR_Linux + 156)
-#define __NR_sync (__NR_Linux + 157)
-#define __NR_acct (__NR_Linux + 158)
-#define __NR_settimeofday (__NR_Linux + 159)
-#define __NR_mount (__NR_Linux + 160)
-#define __NR_umount2 (__NR_Linux + 161)
-#define __NR_swapon (__NR_Linux + 162)
-#define __NR_swapoff (__NR_Linux + 163)
-#define __NR_reboot (__NR_Linux + 164)
-#define __NR_sethostname (__NR_Linux + 165)
-#define __NR_setdomainname (__NR_Linux + 166)
-#define __NR_create_module (__NR_Linux + 167)
-#define __NR_init_module (__NR_Linux + 168)
-#define __NR_delete_module (__NR_Linux + 169)
-#define __NR_get_kernel_syms (__NR_Linux + 170)
-#define __NR_query_module (__NR_Linux + 171)
-#define __NR_quotactl (__NR_Linux + 172)
-#define __NR_nfsservctl (__NR_Linux + 173)
-#define __NR_getpmsg (__NR_Linux + 174)
-#define __NR_putpmsg (__NR_Linux + 175)
-#define __NR_afs_syscall (__NR_Linux + 176)
-#define __NR_reserved177 (__NR_Linux + 177)
-#define __NR_gettid (__NR_Linux + 178)
-#define __NR_readahead (__NR_Linux + 179)
-#define __NR_setxattr (__NR_Linux + 180)
-#define __NR_lsetxattr (__NR_Linux + 181)
-#define __NR_fsetxattr (__NR_Linux + 182)
-#define __NR_getxattr (__NR_Linux + 183)
-#define __NR_lgetxattr (__NR_Linux + 184)
-#define __NR_fgetxattr (__NR_Linux + 185)
-#define __NR_listxattr (__NR_Linux + 186)
-#define __NR_llistxattr (__NR_Linux + 187)
-#define __NR_flistxattr (__NR_Linux + 188)
-#define __NR_removexattr (__NR_Linux + 189)
-#define __NR_lremovexattr (__NR_Linux + 190)
-#define __NR_fremovexattr (__NR_Linux + 191)
-#define __NR_tkill (__NR_Linux + 192)
-#define __NR_reserved193 (__NR_Linux + 193)
-#define __NR_futex (__NR_Linux + 194)
-#define __NR_sched_setaffinity (__NR_Linux + 195)
-#define __NR_sched_getaffinity (__NR_Linux + 196)
-#define __NR_cacheflush (__NR_Linux + 197)
-#define __NR_cachectl (__NR_Linux + 198)
-#define __NR_sysmips (__NR_Linux + 199)
-#define __NR_io_setup (__NR_Linux + 200)
-#define __NR_io_destroy (__NR_Linux + 201)
-#define __NR_io_getevents (__NR_Linux + 202)
-#define __NR_io_submit (__NR_Linux + 203)
-#define __NR_io_cancel (__NR_Linux + 204)
-#define __NR_exit_group (__NR_Linux + 205)
-#define __NR_lookup_dcookie (__NR_Linux + 206)
-#define __NR_epoll_create (__NR_Linux + 207)
-#define __NR_epoll_ctl (__NR_Linux + 208)
-#define __NR_epoll_wait (__NR_Linux + 209)
-#define __NR_remap_file_pages (__NR_Linux + 210)
-#define __NR_rt_sigreturn (__NR_Linux + 211)
-#define __NR_fcntl64 (__NR_Linux + 212)
-#define __NR_set_tid_address (__NR_Linux + 213)
-#define __NR_restart_syscall (__NR_Linux + 214)
-#define __NR_semtimedop (__NR_Linux + 215)
-#define __NR_fadvise64 (__NR_Linux + 216)
-#define __NR_statfs64 (__NR_Linux + 217)
-#define __NR_fstatfs64 (__NR_Linux + 218)
-#define __NR_sendfile64 (__NR_Linux + 219)
-#define __NR_timer_create (__NR_Linux + 220)
-#define __NR_timer_settime (__NR_Linux + 221)
-#define __NR_timer_gettime (__NR_Linux + 222)
-#define __NR_timer_getoverrun (__NR_Linux + 223)
-#define __NR_timer_delete (__NR_Linux + 224)
-#define __NR_clock_settime (__NR_Linux + 225)
-#define __NR_clock_gettime (__NR_Linux + 226)
-#define __NR_clock_getres (__NR_Linux + 227)
-#define __NR_clock_nanosleep (__NR_Linux + 228)
-#define __NR_tgkill (__NR_Linux + 229)
-#define __NR_utimes (__NR_Linux + 230)
-#define __NR_mbind (__NR_Linux + 231)
-#define __NR_get_mempolicy (__NR_Linux + 232)
-#define __NR_set_mempolicy (__NR_Linux + 233)
-#define __NR_mq_open (__NR_Linux + 234)
-#define __NR_mq_unlink (__NR_Linux + 235)
-#define __NR_mq_timedsend (__NR_Linux + 236)
-#define __NR_mq_timedreceive (__NR_Linux + 237)
-#define __NR_mq_notify (__NR_Linux + 238)
-#define __NR_mq_getsetattr (__NR_Linux + 239)
-#define __NR_vserver (__NR_Linux + 240)
-#define __NR_waitid (__NR_Linux + 241)
-#define __NR_add_key (__NR_Linux + 243)
-#define __NR_request_key (__NR_Linux + 244)
-#define __NR_keyctl (__NR_Linux + 245)
-#define __NR_set_thread_area (__NR_Linux + 246)
-#define __NR_inotify_init (__NR_Linux + 247)
-#define __NR_inotify_add_watch (__NR_Linux + 248)
-#define __NR_inotify_rm_watch (__NR_Linux + 249)
-#define __NR_migrate_pages (__NR_Linux + 250)
-#define __NR_openat (__NR_Linux + 251)
-#define __NR_mkdirat (__NR_Linux + 252)
-#define __NR_mknodat (__NR_Linux + 253)
-#define __NR_fchownat (__NR_Linux + 254)
-#define __NR_futimesat (__NR_Linux + 255)
-#define __NR_newfstatat (__NR_Linux + 256)
-#define __NR_unlinkat (__NR_Linux + 257)
-#define __NR_renameat (__NR_Linux + 258)
-#define __NR_linkat (__NR_Linux + 259)
-#define __NR_symlinkat (__NR_Linux + 260)
-#define __NR_readlinkat (__NR_Linux + 261)
-#define __NR_fchmodat (__NR_Linux + 262)
-#define __NR_faccessat (__NR_Linux + 263)
-#define __NR_pselect6 (__NR_Linux + 264)
-#define __NR_ppoll (__NR_Linux + 265)
-#define __NR_unshare (__NR_Linux + 266)
-#define __NR_splice (__NR_Linux + 267)
-#define __NR_sync_file_range (__NR_Linux + 268)
-#define __NR_tee (__NR_Linux + 269)
-#define __NR_vmsplice (__NR_Linux + 270)
-#define __NR_move_pages (__NR_Linux + 271)
-#define __NR_set_robust_list (__NR_Linux + 272)
-#define __NR_get_robust_list (__NR_Linux + 273)
-#define __NR_kexec_load (__NR_Linux + 274)
-#define __NR_getcpu (__NR_Linux + 275)
-#define __NR_epoll_pwait (__NR_Linux + 276)
-#define __NR_ioprio_set (__NR_Linux + 277)
-#define __NR_ioprio_get (__NR_Linux + 278)
-#define __NR_utimensat (__NR_Linux + 279)
-#define __NR_signalfd (__NR_Linux + 280)
-#define __NR_timerfd (__NR_Linux + 281)
-#define __NR_eventfd (__NR_Linux + 282)
-#define __NR_fallocate (__NR_Linux + 283)
-#define __NR_timerfd_create (__NR_Linux + 284)
-#define __NR_timerfd_gettime (__NR_Linux + 285)
-#define __NR_timerfd_settime (__NR_Linux + 286)
-#define __NR_signalfd4 (__NR_Linux + 287)
-#define __NR_eventfd2 (__NR_Linux + 288)
-#define __NR_epoll_create1 (__NR_Linux + 289)
-#define __NR_dup3 (__NR_Linux + 290)
-#define __NR_pipe2 (__NR_Linux + 291)
-#define __NR_inotify_init1 (__NR_Linux + 292)
-#define __NR_preadv (__NR_Linux + 293)
-#define __NR_pwritev (__NR_Linux + 294)
-#define __NR_rt_tgsigqueueinfo (__NR_Linux + 295)
-#define __NR_perf_event_open (__NR_Linux + 296)
-#define __NR_accept4 (__NR_Linux + 297)
-#define __NR_recvmmsg (__NR_Linux + 298)
-#define __NR_getdents64 (__NR_Linux + 299)
-#define __NR_fanotify_init (__NR_Linux + 300)
-#define __NR_fanotify_mark (__NR_Linux + 301)
-#define __NR_prlimit64 (__NR_Linux + 302)
-#define __NR_name_to_handle_at (__NR_Linux + 303)
-#define __NR_open_by_handle_at (__NR_Linux + 304)
-#define __NR_clock_adjtime (__NR_Linux + 305)
-#define __NR_syncfs (__NR_Linux + 306)
-#define __NR_sendmmsg (__NR_Linux + 307)
-#define __NR_setns (__NR_Linux + 308)
-#define __NR_process_vm_readv (__NR_Linux + 309)
-#define __NR_process_vm_writev (__NR_Linux + 310)
-#define __NR_kcmp (__NR_Linux + 311)
-#define __NR_finit_module (__NR_Linux + 312)
-#define __NR_sched_setattr (__NR_Linux + 313)
-#define __NR_sched_getattr (__NR_Linux + 314)
-#define __NR_renameat2 (__NR_Linux + 315)
-#define __NR_seccomp (__NR_Linux + 316)
-#define __NR_getrandom (__NR_Linux + 317)
-#define __NR_memfd_create (__NR_Linux + 318)
-#define __NR_bpf (__NR_Linux + 319)
-#define __NR_execveat (__NR_Linux + 320)
-#define __NR_userfaultfd (__NR_Linux + 321)
-#define __NR_membarrier (__NR_Linux + 322)
-#define __NR_mlock2 (__NR_Linux + 323)
-#define __NR_copy_file_range (__NR_Linux + 324)
-#define __NR_preadv2 (__NR_Linux + 325)
-#define __NR_pwritev2 (__NR_Linux + 326)
-#define __NR_pkey_mprotect (__NR_Linux + 327)
-#define __NR_pkey_alloc (__NR_Linux + 328)
-#define __NR_pkey_free (__NR_Linux + 329)
-#define __NR_statx (__NR_Linux + 330)
-#define __NR_rseq (__NR_Linux + 331)
-#define __NR_io_pgetevents (__NR_Linux + 332)
-#define __NR_clock_gettime64 (__NR_Linux + 403)
-#define __NR_clock_settime64 (__NR_Linux + 404)
-#define __NR_clock_adjtime64 (__NR_Linux + 405)
-#define __NR_clock_getres_time64 (__NR_Linux + 406)
-#define __NR_clock_nanosleep_time64 (__NR_Linux + 407)
-#define __NR_timer_gettime64 (__NR_Linux + 408)
-#define __NR_timer_settime64 (__NR_Linux + 409)
-#define __NR_timerfd_gettime64 (__NR_Linux + 410)
-#define __NR_timerfd_settime64 (__NR_Linux + 411)
-#define __NR_utimensat_time64 (__NR_Linux + 412)
-#define __NR_pselect6_time64 (__NR_Linux + 413)
-#define __NR_ppoll_time64 (__NR_Linux + 414)
-#define __NR_io_pgetevents_time64 (__NR_Linux + 416)
-#define __NR_recvmmsg_time64 (__NR_Linux + 417)
-#define __NR_mq_timedsend_time64 (__NR_Linux + 418)
-#define __NR_mq_timedreceive_time64 (__NR_Linux + 419)
-#define __NR_semtimedop_time64 (__NR_Linux + 420)
-#define __NR_rt_sigtimedwait_time64 (__NR_Linux + 421)
-#define __NR_futex_time64 (__NR_Linux + 422)
-#define __NR_sched_rr_get_interval_time64 (__NR_Linux + 423)
-#define __NR_pidfd_send_signal (__NR_Linux + 424)
-#define __NR_io_uring_setup (__NR_Linux + 425)
-#define __NR_io_uring_enter (__NR_Linux + 426)
-#define __NR_io_uring_register (__NR_Linux + 427)
-#define __NR_open_tree (__NR_Linux + 428)
-#define __NR_move_mount (__NR_Linux + 429)
-#define __NR_fsopen (__NR_Linux + 430)
-#define __NR_fsconfig (__NR_Linux + 431)
-#define __NR_fsmount (__NR_Linux + 432)
-#define __NR_fspick (__NR_Linux + 433)
-#define __NR_pidfd_open (__NR_Linux + 434)
-#define __NR_clone3 (__NR_Linux + 435)
-#define __NR_close_range (__NR_Linux + 436)
-#define __NR_openat2 (__NR_Linux + 437)
-#define __NR_pidfd_getfd (__NR_Linux + 438)
-#define __NR_faccessat2 (__NR_Linux + 439)
-#define __NR_process_madvise (__NR_Linux + 440)
-#define __NR_epoll_pwait2 (__NR_Linux + 441)
-#define __NR_mount_setattr (__NR_Linux + 442)
-#define __NR_landlock_create_ruleset (__NR_Linux + 444)
-#define __NR_landlock_add_rule (__NR_Linux + 445)
-#define __NR_landlock_restrict_self (__NR_Linux + 446)
+#define __NR_read	(__NR_Linux + 0)
+#define __NR_write	(__NR_Linux + 1)
+#define __NR_open	(__NR_Linux + 2)
+#define __NR_close	(__NR_Linux + 3)
+#define __NR_stat	(__NR_Linux + 4)
+#define __NR_fstat	(__NR_Linux + 5)
+#define __NR_lstat	(__NR_Linux + 6)
+#define __NR_poll	(__NR_Linux + 7)
+#define __NR_lseek	(__NR_Linux + 8)
+#define __NR_mmap	(__NR_Linux + 9)
+#define __NR_mprotect	(__NR_Linux + 10)
+#define __NR_munmap	(__NR_Linux + 11)
+#define __NR_brk	(__NR_Linux + 12)
+#define __NR_rt_sigaction	(__NR_Linux + 13)
+#define __NR_rt_sigprocmask	(__NR_Linux + 14)
+#define __NR_ioctl	(__NR_Linux + 15)
+#define __NR_pread64	(__NR_Linux + 16)
+#define __NR_pwrite64	(__NR_Linux + 17)
+#define __NR_readv	(__NR_Linux + 18)
+#define __NR_writev	(__NR_Linux + 19)
+#define __NR_access	(__NR_Linux + 20)
+#define __NR_pipe	(__NR_Linux + 21)
+#define __NR__newselect	(__NR_Linux + 22)
+#define __NR_sched_yield	(__NR_Linux + 23)
+#define __NR_mremap	(__NR_Linux + 24)
+#define __NR_msync	(__NR_Linux + 25)
+#define __NR_mincore	(__NR_Linux + 26)
+#define __NR_madvise	(__NR_Linux + 27)
+#define __NR_shmget	(__NR_Linux + 28)
+#define __NR_shmat	(__NR_Linux + 29)
+#define __NR_shmctl	(__NR_Linux + 30)
+#define __NR_dup	(__NR_Linux + 31)
+#define __NR_dup2	(__NR_Linux + 32)
+#define __NR_pause	(__NR_Linux + 33)
+#define __NR_nanosleep	(__NR_Linux + 34)
+#define __NR_getitimer	(__NR_Linux + 35)
+#define __NR_setitimer	(__NR_Linux + 36)
+#define __NR_alarm	(__NR_Linux + 37)
+#define __NR_getpid	(__NR_Linux + 38)
+#define __NR_sendfile	(__NR_Linux + 39)
+#define __NR_socket	(__NR_Linux + 40)
+#define __NR_connect	(__NR_Linux + 41)
+#define __NR_accept	(__NR_Linux + 42)
+#define __NR_sendto	(__NR_Linux + 43)
+#define __NR_recvfrom	(__NR_Linux + 44)
+#define __NR_sendmsg	(__NR_Linux + 45)
+#define __NR_recvmsg	(__NR_Linux + 46)
+#define __NR_shutdown	(__NR_Linux + 47)
+#define __NR_bind	(__NR_Linux + 48)
+#define __NR_listen	(__NR_Linux + 49)
+#define __NR_getsockname	(__NR_Linux + 50)
+#define __NR_getpeername	(__NR_Linux + 51)
+#define __NR_socketpair	(__NR_Linux + 52)
+#define __NR_setsockopt	(__NR_Linux + 53)
+#define __NR_getsockopt	(__NR_Linux + 54)
+#define __NR_clone	(__NR_Linux + 55)
+#define __NR_fork	(__NR_Linux + 56)
+#define __NR_execve	(__NR_Linux + 57)
+#define __NR_exit	(__NR_Linux + 58)
+#define __NR_wait4	(__NR_Linux + 59)
+#define __NR_kill	(__NR_Linux + 60)
+#define __NR_uname	(__NR_Linux + 61)
+#define __NR_semget	(__NR_Linux + 62)
+#define __NR_semop	(__NR_Linux + 63)
+#define __NR_semctl	(__NR_Linux + 64)
+#define __NR_shmdt	(__NR_Linux + 65)
+#define __NR_msgget	(__NR_Linux + 66)
+#define __NR_msgsnd	(__NR_Linux + 67)
+#define __NR_msgrcv	(__NR_Linux + 68)
+#define __NR_msgctl	(__NR_Linux + 69)
+#define __NR_fcntl	(__NR_Linux + 70)
+#define __NR_flock	(__NR_Linux + 71)
+#define __NR_fsync	(__NR_Linux + 72)
+#define __NR_fdatasync	(__NR_Linux + 73)
+#define __NR_truncate	(__NR_Linux + 74)
+#define __NR_ftruncate	(__NR_Linux + 75)
+#define __NR_getdents	(__NR_Linux + 76)
+#define __NR_getcwd	(__NR_Linux + 77)
+#define __NR_chdir	(__NR_Linux + 78)
+#define __NR_fchdir	(__NR_Linux + 79)
+#define __NR_rename	(__NR_Linux + 80)
+#define __NR_mkdir	(__NR_Linux + 81)
+#define __NR_rmdir	(__NR_Linux + 82)
+#define __NR_creat	(__NR_Linux + 83)
+#define __NR_link	(__NR_Linux + 84)
+#define __NR_unlink	(__NR_Linux + 85)
+#define __NR_symlink	(__NR_Linux + 86)
+#define __NR_readlink	(__NR_Linux + 87)
+#define __NR_chmod	(__NR_Linux + 88)
+#define __NR_fchmod	(__NR_Linux + 89)
+#define __NR_chown	(__NR_Linux + 90)
+#define __NR_fchown	(__NR_Linux + 91)
+#define __NR_lchown	(__NR_Linux + 92)
+#define __NR_umask	(__NR_Linux + 93)
+#define __NR_gettimeofday	(__NR_Linux + 94)
+#define __NR_getrlimit	(__NR_Linux + 95)
+#define __NR_getrusage	(__NR_Linux + 96)
+#define __NR_sysinfo	(__NR_Linux + 97)
+#define __NR_times	(__NR_Linux + 98)
+#define __NR_ptrace	(__NR_Linux + 99)
+#define __NR_getuid	(__NR_Linux + 100)
+#define __NR_syslog	(__NR_Linux + 101)
+#define __NR_getgid	(__NR_Linux + 102)
+#define __NR_setuid	(__NR_Linux + 103)
+#define __NR_setgid	(__NR_Linux + 104)
+#define __NR_geteuid	(__NR_Linux + 105)
+#define __NR_getegid	(__NR_Linux + 106)
+#define __NR_setpgid	(__NR_Linux + 107)
+#define __NR_getppid	(__NR_Linux + 108)
+#define __NR_getpgrp	(__NR_Linux + 109)
+#define __NR_setsid	(__NR_Linux + 110)
+#define __NR_setreuid	(__NR_Linux + 111)
+#define __NR_setregid	(__NR_Linux + 112)
+#define __NR_getgroups	(__NR_Linux + 113)
+#define __NR_setgroups	(__NR_Linux + 114)
+#define __NR_setresuid	(__NR_Linux + 115)
+#define __NR_getresuid	(__NR_Linux + 116)
+#define __NR_setresgid	(__NR_Linux + 117)
+#define __NR_getresgid	(__NR_Linux + 118)
+#define __NR_getpgid	(__NR_Linux + 119)
+#define __NR_setfsuid	(__NR_Linux + 120)
+#define __NR_setfsgid	(__NR_Linux + 121)
+#define __NR_getsid	(__NR_Linux + 122)
+#define __NR_capget	(__NR_Linux + 123)
+#define __NR_capset	(__NR_Linux + 124)
+#define __NR_rt_sigpending	(__NR_Linux + 125)
+#define __NR_rt_sigtimedwait	(__NR_Linux + 126)
+#define __NR_rt_sigqueueinfo	(__NR_Linux + 127)
+#define __NR_rt_sigsuspend	(__NR_Linux + 128)
+#define __NR_sigaltstack	(__NR_Linux + 129)
+#define __NR_utime	(__NR_Linux + 130)
+#define __NR_mknod	(__NR_Linux + 131)
+#define __NR_personality	(__NR_Linux + 132)
+#define __NR_ustat	(__NR_Linux + 133)
+#define __NR_statfs	(__NR_Linux + 134)
+#define __NR_fstatfs	(__NR_Linux + 135)
+#define __NR_sysfs	(__NR_Linux + 136)
+#define __NR_getpriority	(__NR_Linux + 137)
+#define __NR_setpriority	(__NR_Linux + 138)
+#define __NR_sched_setparam	(__NR_Linux + 139)
+#define __NR_sched_getparam	(__NR_Linux + 140)
+#define __NR_sched_setscheduler	(__NR_Linux + 141)
+#define __NR_sched_getscheduler	(__NR_Linux + 142)
+#define __NR_sched_get_priority_max	(__NR_Linux + 143)
+#define __NR_sched_get_priority_min	(__NR_Linux + 144)
+#define __NR_sched_rr_get_interval	(__NR_Linux + 145)
+#define __NR_mlock	(__NR_Linux + 146)
+#define __NR_munlock	(__NR_Linux + 147)
+#define __NR_mlockall	(__NR_Linux + 148)
+#define __NR_munlockall	(__NR_Linux + 149)
+#define __NR_vhangup	(__NR_Linux + 150)
+#define __NR_pivot_root	(__NR_Linux + 151)
+#define __NR__sysctl	(__NR_Linux + 152)
+#define __NR_prctl	(__NR_Linux + 153)
+#define __NR_adjtimex	(__NR_Linux + 154)
+#define __NR_setrlimit	(__NR_Linux + 155)
+#define __NR_chroot	(__NR_Linux + 156)
+#define __NR_sync	(__NR_Linux + 157)
+#define __NR_acct	(__NR_Linux + 158)
+#define __NR_settimeofday	(__NR_Linux + 159)
+#define __NR_mount	(__NR_Linux + 160)
+#define __NR_umount2	(__NR_Linux + 161)
+#define __NR_swapon	(__NR_Linux + 162)
+#define __NR_swapoff	(__NR_Linux + 163)
+#define __NR_reboot	(__NR_Linux + 164)
+#define __NR_sethostname	(__NR_Linux + 165)
+#define __NR_setdomainname	(__NR_Linux + 166)
+#define __NR_create_module	(__NR_Linux + 167)
+#define __NR_init_module	(__NR_Linux + 168)
+#define __NR_delete_module	(__NR_Linux + 169)
+#define __NR_get_kernel_syms	(__NR_Linux + 170)
+#define __NR_query_module	(__NR_Linux + 171)
+#define __NR_quotactl	(__NR_Linux + 172)
+#define __NR_nfsservctl	(__NR_Linux + 173)
+#define __NR_getpmsg	(__NR_Linux + 174)
+#define __NR_putpmsg	(__NR_Linux + 175)
+#define __NR_afs_syscall	(__NR_Linux + 176)
+#define __NR_reserved177	(__NR_Linux + 177)
+#define __NR_gettid	(__NR_Linux + 178)
+#define __NR_readahead	(__NR_Linux + 179)
+#define __NR_setxattr	(__NR_Linux + 180)
+#define __NR_lsetxattr	(__NR_Linux + 181)
+#define __NR_fsetxattr	(__NR_Linux + 182)
+#define __NR_getxattr	(__NR_Linux + 183)
+#define __NR_lgetxattr	(__NR_Linux + 184)
+#define __NR_fgetxattr	(__NR_Linux + 185)
+#define __NR_listxattr	(__NR_Linux + 186)
+#define __NR_llistxattr	(__NR_Linux + 187)
+#define __NR_flistxattr	(__NR_Linux + 188)
+#define __NR_removexattr	(__NR_Linux + 189)
+#define __NR_lremovexattr	(__NR_Linux + 190)
+#define __NR_fremovexattr	(__NR_Linux + 191)
+#define __NR_tkill	(__NR_Linux + 192)
+#define __NR_reserved193	(__NR_Linux + 193)
+#define __NR_futex	(__NR_Linux + 194)
+#define __NR_sched_setaffinity	(__NR_Linux + 195)
+#define __NR_sched_getaffinity	(__NR_Linux + 196)
+#define __NR_cacheflush	(__NR_Linux + 197)
+#define __NR_cachectl	(__NR_Linux + 198)
+#define __NR_sysmips	(__NR_Linux + 199)
+#define __NR_io_setup	(__NR_Linux + 200)
+#define __NR_io_destroy	(__NR_Linux + 201)
+#define __NR_io_getevents	(__NR_Linux + 202)
+#define __NR_io_submit	(__NR_Linux + 203)
+#define __NR_io_cancel	(__NR_Linux + 204)
+#define __NR_exit_group	(__NR_Linux + 205)
+#define __NR_lookup_dcookie	(__NR_Linux + 206)
+#define __NR_epoll_create	(__NR_Linux + 207)
+#define __NR_epoll_ctl	(__NR_Linux + 208)
+#define __NR_epoll_wait	(__NR_Linux + 209)
+#define __NR_remap_file_pages	(__NR_Linux + 210)
+#define __NR_rt_sigreturn	(__NR_Linux + 211)
+#define __NR_fcntl64	(__NR_Linux + 212)
+#define __NR_set_tid_address	(__NR_Linux + 213)
+#define __NR_restart_syscall	(__NR_Linux + 214)
+#define __NR_semtimedop	(__NR_Linux + 215)
+#define __NR_fadvise64	(__NR_Linux + 216)
+#define __NR_statfs64	(__NR_Linux + 217)
+#define __NR_fstatfs64	(__NR_Linux + 218)
+#define __NR_sendfile64	(__NR_Linux + 219)
+#define __NR_timer_create	(__NR_Linux + 220)
+#define __NR_timer_settime	(__NR_Linux + 221)
+#define __NR_timer_gettime	(__NR_Linux + 222)
+#define __NR_timer_getoverrun	(__NR_Linux + 223)
+#define __NR_timer_delete	(__NR_Linux + 224)
+#define __NR_clock_settime	(__NR_Linux + 225)
+#define __NR_clock_gettime	(__NR_Linux + 226)
+#define __NR_clock_getres	(__NR_Linux + 227)
+#define __NR_clock_nanosleep	(__NR_Linux + 228)
+#define __NR_tgkill	(__NR_Linux + 229)
+#define __NR_utimes	(__NR_Linux + 230)
+#define __NR_mbind	(__NR_Linux + 231)
+#define __NR_get_mempolicy	(__NR_Linux + 232)
+#define __NR_set_mempolicy	(__NR_Linux + 233)
+#define __NR_mq_open	(__NR_Linux + 234)
+#define __NR_mq_unlink	(__NR_Linux + 235)
+#define __NR_mq_timedsend	(__NR_Linux + 236)
+#define __NR_mq_timedreceive	(__NR_Linux + 237)
+#define __NR_mq_notify	(__NR_Linux + 238)
+#define __NR_mq_getsetattr	(__NR_Linux + 239)
+#define __NR_vserver	(__NR_Linux + 240)
+#define __NR_waitid	(__NR_Linux + 241)
+#define __NR_add_key	(__NR_Linux + 243)
+#define __NR_request_key	(__NR_Linux + 244)
+#define __NR_keyctl	(__NR_Linux + 245)
+#define __NR_set_thread_area	(__NR_Linux + 246)
+#define __NR_inotify_init	(__NR_Linux + 247)
+#define __NR_inotify_add_watch	(__NR_Linux + 248)
+#define __NR_inotify_rm_watch	(__NR_Linux + 249)
+#define __NR_migrate_pages	(__NR_Linux + 250)
+#define __NR_openat	(__NR_Linux + 251)
+#define __NR_mkdirat	(__NR_Linux + 252)
+#define __NR_mknodat	(__NR_Linux + 253)
+#define __NR_fchownat	(__NR_Linux + 254)
+#define __NR_futimesat	(__NR_Linux + 255)
+#define __NR_newfstatat	(__NR_Linux + 256)
+#define __NR_unlinkat	(__NR_Linux + 257)
+#define __NR_renameat	(__NR_Linux + 258)
+#define __NR_linkat	(__NR_Linux + 259)
+#define __NR_symlinkat	(__NR_Linux + 260)
+#define __NR_readlinkat	(__NR_Linux + 261)
+#define __NR_fchmodat	(__NR_Linux + 262)
+#define __NR_faccessat	(__NR_Linux + 263)
+#define __NR_pselect6	(__NR_Linux + 264)
+#define __NR_ppoll	(__NR_Linux + 265)
+#define __NR_unshare	(__NR_Linux + 266)
+#define __NR_splice	(__NR_Linux + 267)
+#define __NR_sync_file_range	(__NR_Linux + 268)
+#define __NR_tee	(__NR_Linux + 269)
+#define __NR_vmsplice	(__NR_Linux + 270)
+#define __NR_move_pages	(__NR_Linux + 271)
+#define __NR_set_robust_list	(__NR_Linux + 272)
+#define __NR_get_robust_list	(__NR_Linux + 273)
+#define __NR_kexec_load	(__NR_Linux + 274)
+#define __NR_getcpu	(__NR_Linux + 275)
+#define __NR_epoll_pwait	(__NR_Linux + 276)
+#define __NR_ioprio_set	(__NR_Linux + 277)
+#define __NR_ioprio_get	(__NR_Linux + 278)
+#define __NR_utimensat	(__NR_Linux + 279)
+#define __NR_signalfd	(__NR_Linux + 280)
+#define __NR_timerfd	(__NR_Linux + 281)
+#define __NR_eventfd	(__NR_Linux + 282)
+#define __NR_fallocate	(__NR_Linux + 283)
+#define __NR_timerfd_create	(__NR_Linux + 284)
+#define __NR_timerfd_gettime	(__NR_Linux + 285)
+#define __NR_timerfd_settime	(__NR_Linux + 286)
+#define __NR_signalfd4	(__NR_Linux + 287)
+#define __NR_eventfd2	(__NR_Linux + 288)
+#define __NR_epoll_create1	(__NR_Linux + 289)
+#define __NR_dup3	(__NR_Linux + 290)
+#define __NR_pipe2	(__NR_Linux + 291)
+#define __NR_inotify_init1	(__NR_Linux + 292)
+#define __NR_preadv	(__NR_Linux + 293)
+#define __NR_pwritev	(__NR_Linux + 294)
+#define __NR_rt_tgsigqueueinfo	(__NR_Linux + 295)
+#define __NR_perf_event_open	(__NR_Linux + 296)
+#define __NR_accept4	(__NR_Linux + 297)
+#define __NR_recvmmsg	(__NR_Linux + 298)
+#define __NR_getdents64	(__NR_Linux + 299)
+#define __NR_fanotify_init	(__NR_Linux + 300)
+#define __NR_fanotify_mark	(__NR_Linux + 301)
+#define __NR_prlimit64	(__NR_Linux + 302)
+#define __NR_name_to_handle_at	(__NR_Linux + 303)
+#define __NR_open_by_handle_at	(__NR_Linux + 304)
+#define __NR_clock_adjtime	(__NR_Linux + 305)
+#define __NR_syncfs	(__NR_Linux + 306)
+#define __NR_sendmmsg	(__NR_Linux + 307)
+#define __NR_setns	(__NR_Linux + 308)
+#define __NR_process_vm_readv	(__NR_Linux + 309)
+#define __NR_process_vm_writev	(__NR_Linux + 310)
+#define __NR_kcmp	(__NR_Linux + 311)
+#define __NR_finit_module	(__NR_Linux + 312)
+#define __NR_sched_setattr	(__NR_Linux + 313)
+#define __NR_sched_getattr	(__NR_Linux + 314)
+#define __NR_renameat2	(__NR_Linux + 315)
+#define __NR_seccomp	(__NR_Linux + 316)
+#define __NR_getrandom	(__NR_Linux + 317)
+#define __NR_memfd_create	(__NR_Linux + 318)
+#define __NR_bpf	(__NR_Linux + 319)
+#define __NR_execveat	(__NR_Linux + 320)
+#define __NR_userfaultfd	(__NR_Linux + 321)
+#define __NR_membarrier	(__NR_Linux + 322)
+#define __NR_mlock2	(__NR_Linux + 323)
+#define __NR_copy_file_range	(__NR_Linux + 324)
+#define __NR_preadv2	(__NR_Linux + 325)
+#define __NR_pwritev2	(__NR_Linux + 326)
+#define __NR_pkey_mprotect	(__NR_Linux + 327)
+#define __NR_pkey_alloc	(__NR_Linux + 328)
+#define __NR_pkey_free	(__NR_Linux + 329)
+#define __NR_statx	(__NR_Linux + 330)
+#define __NR_rseq	(__NR_Linux + 331)
+#define __NR_io_pgetevents	(__NR_Linux + 332)
+#define __NR_clock_gettime64	(__NR_Linux + 403)
+#define __NR_clock_settime64	(__NR_Linux + 404)
+#define __NR_clock_adjtime64	(__NR_Linux + 405)
+#define __NR_clock_getres_time64	(__NR_Linux + 406)
+#define __NR_clock_nanosleep_time64	(__NR_Linux + 407)
+#define __NR_timer_gettime64	(__NR_Linux + 408)
+#define __NR_timer_settime64	(__NR_Linux + 409)
+#define __NR_timerfd_gettime64	(__NR_Linux + 410)
+#define __NR_timerfd_settime64	(__NR_Linux + 411)
+#define __NR_utimensat_time64	(__NR_Linux + 412)
+#define __NR_pselect6_time64	(__NR_Linux + 413)
+#define __NR_ppoll_time64	(__NR_Linux + 414)
+#define __NR_io_pgetevents_time64	(__NR_Linux + 416)
+#define __NR_recvmmsg_time64	(__NR_Linux + 417)
+#define __NR_mq_timedsend_time64	(__NR_Linux + 418)
+#define __NR_mq_timedreceive_time64	(__NR_Linux + 419)
+#define __NR_semtimedop_time64	(__NR_Linux + 420)
+#define __NR_rt_sigtimedwait_time64	(__NR_Linux + 421)
+#define __NR_futex_time64	(__NR_Linux + 422)
+#define __NR_sched_rr_get_interval_time64	(__NR_Linux + 423)
+#define __NR_pidfd_send_signal	(__NR_Linux + 424)
+#define __NR_io_uring_setup	(__NR_Linux + 425)
+#define __NR_io_uring_enter	(__NR_Linux + 426)
+#define __NR_io_uring_register	(__NR_Linux + 427)
+#define __NR_open_tree	(__NR_Linux + 428)
+#define __NR_move_mount	(__NR_Linux + 429)
+#define __NR_fsopen	(__NR_Linux + 430)
+#define __NR_fsconfig	(__NR_Linux + 431)
+#define __NR_fsmount	(__NR_Linux + 432)
+#define __NR_fspick	(__NR_Linux + 433)
+#define __NR_pidfd_open	(__NR_Linux + 434)
+#define __NR_clone3	(__NR_Linux + 435)
+#define __NR_close_range	(__NR_Linux + 436)
+#define __NR_openat2	(__NR_Linux + 437)
+#define __NR_pidfd_getfd	(__NR_Linux + 438)
+#define __NR_faccessat2	(__NR_Linux + 439)
+#define __NR_process_madvise	(__NR_Linux + 440)
+#define __NR_epoll_pwait2	(__NR_Linux + 441)
 
-#endif /* _ASM_UNISTD_N32_H */
+
+#endif /* _ASM_MIPS_UNISTD_N32_H */
diff --git a/linux-headers/asm-mips/unistd_n64.h b/linux-headers/asm-mips/unistd_n64.h
index 0996001802..683558a7f8 100644
--- a/linux-headers/asm-mips/unistd_n64.h
+++ b/linux-headers/asm-mips/unistd_n64.h
@@ -1,355 +1,352 @@
-#ifndef _ASM_UNISTD_N64_H
-#define _ASM_UNISTD_N64_H
+#ifndef _ASM_MIPS_UNISTD_N64_H
+#define _ASM_MIPS_UNISTD_N64_H
 
-#define __NR_read (__NR_Linux + 0)
-#define __NR_write (__NR_Linux + 1)
-#define __NR_open (__NR_Linux + 2)
-#define __NR_close (__NR_Linux + 3)
-#define __NR_stat (__NR_Linux + 4)
-#define __NR_fstat (__NR_Linux + 5)
-#define __NR_lstat (__NR_Linux + 6)
-#define __NR_poll (__NR_Linux + 7)
-#define __NR_lseek (__NR_Linux + 8)
-#define __NR_mmap (__NR_Linux + 9)
-#define __NR_mprotect (__NR_Linux + 10)
-#define __NR_munmap (__NR_Linux + 11)
-#define __NR_brk (__NR_Linux + 12)
-#define __NR_rt_sigaction (__NR_Linux + 13)
-#define __NR_rt_sigprocmask (__NR_Linux + 14)
-#define __NR_ioctl (__NR_Linux + 15)
-#define __NR_pread64 (__NR_Linux + 16)
-#define __NR_pwrite64 (__NR_Linux + 17)
-#define __NR_readv (__NR_Linux + 18)
-#define __NR_writev (__NR_Linux + 19)
-#define __NR_access (__NR_Linux + 20)
-#define __NR_pipe (__NR_Linux + 21)
-#define __NR__newselect (__NR_Linux + 22)
-#define __NR_sched_yield (__NR_Linux + 23)
-#define __NR_mremap (__NR_Linux + 24)
-#define __NR_msync (__NR_Linux + 25)
-#define __NR_mincore (__NR_Linux + 26)
-#define __NR_madvise (__NR_Linux + 27)
-#define __NR_shmget (__NR_Linux + 28)
-#define __NR_shmat (__NR_Linux + 29)
-#define __NR_shmctl (__NR_Linux + 30)
-#define __NR_dup (__NR_Linux + 31)
-#define __NR_dup2 (__NR_Linux + 32)
-#define __NR_pause (__NR_Linux + 33)
-#define __NR_nanosleep (__NR_Linux + 34)
-#define __NR_getitimer (__NR_Linux + 35)
-#define __NR_setitimer (__NR_Linux + 36)
-#define __NR_alarm (__NR_Linux + 37)
-#define __NR_getpid (__NR_Linux + 38)
-#define __NR_sendfile (__NR_Linux + 39)
-#define __NR_socket (__NR_Linux + 40)
-#define __NR_connect (__NR_Linux + 41)
-#define __NR_accept (__NR_Linux + 42)
-#define __NR_sendto (__NR_Linux + 43)
-#define __NR_recvfrom (__NR_Linux + 44)
-#define __NR_sendmsg (__NR_Linux + 45)
-#define __NR_recvmsg (__NR_Linux + 46)
-#define __NR_shutdown (__NR_Linux + 47)
-#define __NR_bind (__NR_Linux + 48)
-#define __NR_listen (__NR_Linux + 49)
-#define __NR_getsockname (__NR_Linux + 50)
-#define __NR_getpeername (__NR_Linux + 51)
-#define __NR_socketpair (__NR_Linux + 52)
-#define __NR_setsockopt (__NR_Linux + 53)
-#define __NR_getsockopt (__NR_Linux + 54)
-#define __NR_clone (__NR_Linux + 55)
-#define __NR_fork (__NR_Linux + 56)
-#define __NR_execve (__NR_Linux + 57)
-#define __NR_exit (__NR_Linux + 58)
-#define __NR_wait4 (__NR_Linux + 59)
-#define __NR_kill (__NR_Linux + 60)
-#define __NR_uname (__NR_Linux + 61)
-#define __NR_semget (__NR_Linux + 62)
-#define __NR_semop (__NR_Linux + 63)
-#define __NR_semctl (__NR_Linux + 64)
-#define __NR_shmdt (__NR_Linux + 65)
-#define __NR_msgget (__NR_Linux + 66)
-#define __NR_msgsnd (__NR_Linux + 67)
-#define __NR_msgrcv (__NR_Linux + 68)
-#define __NR_msgctl (__NR_Linux + 69)
-#define __NR_fcntl (__NR_Linux + 70)
-#define __NR_flock (__NR_Linux + 71)
-#define __NR_fsync (__NR_Linux + 72)
-#define __NR_fdatasync (__NR_Linux + 73)
-#define __NR_truncate (__NR_Linux + 74)
-#define __NR_ftruncate (__NR_Linux + 75)
-#define __NR_getdents (__NR_Linux + 76)
-#define __NR_getcwd (__NR_Linux + 77)
-#define __NR_chdir (__NR_Linux + 78)
-#define __NR_fchdir (__NR_Linux + 79)
-#define __NR_rename (__NR_Linux + 80)
-#define __NR_mkdir (__NR_Linux + 81)
-#define __NR_rmdir (__NR_Linux + 82)
-#define __NR_creat (__NR_Linux + 83)
-#define __NR_link (__NR_Linux + 84)
-#define __NR_unlink (__NR_Linux + 85)
-#define __NR_symlink (__NR_Linux + 86)
-#define __NR_readlink (__NR_Linux + 87)
-#define __NR_chmod (__NR_Linux + 88)
-#define __NR_fchmod (__NR_Linux + 89)
-#define __NR_chown (__NR_Linux + 90)
-#define __NR_fchown (__NR_Linux + 91)
-#define __NR_lchown (__NR_Linux + 92)
-#define __NR_umask (__NR_Linux + 93)
-#define __NR_gettimeofday (__NR_Linux + 94)
-#define __NR_getrlimit (__NR_Linux + 95)
-#define __NR_getrusage (__NR_Linux + 96)
-#define __NR_sysinfo (__NR_Linux + 97)
-#define __NR_times (__NR_Linux + 98)
-#define __NR_ptrace (__NR_Linux + 99)
-#define __NR_getuid (__NR_Linux + 100)
-#define __NR_syslog (__NR_Linux + 101)
-#define __NR_getgid (__NR_Linux + 102)
-#define __NR_setuid (__NR_Linux + 103)
-#define __NR_setgid (__NR_Linux + 104)
-#define __NR_geteuid (__NR_Linux + 105)
-#define __NR_getegid (__NR_Linux + 106)
-#define __NR_setpgid (__NR_Linux + 107)
-#define __NR_getppid (__NR_Linux + 108)
-#define __NR_getpgrp (__NR_Linux + 109)
-#define __NR_setsid (__NR_Linux + 110)
-#define __NR_setreuid (__NR_Linux + 111)
-#define __NR_setregid (__NR_Linux + 112)
-#define __NR_getgroups (__NR_Linux + 113)
-#define __NR_setgroups (__NR_Linux + 114)
-#define __NR_setresuid (__NR_Linux + 115)
-#define __NR_getresuid (__NR_Linux + 116)
-#define __NR_setresgid (__NR_Linux + 117)
-#define __NR_getresgid (__NR_Linux + 118)
-#define __NR_getpgid (__NR_Linux + 119)
-#define __NR_setfsuid (__NR_Linux + 120)
-#define __NR_setfsgid (__NR_Linux + 121)
-#define __NR_getsid (__NR_Linux + 122)
-#define __NR_capget (__NR_Linux + 123)
-#define __NR_capset (__NR_Linux + 124)
-#define __NR_rt_sigpending (__NR_Linux + 125)
-#define __NR_rt_sigtimedwait (__NR_Linux + 126)
-#define __NR_rt_sigqueueinfo (__NR_Linux + 127)
-#define __NR_rt_sigsuspend (__NR_Linux + 128)
-#define __NR_sigaltstack (__NR_Linux + 129)
-#define __NR_utime (__NR_Linux + 130)
-#define __NR_mknod (__NR_Linux + 131)
-#define __NR_personality (__NR_Linux + 132)
-#define __NR_ustat (__NR_Linux + 133)
-#define __NR_statfs (__NR_Linux + 134)
-#define __NR_fstatfs (__NR_Linux + 135)
-#define __NR_sysfs (__NR_Linux + 136)
-#define __NR_getpriority (__NR_Linux + 137)
-#define __NR_setpriority (__NR_Linux + 138)
-#define __NR_sched_setparam (__NR_Linux + 139)
-#define __NR_sched_getparam (__NR_Linux + 140)
-#define __NR_sched_setscheduler (__NR_Linux + 141)
-#define __NR_sched_getscheduler (__NR_Linux + 142)
-#define __NR_sched_get_priority_max (__NR_Linux + 143)
-#define __NR_sched_get_priority_min (__NR_Linux + 144)
-#define __NR_sched_rr_get_interval (__NR_Linux + 145)
-#define __NR_mlock (__NR_Linux + 146)
-#define __NR_munlock (__NR_Linux + 147)
-#define __NR_mlockall (__NR_Linux + 148)
-#define __NR_munlockall (__NR_Linux + 149)
-#define __NR_vhangup (__NR_Linux + 150)
-#define __NR_pivot_root (__NR_Linux + 151)
-#define __NR__sysctl (__NR_Linux + 152)
-#define __NR_prctl (__NR_Linux + 153)
-#define __NR_adjtimex (__NR_Linux + 154)
-#define __NR_setrlimit (__NR_Linux + 155)
-#define __NR_chroot (__NR_Linux + 156)
-#define __NR_sync (__NR_Linux + 157)
-#define __NR_acct (__NR_Linux + 158)
-#define __NR_settimeofday (__NR_Linux + 159)
-#define __NR_mount (__NR_Linux + 160)
-#define __NR_umount2 (__NR_Linux + 161)
-#define __NR_swapon (__NR_Linux + 162)
-#define __NR_swapoff (__NR_Linux + 163)
-#define __NR_reboot (__NR_Linux + 164)
-#define __NR_sethostname (__NR_Linux + 165)
-#define __NR_setdomainname (__NR_Linux + 166)
-#define __NR_create_module (__NR_Linux + 167)
-#define __NR_init_module (__NR_Linux + 168)
-#define __NR_delete_module (__NR_Linux + 169)
-#define __NR_get_kernel_syms (__NR_Linux + 170)
-#define __NR_query_module (__NR_Linux + 171)
-#define __NR_quotactl (__NR_Linux + 172)
-#define __NR_nfsservctl (__NR_Linux + 173)
-#define __NR_getpmsg (__NR_Linux + 174)
-#define __NR_putpmsg (__NR_Linux + 175)
-#define __NR_afs_syscall (__NR_Linux + 176)
-#define __NR_reserved177 (__NR_Linux + 177)
-#define __NR_gettid (__NR_Linux + 178)
-#define __NR_readahead (__NR_Linux + 179)
-#define __NR_setxattr (__NR_Linux + 180)
-#define __NR_lsetxattr (__NR_Linux + 181)
-#define __NR_fsetxattr (__NR_Linux + 182)
-#define __NR_getxattr (__NR_Linux + 183)
-#define __NR_lgetxattr (__NR_Linux + 184)
-#define __NR_fgetxattr (__NR_Linux + 185)
-#define __NR_listxattr (__NR_Linux + 186)
-#define __NR_llistxattr (__NR_Linux + 187)
-#define __NR_flistxattr (__NR_Linux + 188)
-#define __NR_removexattr (__NR_Linux + 189)
-#define __NR_lremovexattr (__NR_Linux + 190)
-#define __NR_fremovexattr (__NR_Linux + 191)
-#define __NR_tkill (__NR_Linux + 192)
-#define __NR_reserved193 (__NR_Linux + 193)
-#define __NR_futex (__NR_Linux + 194)
-#define __NR_sched_setaffinity (__NR_Linux + 195)
-#define __NR_sched_getaffinity (__NR_Linux + 196)
-#define __NR_cacheflush (__NR_Linux + 197)
-#define __NR_cachectl (__NR_Linux + 198)
-#define __NR_sysmips (__NR_Linux + 199)
-#define __NR_io_setup (__NR_Linux + 200)
-#define __NR_io_destroy (__NR_Linux + 201)
-#define __NR_io_getevents (__NR_Linux + 202)
-#define __NR_io_submit (__NR_Linux + 203)
-#define __NR_io_cancel (__NR_Linux + 204)
-#define __NR_exit_group (__NR_Linux + 205)
-#define __NR_lookup_dcookie (__NR_Linux + 206)
-#define __NR_epoll_create (__NR_Linux + 207)
-#define __NR_epoll_ctl (__NR_Linux + 208)
-#define __NR_epoll_wait (__NR_Linux + 209)
-#define __NR_remap_file_pages (__NR_Linux + 210)
-#define __NR_rt_sigreturn (__NR_Linux + 211)
-#define __NR_set_tid_address (__NR_Linux + 212)
-#define __NR_restart_syscall (__NR_Linux + 213)
-#define __NR_semtimedop (__NR_Linux + 214)
-#define __NR_fadvise64 (__NR_Linux + 215)
-#define __NR_timer_create (__NR_Linux + 216)
-#define __NR_timer_settime (__NR_Linux + 217)
-#define __NR_timer_gettime (__NR_Linux + 218)
-#define __NR_timer_getoverrun (__NR_Linux + 219)
-#define __NR_timer_delete (__NR_Linux + 220)
-#define __NR_clock_settime (__NR_Linux + 221)
-#define __NR_clock_gettime (__NR_Linux + 222)
-#define __NR_clock_getres (__NR_Linux + 223)
-#define __NR_clock_nanosleep (__NR_Linux + 224)
-#define __NR_tgkill (__NR_Linux + 225)
-#define __NR_utimes (__NR_Linux + 226)
-#define __NR_mbind (__NR_Linux + 227)
-#define __NR_get_mempolicy (__NR_Linux + 228)
-#define __NR_set_mempolicy (__NR_Linux + 229)
-#define __NR_mq_open (__NR_Linux + 230)
-#define __NR_mq_unlink (__NR_Linux + 231)
-#define __NR_mq_timedsend (__NR_Linux + 232)
-#define __NR_mq_timedreceive (__NR_Linux + 233)
-#define __NR_mq_notify (__NR_Linux + 234)
-#define __NR_mq_getsetattr (__NR_Linux + 235)
-#define __NR_vserver (__NR_Linux + 236)
-#define __NR_waitid (__NR_Linux + 237)
-#define __NR_add_key (__NR_Linux + 239)
-#define __NR_request_key (__NR_Linux + 240)
-#define __NR_keyctl (__NR_Linux + 241)
-#define __NR_set_thread_area (__NR_Linux + 242)
-#define __NR_inotify_init (__NR_Linux + 243)
-#define __NR_inotify_add_watch (__NR_Linux + 244)
-#define __NR_inotify_rm_watch (__NR_Linux + 245)
-#define __NR_migrate_pages (__NR_Linux + 246)
-#define __NR_openat (__NR_Linux + 247)
-#define __NR_mkdirat (__NR_Linux + 248)
-#define __NR_mknodat (__NR_Linux + 249)
-#define __NR_fchownat (__NR_Linux + 250)
-#define __NR_futimesat (__NR_Linux + 251)
-#define __NR_newfstatat (__NR_Linux + 252)
-#define __NR_unlinkat (__NR_Linux + 253)
-#define __NR_renameat (__NR_Linux + 254)
-#define __NR_linkat (__NR_Linux + 255)
-#define __NR_symlinkat (__NR_Linux + 256)
-#define __NR_readlinkat (__NR_Linux + 257)
-#define __NR_fchmodat (__NR_Linux + 258)
-#define __NR_faccessat (__NR_Linux + 259)
-#define __NR_pselect6 (__NR_Linux + 260)
-#define __NR_ppoll (__NR_Linux + 261)
-#define __NR_unshare (__NR_Linux + 262)
-#define __NR_splice (__NR_Linux + 263)
-#define __NR_sync_file_range (__NR_Linux + 264)
-#define __NR_tee (__NR_Linux + 265)
-#define __NR_vmsplice (__NR_Linux + 266)
-#define __NR_move_pages (__NR_Linux + 267)
-#define __NR_set_robust_list (__NR_Linux + 268)
-#define __NR_get_robust_list (__NR_Linux + 269)
-#define __NR_kexec_load (__NR_Linux + 270)
-#define __NR_getcpu (__NR_Linux + 271)
-#define __NR_epoll_pwait (__NR_Linux + 272)
-#define __NR_ioprio_set (__NR_Linux + 273)
-#define __NR_ioprio_get (__NR_Linux + 274)
-#define __NR_utimensat (__NR_Linux + 275)
-#define __NR_signalfd (__NR_Linux + 276)
-#define __NR_timerfd (__NR_Linux + 277)
-#define __NR_eventfd (__NR_Linux + 278)
-#define __NR_fallocate (__NR_Linux + 279)
-#define __NR_timerfd_create (__NR_Linux + 280)
-#define __NR_timerfd_gettime (__NR_Linux + 281)
-#define __NR_timerfd_settime (__NR_Linux + 282)
-#define __NR_signalfd4 (__NR_Linux + 283)
-#define __NR_eventfd2 (__NR_Linux + 284)
-#define __NR_epoll_create1 (__NR_Linux + 285)
-#define __NR_dup3 (__NR_Linux + 286)
-#define __NR_pipe2 (__NR_Linux + 287)
-#define __NR_inotify_init1 (__NR_Linux + 288)
-#define __NR_preadv (__NR_Linux + 289)
-#define __NR_pwritev (__NR_Linux + 290)
-#define __NR_rt_tgsigqueueinfo (__NR_Linux + 291)
-#define __NR_perf_event_open (__NR_Linux + 292)
-#define __NR_accept4 (__NR_Linux + 293)
-#define __NR_recvmmsg (__NR_Linux + 294)
-#define __NR_fanotify_init (__NR_Linux + 295)
-#define __NR_fanotify_mark (__NR_Linux + 296)
-#define __NR_prlimit64 (__NR_Linux + 297)
-#define __NR_name_to_handle_at (__NR_Linux + 298)
-#define __NR_open_by_handle_at (__NR_Linux + 299)
-#define __NR_clock_adjtime (__NR_Linux + 300)
-#define __NR_syncfs (__NR_Linux + 301)
-#define __NR_sendmmsg (__NR_Linux + 302)
-#define __NR_setns (__NR_Linux + 303)
-#define __NR_process_vm_readv (__NR_Linux + 304)
-#define __NR_process_vm_writev (__NR_Linux + 305)
-#define __NR_kcmp (__NR_Linux + 306)
-#define __NR_finit_module (__NR_Linux + 307)
-#define __NR_getdents64 (__NR_Linux + 308)
-#define __NR_sched_setattr (__NR_Linux + 309)
-#define __NR_sched_getattr (__NR_Linux + 310)
-#define __NR_renameat2 (__NR_Linux + 311)
-#define __NR_seccomp (__NR_Linux + 312)
-#define __NR_getrandom (__NR_Linux + 313)
-#define __NR_memfd_create (__NR_Linux + 314)
-#define __NR_bpf (__NR_Linux + 315)
-#define __NR_execveat (__NR_Linux + 316)
-#define __NR_userfaultfd (__NR_Linux + 317)
-#define __NR_membarrier (__NR_Linux + 318)
-#define __NR_mlock2 (__NR_Linux + 319)
-#define __NR_copy_file_range (__NR_Linux + 320)
-#define __NR_preadv2 (__NR_Linux + 321)
-#define __NR_pwritev2 (__NR_Linux + 322)
-#define __NR_pkey_mprotect (__NR_Linux + 323)
-#define __NR_pkey_alloc (__NR_Linux + 324)
-#define __NR_pkey_free (__NR_Linux + 325)
-#define __NR_statx (__NR_Linux + 326)
-#define __NR_rseq (__NR_Linux + 327)
-#define __NR_io_pgetevents (__NR_Linux + 328)
-#define __NR_pidfd_send_signal (__NR_Linux + 424)
-#define __NR_io_uring_setup (__NR_Linux + 425)
-#define __NR_io_uring_enter (__NR_Linux + 426)
-#define __NR_io_uring_register (__NR_Linux + 427)
-#define __NR_open_tree (__NR_Linux + 428)
-#define __NR_move_mount (__NR_Linux + 429)
-#define __NR_fsopen (__NR_Linux + 430)
-#define __NR_fsconfig (__NR_Linux + 431)
-#define __NR_fsmount (__NR_Linux + 432)
-#define __NR_fspick (__NR_Linux + 433)
-#define __NR_pidfd_open (__NR_Linux + 434)
-#define __NR_clone3 (__NR_Linux + 435)
-#define __NR_close_range (__NR_Linux + 436)
-#define __NR_openat2 (__NR_Linux + 437)
-#define __NR_pidfd_getfd (__NR_Linux + 438)
-#define __NR_faccessat2 (__NR_Linux + 439)
-#define __NR_process_madvise (__NR_Linux + 440)
-#define __NR_epoll_pwait2 (__NR_Linux + 441)
-#define __NR_mount_setattr (__NR_Linux + 442)
-#define __NR_landlock_create_ruleset (__NR_Linux + 444)
-#define __NR_landlock_add_rule (__NR_Linux + 445)
-#define __NR_landlock_restrict_self (__NR_Linux + 446)
+#define __NR_read	(__NR_Linux + 0)
+#define __NR_write	(__NR_Linux + 1)
+#define __NR_open	(__NR_Linux + 2)
+#define __NR_close	(__NR_Linux + 3)
+#define __NR_stat	(__NR_Linux + 4)
+#define __NR_fstat	(__NR_Linux + 5)
+#define __NR_lstat	(__NR_Linux + 6)
+#define __NR_poll	(__NR_Linux + 7)
+#define __NR_lseek	(__NR_Linux + 8)
+#define __NR_mmap	(__NR_Linux + 9)
+#define __NR_mprotect	(__NR_Linux + 10)
+#define __NR_munmap	(__NR_Linux + 11)
+#define __NR_brk	(__NR_Linux + 12)
+#define __NR_rt_sigaction	(__NR_Linux + 13)
+#define __NR_rt_sigprocmask	(__NR_Linux + 14)
+#define __NR_ioctl	(__NR_Linux + 15)
+#define __NR_pread64	(__NR_Linux + 16)
+#define __NR_pwrite64	(__NR_Linux + 17)
+#define __NR_readv	(__NR_Linux + 18)
+#define __NR_writev	(__NR_Linux + 19)
+#define __NR_access	(__NR_Linux + 20)
+#define __NR_pipe	(__NR_Linux + 21)
+#define __NR__newselect	(__NR_Linux + 22)
+#define __NR_sched_yield	(__NR_Linux + 23)
+#define __NR_mremap	(__NR_Linux + 24)
+#define __NR_msync	(__NR_Linux + 25)
+#define __NR_mincore	(__NR_Linux + 26)
+#define __NR_madvise	(__NR_Linux + 27)
+#define __NR_shmget	(__NR_Linux + 28)
+#define __NR_shmat	(__NR_Linux + 29)
+#define __NR_shmctl	(__NR_Linux + 30)
+#define __NR_dup	(__NR_Linux + 31)
+#define __NR_dup2	(__NR_Linux + 32)
+#define __NR_pause	(__NR_Linux + 33)
+#define __NR_nanosleep	(__NR_Linux + 34)
+#define __NR_getitimer	(__NR_Linux + 35)
+#define __NR_setitimer	(__NR_Linux + 36)
+#define __NR_alarm	(__NR_Linux + 37)
+#define __NR_getpid	(__NR_Linux + 38)
+#define __NR_sendfile	(__NR_Linux + 39)
+#define __NR_socket	(__NR_Linux + 40)
+#define __NR_connect	(__NR_Linux + 41)
+#define __NR_accept	(__NR_Linux + 42)
+#define __NR_sendto	(__NR_Linux + 43)
+#define __NR_recvfrom	(__NR_Linux + 44)
+#define __NR_sendmsg	(__NR_Linux + 45)
+#define __NR_recvmsg	(__NR_Linux + 46)
+#define __NR_shutdown	(__NR_Linux + 47)
+#define __NR_bind	(__NR_Linux + 48)
+#define __NR_listen	(__NR_Linux + 49)
+#define __NR_getsockname	(__NR_Linux + 50)
+#define __NR_getpeername	(__NR_Linux + 51)
+#define __NR_socketpair	(__NR_Linux + 52)
+#define __NR_setsockopt	(__NR_Linux + 53)
+#define __NR_getsockopt	(__NR_Linux + 54)
+#define __NR_clone	(__NR_Linux + 55)
+#define __NR_fork	(__NR_Linux + 56)
+#define __NR_execve	(__NR_Linux + 57)
+#define __NR_exit	(__NR_Linux + 58)
+#define __NR_wait4	(__NR_Linux + 59)
+#define __NR_kill	(__NR_Linux + 60)
+#define __NR_uname	(__NR_Linux + 61)
+#define __NR_semget	(__NR_Linux + 62)
+#define __NR_semop	(__NR_Linux + 63)
+#define __NR_semctl	(__NR_Linux + 64)
+#define __NR_shmdt	(__NR_Linux + 65)
+#define __NR_msgget	(__NR_Linux + 66)
+#define __NR_msgsnd	(__NR_Linux + 67)
+#define __NR_msgrcv	(__NR_Linux + 68)
+#define __NR_msgctl	(__NR_Linux + 69)
+#define __NR_fcntl	(__NR_Linux + 70)
+#define __NR_flock	(__NR_Linux + 71)
+#define __NR_fsync	(__NR_Linux + 72)
+#define __NR_fdatasync	(__NR_Linux + 73)
+#define __NR_truncate	(__NR_Linux + 74)
+#define __NR_ftruncate	(__NR_Linux + 75)
+#define __NR_getdents	(__NR_Linux + 76)
+#define __NR_getcwd	(__NR_Linux + 77)
+#define __NR_chdir	(__NR_Linux + 78)
+#define __NR_fchdir	(__NR_Linux + 79)
+#define __NR_rename	(__NR_Linux + 80)
+#define __NR_mkdir	(__NR_Linux + 81)
+#define __NR_rmdir	(__NR_Linux + 82)
+#define __NR_creat	(__NR_Linux + 83)
+#define __NR_link	(__NR_Linux + 84)
+#define __NR_unlink	(__NR_Linux + 85)
+#define __NR_symlink	(__NR_Linux + 86)
+#define __NR_readlink	(__NR_Linux + 87)
+#define __NR_chmod	(__NR_Linux + 88)
+#define __NR_fchmod	(__NR_Linux + 89)
+#define __NR_chown	(__NR_Linux + 90)
+#define __NR_fchown	(__NR_Linux + 91)
+#define __NR_lchown	(__NR_Linux + 92)
+#define __NR_umask	(__NR_Linux + 93)
+#define __NR_gettimeofday	(__NR_Linux + 94)
+#define __NR_getrlimit	(__NR_Linux + 95)
+#define __NR_getrusage	(__NR_Linux + 96)
+#define __NR_sysinfo	(__NR_Linux + 97)
+#define __NR_times	(__NR_Linux + 98)
+#define __NR_ptrace	(__NR_Linux + 99)
+#define __NR_getuid	(__NR_Linux + 100)
+#define __NR_syslog	(__NR_Linux + 101)
+#define __NR_getgid	(__NR_Linux + 102)
+#define __NR_setuid	(__NR_Linux + 103)
+#define __NR_setgid	(__NR_Linux + 104)
+#define __NR_geteuid	(__NR_Linux + 105)
+#define __NR_getegid	(__NR_Linux + 106)
+#define __NR_setpgid	(__NR_Linux + 107)
+#define __NR_getppid	(__NR_Linux + 108)
+#define __NR_getpgrp	(__NR_Linux + 109)
+#define __NR_setsid	(__NR_Linux + 110)
+#define __NR_setreuid	(__NR_Linux + 111)
+#define __NR_setregid	(__NR_Linux + 112)
+#define __NR_getgroups	(__NR_Linux + 113)
+#define __NR_setgroups	(__NR_Linux + 114)
+#define __NR_setresuid	(__NR_Linux + 115)
+#define __NR_getresuid	(__NR_Linux + 116)
+#define __NR_setresgid	(__NR_Linux + 117)
+#define __NR_getresgid	(__NR_Linux + 118)
+#define __NR_getpgid	(__NR_Linux + 119)
+#define __NR_setfsuid	(__NR_Linux + 120)
+#define __NR_setfsgid	(__NR_Linux + 121)
+#define __NR_getsid	(__NR_Linux + 122)
+#define __NR_capget	(__NR_Linux + 123)
+#define __NR_capset	(__NR_Linux + 124)
+#define __NR_rt_sigpending	(__NR_Linux + 125)
+#define __NR_rt_sigtimedwait	(__NR_Linux + 126)
+#define __NR_rt_sigqueueinfo	(__NR_Linux + 127)
+#define __NR_rt_sigsuspend	(__NR_Linux + 128)
+#define __NR_sigaltstack	(__NR_Linux + 129)
+#define __NR_utime	(__NR_Linux + 130)
+#define __NR_mknod	(__NR_Linux + 131)
+#define __NR_personality	(__NR_Linux + 132)
+#define __NR_ustat	(__NR_Linux + 133)
+#define __NR_statfs	(__NR_Linux + 134)
+#define __NR_fstatfs	(__NR_Linux + 135)
+#define __NR_sysfs	(__NR_Linux + 136)
+#define __NR_getpriority	(__NR_Linux + 137)
+#define __NR_setpriority	(__NR_Linux + 138)
+#define __NR_sched_setparam	(__NR_Linux + 139)
+#define __NR_sched_getparam	(__NR_Linux + 140)
+#define __NR_sched_setscheduler	(__NR_Linux + 141)
+#define __NR_sched_getscheduler	(__NR_Linux + 142)
+#define __NR_sched_get_priority_max	(__NR_Linux + 143)
+#define __NR_sched_get_priority_min	(__NR_Linux + 144)
+#define __NR_sched_rr_get_interval	(__NR_Linux + 145)
+#define __NR_mlock	(__NR_Linux + 146)
+#define __NR_munlock	(__NR_Linux + 147)
+#define __NR_mlockall	(__NR_Linux + 148)
+#define __NR_munlockall	(__NR_Linux + 149)
+#define __NR_vhangup	(__NR_Linux + 150)
+#define __NR_pivot_root	(__NR_Linux + 151)
+#define __NR__sysctl	(__NR_Linux + 152)
+#define __NR_prctl	(__NR_Linux + 153)
+#define __NR_adjtimex	(__NR_Linux + 154)
+#define __NR_setrlimit	(__NR_Linux + 155)
+#define __NR_chroot	(__NR_Linux + 156)
+#define __NR_sync	(__NR_Linux + 157)
+#define __NR_acct	(__NR_Linux + 158)
+#define __NR_settimeofday	(__NR_Linux + 159)
+#define __NR_mount	(__NR_Linux + 160)
+#define __NR_umount2	(__NR_Linux + 161)
+#define __NR_swapon	(__NR_Linux + 162)
+#define __NR_swapoff	(__NR_Linux + 163)
+#define __NR_reboot	(__NR_Linux + 164)
+#define __NR_sethostname	(__NR_Linux + 165)
+#define __NR_setdomainname	(__NR_Linux + 166)
+#define __NR_create_module	(__NR_Linux + 167)
+#define __NR_init_module	(__NR_Linux + 168)
+#define __NR_delete_module	(__NR_Linux + 169)
+#define __NR_get_kernel_syms	(__NR_Linux + 170)
+#define __NR_query_module	(__NR_Linux + 171)
+#define __NR_quotactl	(__NR_Linux + 172)
+#define __NR_nfsservctl	(__NR_Linux + 173)
+#define __NR_getpmsg	(__NR_Linux + 174)
+#define __NR_putpmsg	(__NR_Linux + 175)
+#define __NR_afs_syscall	(__NR_Linux + 176)
+#define __NR_reserved177	(__NR_Linux + 177)
+#define __NR_gettid	(__NR_Linux + 178)
+#define __NR_readahead	(__NR_Linux + 179)
+#define __NR_setxattr	(__NR_Linux + 180)
+#define __NR_lsetxattr	(__NR_Linux + 181)
+#define __NR_fsetxattr	(__NR_Linux + 182)
+#define __NR_getxattr	(__NR_Linux + 183)
+#define __NR_lgetxattr	(__NR_Linux + 184)
+#define __NR_fgetxattr	(__NR_Linux + 185)
+#define __NR_listxattr	(__NR_Linux + 186)
+#define __NR_llistxattr	(__NR_Linux + 187)
+#define __NR_flistxattr	(__NR_Linux + 188)
+#define __NR_removexattr	(__NR_Linux + 189)
+#define __NR_lremovexattr	(__NR_Linux + 190)
+#define __NR_fremovexattr	(__NR_Linux + 191)
+#define __NR_tkill	(__NR_Linux + 192)
+#define __NR_reserved193	(__NR_Linux + 193)
+#define __NR_futex	(__NR_Linux + 194)
+#define __NR_sched_setaffinity	(__NR_Linux + 195)
+#define __NR_sched_getaffinity	(__NR_Linux + 196)
+#define __NR_cacheflush	(__NR_Linux + 197)
+#define __NR_cachectl	(__NR_Linux + 198)
+#define __NR_sysmips	(__NR_Linux + 199)
+#define __NR_io_setup	(__NR_Linux + 200)
+#define __NR_io_destroy	(__NR_Linux + 201)
+#define __NR_io_getevents	(__NR_Linux + 202)
+#define __NR_io_submit	(__NR_Linux + 203)
+#define __NR_io_cancel	(__NR_Linux + 204)
+#define __NR_exit_group	(__NR_Linux + 205)
+#define __NR_lookup_dcookie	(__NR_Linux + 206)
+#define __NR_epoll_create	(__NR_Linux + 207)
+#define __NR_epoll_ctl	(__NR_Linux + 208)
+#define __NR_epoll_wait	(__NR_Linux + 209)
+#define __NR_remap_file_pages	(__NR_Linux + 210)
+#define __NR_rt_sigreturn	(__NR_Linux + 211)
+#define __NR_set_tid_address	(__NR_Linux + 212)
+#define __NR_restart_syscall	(__NR_Linux + 213)
+#define __NR_semtimedop	(__NR_Linux + 214)
+#define __NR_fadvise64	(__NR_Linux + 215)
+#define __NR_timer_create	(__NR_Linux + 216)
+#define __NR_timer_settime	(__NR_Linux + 217)
+#define __NR_timer_gettime	(__NR_Linux + 218)
+#define __NR_timer_getoverrun	(__NR_Linux + 219)
+#define __NR_timer_delete	(__NR_Linux + 220)
+#define __NR_clock_settime	(__NR_Linux + 221)
+#define __NR_clock_gettime	(__NR_Linux + 222)
+#define __NR_clock_getres	(__NR_Linux + 223)
+#define __NR_clock_nanosleep	(__NR_Linux + 224)
+#define __NR_tgkill	(__NR_Linux + 225)
+#define __NR_utimes	(__NR_Linux + 226)
+#define __NR_mbind	(__NR_Linux + 227)
+#define __NR_get_mempolicy	(__NR_Linux + 228)
+#define __NR_set_mempolicy	(__NR_Linux + 229)
+#define __NR_mq_open	(__NR_Linux + 230)
+#define __NR_mq_unlink	(__NR_Linux + 231)
+#define __NR_mq_timedsend	(__NR_Linux + 232)
+#define __NR_mq_timedreceive	(__NR_Linux + 233)
+#define __NR_mq_notify	(__NR_Linux + 234)
+#define __NR_mq_getsetattr	(__NR_Linux + 235)
+#define __NR_vserver	(__NR_Linux + 236)
+#define __NR_waitid	(__NR_Linux + 237)
+#define __NR_add_key	(__NR_Linux + 239)
+#define __NR_request_key	(__NR_Linux + 240)
+#define __NR_keyctl	(__NR_Linux + 241)
+#define __NR_set_thread_area	(__NR_Linux + 242)
+#define __NR_inotify_init	(__NR_Linux + 243)
+#define __NR_inotify_add_watch	(__NR_Linux + 244)
+#define __NR_inotify_rm_watch	(__NR_Linux + 245)
+#define __NR_migrate_pages	(__NR_Linux + 246)
+#define __NR_openat	(__NR_Linux + 247)
+#define __NR_mkdirat	(__NR_Linux + 248)
+#define __NR_mknodat	(__NR_Linux + 249)
+#define __NR_fchownat	(__NR_Linux + 250)
+#define __NR_futimesat	(__NR_Linux + 251)
+#define __NR_newfstatat	(__NR_Linux + 252)
+#define __NR_unlinkat	(__NR_Linux + 253)
+#define __NR_renameat	(__NR_Linux + 254)
+#define __NR_linkat	(__NR_Linux + 255)
+#define __NR_symlinkat	(__NR_Linux + 256)
+#define __NR_readlinkat	(__NR_Linux + 257)
+#define __NR_fchmodat	(__NR_Linux + 258)
+#define __NR_faccessat	(__NR_Linux + 259)
+#define __NR_pselect6	(__NR_Linux + 260)
+#define __NR_ppoll	(__NR_Linux + 261)
+#define __NR_unshare	(__NR_Linux + 262)
+#define __NR_splice	(__NR_Linux + 263)
+#define __NR_sync_file_range	(__NR_Linux + 264)
+#define __NR_tee	(__NR_Linux + 265)
+#define __NR_vmsplice	(__NR_Linux + 266)
+#define __NR_move_pages	(__NR_Linux + 267)
+#define __NR_set_robust_list	(__NR_Linux + 268)
+#define __NR_get_robust_list	(__NR_Linux + 269)
+#define __NR_kexec_load	(__NR_Linux + 270)
+#define __NR_getcpu	(__NR_Linux + 271)
+#define __NR_epoll_pwait	(__NR_Linux + 272)
+#define __NR_ioprio_set	(__NR_Linux + 273)
+#define __NR_ioprio_get	(__NR_Linux + 274)
+#define __NR_utimensat	(__NR_Linux + 275)
+#define __NR_signalfd	(__NR_Linux + 276)
+#define __NR_timerfd	(__NR_Linux + 277)
+#define __NR_eventfd	(__NR_Linux + 278)
+#define __NR_fallocate	(__NR_Linux + 279)
+#define __NR_timerfd_create	(__NR_Linux + 280)
+#define __NR_timerfd_gettime	(__NR_Linux + 281)
+#define __NR_timerfd_settime	(__NR_Linux + 282)
+#define __NR_signalfd4	(__NR_Linux + 283)
+#define __NR_eventfd2	(__NR_Linux + 284)
+#define __NR_epoll_create1	(__NR_Linux + 285)
+#define __NR_dup3	(__NR_Linux + 286)
+#define __NR_pipe2	(__NR_Linux + 287)
+#define __NR_inotify_init1	(__NR_Linux + 288)
+#define __NR_preadv	(__NR_Linux + 289)
+#define __NR_pwritev	(__NR_Linux + 290)
+#define __NR_rt_tgsigqueueinfo	(__NR_Linux + 291)
+#define __NR_perf_event_open	(__NR_Linux + 292)
+#define __NR_accept4	(__NR_Linux + 293)
+#define __NR_recvmmsg	(__NR_Linux + 294)
+#define __NR_fanotify_init	(__NR_Linux + 295)
+#define __NR_fanotify_mark	(__NR_Linux + 296)
+#define __NR_prlimit64	(__NR_Linux + 297)
+#define __NR_name_to_handle_at	(__NR_Linux + 298)
+#define __NR_open_by_handle_at	(__NR_Linux + 299)
+#define __NR_clock_adjtime	(__NR_Linux + 300)
+#define __NR_syncfs	(__NR_Linux + 301)
+#define __NR_sendmmsg	(__NR_Linux + 302)
+#define __NR_setns	(__NR_Linux + 303)
+#define __NR_process_vm_readv	(__NR_Linux + 304)
+#define __NR_process_vm_writev	(__NR_Linux + 305)
+#define __NR_kcmp	(__NR_Linux + 306)
+#define __NR_finit_module	(__NR_Linux + 307)
+#define __NR_getdents64	(__NR_Linux + 308)
+#define __NR_sched_setattr	(__NR_Linux + 309)
+#define __NR_sched_getattr	(__NR_Linux + 310)
+#define __NR_renameat2	(__NR_Linux + 311)
+#define __NR_seccomp	(__NR_Linux + 312)
+#define __NR_getrandom	(__NR_Linux + 313)
+#define __NR_memfd_create	(__NR_Linux + 314)
+#define __NR_bpf	(__NR_Linux + 315)
+#define __NR_execveat	(__NR_Linux + 316)
+#define __NR_userfaultfd	(__NR_Linux + 317)
+#define __NR_membarrier	(__NR_Linux + 318)
+#define __NR_mlock2	(__NR_Linux + 319)
+#define __NR_copy_file_range	(__NR_Linux + 320)
+#define __NR_preadv2	(__NR_Linux + 321)
+#define __NR_pwritev2	(__NR_Linux + 322)
+#define __NR_pkey_mprotect	(__NR_Linux + 323)
+#define __NR_pkey_alloc	(__NR_Linux + 324)
+#define __NR_pkey_free	(__NR_Linux + 325)
+#define __NR_statx	(__NR_Linux + 326)
+#define __NR_rseq	(__NR_Linux + 327)
+#define __NR_io_pgetevents	(__NR_Linux + 328)
+#define __NR_pidfd_send_signal	(__NR_Linux + 424)
+#define __NR_io_uring_setup	(__NR_Linux + 425)
+#define __NR_io_uring_enter	(__NR_Linux + 426)
+#define __NR_io_uring_register	(__NR_Linux + 427)
+#define __NR_open_tree	(__NR_Linux + 428)
+#define __NR_move_mount	(__NR_Linux + 429)
+#define __NR_fsopen	(__NR_Linux + 430)
+#define __NR_fsconfig	(__NR_Linux + 431)
+#define __NR_fsmount	(__NR_Linux + 432)
+#define __NR_fspick	(__NR_Linux + 433)
+#define __NR_pidfd_open	(__NR_Linux + 434)
+#define __NR_clone3	(__NR_Linux + 435)
+#define __NR_close_range	(__NR_Linux + 436)
+#define __NR_openat2	(__NR_Linux + 437)
+#define __NR_pidfd_getfd	(__NR_Linux + 438)
+#define __NR_faccessat2	(__NR_Linux + 439)
+#define __NR_process_madvise	(__NR_Linux + 440)
+#define __NR_epoll_pwait2	(__NR_Linux + 441)
 
-#endif /* _ASM_UNISTD_N64_H */
+
+#endif /* _ASM_MIPS_UNISTD_N64_H */
diff --git a/linux-headers/asm-mips/unistd_o32.h b/linux-headers/asm-mips/unistd_o32.h
index 954303ad69..ca6a7e5c0b 100644
--- a/linux-headers/asm-mips/unistd_o32.h
+++ b/linux-headers/asm-mips/unistd_o32.h
@@ -1,425 +1,422 @@
-#ifndef _ASM_UNISTD_O32_H
-#define _ASM_UNISTD_O32_H
+#ifndef _ASM_MIPS_UNISTD_O32_H
+#define _ASM_MIPS_UNISTD_O32_H
 
-#define __NR_syscall (__NR_Linux + 0)
-#define __NR_exit (__NR_Linux + 1)
-#define __NR_fork (__NR_Linux + 2)
-#define __NR_read (__NR_Linux + 3)
-#define __NR_write (__NR_Linux + 4)
-#define __NR_open (__NR_Linux + 5)
-#define __NR_close (__NR_Linux + 6)
-#define __NR_waitpid (__NR_Linux + 7)
-#define __NR_creat (__NR_Linux + 8)
-#define __NR_link (__NR_Linux + 9)
-#define __NR_unlink (__NR_Linux + 10)
-#define __NR_execve (__NR_Linux + 11)
-#define __NR_chdir (__NR_Linux + 12)
-#define __NR_time (__NR_Linux + 13)
-#define __NR_mknod (__NR_Linux + 14)
-#define __NR_chmod (__NR_Linux + 15)
-#define __NR_lchown (__NR_Linux + 16)
-#define __NR_break (__NR_Linux + 17)
-#define __NR_unused18 (__NR_Linux + 18)
-#define __NR_lseek (__NR_Linux + 19)
-#define __NR_getpid (__NR_Linux + 20)
-#define __NR_mount (__NR_Linux + 21)
-#define __NR_umount (__NR_Linux + 22)
-#define __NR_setuid (__NR_Linux + 23)
-#define __NR_getuid (__NR_Linux + 24)
-#define __NR_stime (__NR_Linux + 25)
-#define __NR_ptrace (__NR_Linux + 26)
-#define __NR_alarm (__NR_Linux + 27)
-#define __NR_unused28 (__NR_Linux + 28)
-#define __NR_pause (__NR_Linux + 29)
-#define __NR_utime (__NR_Linux + 30)
-#define __NR_stty (__NR_Linux + 31)
-#define __NR_gtty (__NR_Linux + 32)
-#define __NR_access (__NR_Linux + 33)
-#define __NR_nice (__NR_Linux + 34)
-#define __NR_ftime (__NR_Linux + 35)
-#define __NR_sync (__NR_Linux + 36)
-#define __NR_kill (__NR_Linux + 37)
-#define __NR_rename (__NR_Linux + 38)
-#define __NR_mkdir (__NR_Linux + 39)
-#define __NR_rmdir (__NR_Linux + 40)
-#define __NR_dup (__NR_Linux + 41)
-#define __NR_pipe (__NR_Linux + 42)
-#define __NR_times (__NR_Linux + 43)
-#define __NR_prof (__NR_Linux + 44)
-#define __NR_brk (__NR_Linux + 45)
-#define __NR_setgid (__NR_Linux + 46)
-#define __NR_getgid (__NR_Linux + 47)
-#define __NR_signal (__NR_Linux + 48)
-#define __NR_geteuid (__NR_Linux + 49)
-#define __NR_getegid (__NR_Linux + 50)
-#define __NR_acct (__NR_Linux + 51)
-#define __NR_umount2 (__NR_Linux + 52)
-#define __NR_lock (__NR_Linux + 53)
-#define __NR_ioctl (__NR_Linux + 54)
-#define __NR_fcntl (__NR_Linux + 55)
-#define __NR_mpx (__NR_Linux + 56)
-#define __NR_setpgid (__NR_Linux + 57)
-#define __NR_ulimit (__NR_Linux + 58)
-#define __NR_unused59 (__NR_Linux + 59)
-#define __NR_umask (__NR_Linux + 60)
-#define __NR_chroot (__NR_Linux + 61)
-#define __NR_ustat (__NR_Linux + 62)
-#define __NR_dup2 (__NR_Linux + 63)
-#define __NR_getppid (__NR_Linux + 64)
-#define __NR_getpgrp (__NR_Linux + 65)
-#define __NR_setsid (__NR_Linux + 66)
-#define __NR_sigaction (__NR_Linux + 67)
-#define __NR_sgetmask (__NR_Linux + 68)
-#define __NR_ssetmask (__NR_Linux + 69)
-#define __NR_setreuid (__NR_Linux + 70)
-#define __NR_setregid (__NR_Linux + 71)
-#define __NR_sigsuspend (__NR_Linux + 72)
-#define __NR_sigpending (__NR_Linux + 73)
-#define __NR_sethostname (__NR_Linux + 74)
-#define __NR_setrlimit (__NR_Linux + 75)
-#define __NR_getrlimit (__NR_Linux + 76)
-#define __NR_getrusage (__NR_Linux + 77)
-#define __NR_gettimeofday (__NR_Linux + 78)
-#define __NR_settimeofday (__NR_Linux + 79)
-#define __NR_getgroups (__NR_Linux + 80)
-#define __NR_setgroups (__NR_Linux + 81)
-#define __NR_reserved82 (__NR_Linux + 82)
-#define __NR_symlink (__NR_Linux + 83)
-#define __NR_unused84 (__NR_Linux + 84)
-#define __NR_readlink (__NR_Linux + 85)
-#define __NR_uselib (__NR_Linux + 86)
-#define __NR_swapon (__NR_Linux + 87)
-#define __NR_reboot (__NR_Linux + 88)
-#define __NR_readdir (__NR_Linux + 89)
-#define __NR_mmap (__NR_Linux + 90)
-#define __NR_munmap (__NR_Linux + 91)
-#define __NR_truncate (__NR_Linux + 92)
-#define __NR_ftruncate (__NR_Linux + 93)
-#define __NR_fchmod (__NR_Linux + 94)
-#define __NR_fchown (__NR_Linux + 95)
-#define __NR_getpriority (__NR_Linux + 96)
-#define __NR_setpriority (__NR_Linux + 97)
-#define __NR_profil (__NR_Linux + 98)
-#define __NR_statfs (__NR_Linux + 99)
-#define __NR_fstatfs (__NR_Linux + 100)
-#define __NR_ioperm (__NR_Linux + 101)
-#define __NR_socketcall (__NR_Linux + 102)
-#define __NR_syslog (__NR_Linux + 103)
-#define __NR_setitimer (__NR_Linux + 104)
-#define __NR_getitimer (__NR_Linux + 105)
-#define __NR_stat (__NR_Linux + 106)
-#define __NR_lstat (__NR_Linux + 107)
-#define __NR_fstat (__NR_Linux + 108)
-#define __NR_unused109 (__NR_Linux + 109)
-#define __NR_iopl (__NR_Linux + 110)
-#define __NR_vhangup (__NR_Linux + 111)
-#define __NR_idle (__NR_Linux + 112)
-#define __NR_vm86 (__NR_Linux + 113)
-#define __NR_wait4 (__NR_Linux + 114)
-#define __NR_swapoff (__NR_Linux + 115)
-#define __NR_sysinfo (__NR_Linux + 116)
-#define __NR_ipc (__NR_Linux + 117)
-#define __NR_fsync (__NR_Linux + 118)
-#define __NR_sigreturn (__NR_Linux + 119)
-#define __NR_clone (__NR_Linux + 120)
-#define __NR_setdomainname (__NR_Linux + 121)
-#define __NR_uname (__NR_Linux + 122)
-#define __NR_modify_ldt (__NR_Linux + 123)
-#define __NR_adjtimex (__NR_Linux + 124)
-#define __NR_mprotect (__NR_Linux + 125)
-#define __NR_sigprocmask (__NR_Linux + 126)
-#define __NR_create_module (__NR_Linux + 127)
-#define __NR_init_module (__NR_Linux + 128)
-#define __NR_delete_module (__NR_Linux + 129)
-#define __NR_get_kernel_syms (__NR_Linux + 130)
-#define __NR_quotactl (__NR_Linux + 131)
-#define __NR_getpgid (__NR_Linux + 132)
-#define __NR_fchdir (__NR_Linux + 133)
-#define __NR_bdflush (__NR_Linux + 134)
-#define __NR_sysfs (__NR_Linux + 135)
-#define __NR_personality (__NR_Linux + 136)
-#define __NR_afs_syscall (__NR_Linux + 137)
-#define __NR_setfsuid (__NR_Linux + 138)
-#define __NR_setfsgid (__NR_Linux + 139)
-#define __NR__llseek (__NR_Linux + 140)
-#define __NR_getdents (__NR_Linux + 141)
-#define __NR__newselect (__NR_Linux + 142)
-#define __NR_flock (__NR_Linux + 143)
-#define __NR_msync (__NR_Linux + 144)
-#define __NR_readv (__NR_Linux + 145)
-#define __NR_writev (__NR_Linux + 146)
-#define __NR_cacheflush (__NR_Linux + 147)
-#define __NR_cachectl (__NR_Linux + 148)
-#define __NR_sysmips (__NR_Linux + 149)
-#define __NR_unused150 (__NR_Linux + 150)
-#define __NR_getsid (__NR_Linux + 151)
-#define __NR_fdatasync (__NR_Linux + 152)
-#define __NR__sysctl (__NR_Linux + 153)
-#define __NR_mlock (__NR_Linux + 154)
-#define __NR_munlock (__NR_Linux + 155)
-#define __NR_mlockall (__NR_Linux + 156)
-#define __NR_munlockall (__NR_Linux + 157)
-#define __NR_sched_setparam (__NR_Linux + 158)
-#define __NR_sched_getparam (__NR_Linux + 159)
-#define __NR_sched_setscheduler (__NR_Linux + 160)
-#define __NR_sched_getscheduler (__NR_Linux + 161)
-#define __NR_sched_yield (__NR_Linux + 162)
-#define __NR_sched_get_priority_max (__NR_Linux + 163)
-#define __NR_sched_get_priority_min (__NR_Linux + 164)
-#define __NR_sched_rr_get_interval (__NR_Linux + 165)
-#define __NR_nanosleep (__NR_Linux + 166)
-#define __NR_mremap (__NR_Linux + 167)
-#define __NR_accept (__NR_Linux + 168)
-#define __NR_bind (__NR_Linux + 169)
-#define __NR_connect (__NR_Linux + 170)
-#define __NR_getpeername (__NR_Linux + 171)
-#define __NR_getsockname (__NR_Linux + 172)
-#define __NR_getsockopt (__NR_Linux + 173)
-#define __NR_listen (__NR_Linux + 174)
-#define __NR_recv (__NR_Linux + 175)
-#define __NR_recvfrom (__NR_Linux + 176)
-#define __NR_recvmsg (__NR_Linux + 177)
-#define __NR_send (__NR_Linux + 178)
-#define __NR_sendmsg (__NR_Linux + 179)
-#define __NR_sendto (__NR_Linux + 180)
-#define __NR_setsockopt (__NR_Linux + 181)
-#define __NR_shutdown (__NR_Linux + 182)
-#define __NR_socket (__NR_Linux + 183)
-#define __NR_socketpair (__NR_Linux + 184)
-#define __NR_setresuid (__NR_Linux + 185)
-#define __NR_getresuid (__NR_Linux + 186)
-#define __NR_query_module (__NR_Linux + 187)
-#define __NR_poll (__NR_Linux + 188)
-#define __NR_nfsservctl (__NR_Linux + 189)
-#define __NR_setresgid (__NR_Linux + 190)
-#define __NR_getresgid (__NR_Linux + 191)
-#define __NR_prctl (__NR_Linux + 192)
-#define __NR_rt_sigreturn (__NR_Linux + 193)
-#define __NR_rt_sigaction (__NR_Linux + 194)
-#define __NR_rt_sigprocmask (__NR_Linux + 195)
-#define __NR_rt_sigpending (__NR_Linux + 196)
-#define __NR_rt_sigtimedwait (__NR_Linux + 197)
-#define __NR_rt_sigqueueinfo (__NR_Linux + 198)
-#define __NR_rt_sigsuspend (__NR_Linux + 199)
-#define __NR_pread64 (__NR_Linux + 200)
-#define __NR_pwrite64 (__NR_Linux + 201)
-#define __NR_chown (__NR_Linux + 202)
-#define __NR_getcwd (__NR_Linux + 203)
-#define __NR_capget (__NR_Linux + 204)
-#define __NR_capset (__NR_Linux + 205)
-#define __NR_sigaltstack (__NR_Linux + 206)
-#define __NR_sendfile (__NR_Linux + 207)
-#define __NR_getpmsg (__NR_Linux + 208)
-#define __NR_putpmsg (__NR_Linux + 209)
-#define __NR_mmap2 (__NR_Linux + 210)
-#define __NR_truncate64 (__NR_Linux + 211)
-#define __NR_ftruncate64 (__NR_Linux + 212)
-#define __NR_stat64 (__NR_Linux + 213)
-#define __NR_lstat64 (__NR_Linux + 214)
-#define __NR_fstat64 (__NR_Linux + 215)
-#define __NR_pivot_root (__NR_Linux + 216)
-#define __NR_mincore (__NR_Linux + 217)
-#define __NR_madvise (__NR_Linux + 218)
-#define __NR_getdents64 (__NR_Linux + 219)
-#define __NR_fcntl64 (__NR_Linux + 220)
-#define __NR_reserved221 (__NR_Linux + 221)
-#define __NR_gettid (__NR_Linux + 222)
-#define __NR_readahead (__NR_Linux + 223)
-#define __NR_setxattr (__NR_Linux + 224)
-#define __NR_lsetxattr (__NR_Linux + 225)
-#define __NR_fsetxattr (__NR_Linux + 226)
-#define __NR_getxattr (__NR_Linux + 227)
-#define __NR_lgetxattr (__NR_Linux + 228)
-#define __NR_fgetxattr (__NR_Linux + 229)
-#define __NR_listxattr (__NR_Linux + 230)
-#define __NR_llistxattr (__NR_Linux + 231)
-#define __NR_flistxattr (__NR_Linux + 232)
-#define __NR_removexattr (__NR_Linux + 233)
-#define __NR_lremovexattr (__NR_Linux + 234)
-#define __NR_fremovexattr (__NR_Linux + 235)
-#define __NR_tkill (__NR_Linux + 236)
-#define __NR_sendfile64 (__NR_Linux + 237)
-#define __NR_futex (__NR_Linux + 238)
-#define __NR_sched_setaffinity (__NR_Linux + 239)
-#define __NR_sched_getaffinity (__NR_Linux + 240)
-#define __NR_io_setup (__NR_Linux + 241)
-#define __NR_io_destroy (__NR_Linux + 242)
-#define __NR_io_getevents (__NR_Linux + 243)
-#define __NR_io_submit (__NR_Linux + 244)
-#define __NR_io_cancel (__NR_Linux + 245)
-#define __NR_exit_group (__NR_Linux + 246)
-#define __NR_lookup_dcookie (__NR_Linux + 247)
-#define __NR_epoll_create (__NR_Linux + 248)
-#define __NR_epoll_ctl (__NR_Linux + 249)
-#define __NR_epoll_wait (__NR_Linux + 250)
-#define __NR_remap_file_pages (__NR_Linux + 251)
-#define __NR_set_tid_address (__NR_Linux + 252)
-#define __NR_restart_syscall (__NR_Linux + 253)
-#define __NR_fadvise64 (__NR_Linux + 254)
-#define __NR_statfs64 (__NR_Linux + 255)
-#define __NR_fstatfs64 (__NR_Linux + 256)
-#define __NR_timer_create (__NR_Linux + 257)
-#define __NR_timer_settime (__NR_Linux + 258)
-#define __NR_timer_gettime (__NR_Linux + 259)
-#define __NR_timer_getoverrun (__NR_Linux + 260)
-#define __NR_timer_delete (__NR_Linux + 261)
-#define __NR_clock_settime (__NR_Linux + 262)
-#define __NR_clock_gettime (__NR_Linux + 263)
-#define __NR_clock_getres (__NR_Linux + 264)
-#define __NR_clock_nanosleep (__NR_Linux + 265)
-#define __NR_tgkill (__NR_Linux + 266)
-#define __NR_utimes (__NR_Linux + 267)
-#define __NR_mbind (__NR_Linux + 268)
-#define __NR_get_mempolicy (__NR_Linux + 269)
-#define __NR_set_mempolicy (__NR_Linux + 270)
-#define __NR_mq_open (__NR_Linux + 271)
-#define __NR_mq_unlink (__NR_Linux + 272)
-#define __NR_mq_timedsend (__NR_Linux + 273)
-#define __NR_mq_timedreceive (__NR_Linux + 274)
-#define __NR_mq_notify (__NR_Linux + 275)
-#define __NR_mq_getsetattr (__NR_Linux + 276)
-#define __NR_vserver (__NR_Linux + 277)
-#define __NR_waitid (__NR_Linux + 278)
-#define __NR_add_key (__NR_Linux + 280)
-#define __NR_request_key (__NR_Linux + 281)
-#define __NR_keyctl (__NR_Linux + 282)
-#define __NR_set_thread_area (__NR_Linux + 283)
-#define __NR_inotify_init (__NR_Linux + 284)
-#define __NR_inotify_add_watch (__NR_Linux + 285)
-#define __NR_inotify_rm_watch (__NR_Linux + 286)
-#define __NR_migrate_pages (__NR_Linux + 287)
-#define __NR_openat (__NR_Linux + 288)
-#define __NR_mkdirat (__NR_Linux + 289)
-#define __NR_mknodat (__NR_Linux + 290)
-#define __NR_fchownat (__NR_Linux + 291)
-#define __NR_futimesat (__NR_Linux + 292)
-#define __NR_fstatat64 (__NR_Linux + 293)
-#define __NR_unlinkat (__NR_Linux + 294)
-#define __NR_renameat (__NR_Linux + 295)
-#define __NR_linkat (__NR_Linux + 296)
-#define __NR_symlinkat (__NR_Linux + 297)
-#define __NR_readlinkat (__NR_Linux + 298)
-#define __NR_fchmodat (__NR_Linux + 299)
-#define __NR_faccessat (__NR_Linux + 300)
-#define __NR_pselect6 (__NR_Linux + 301)
-#define __NR_ppoll (__NR_Linux + 302)
-#define __NR_unshare (__NR_Linux + 303)
-#define __NR_splice (__NR_Linux + 304)
-#define __NR_sync_file_range (__NR_Linux + 305)
-#define __NR_tee (__NR_Linux + 306)
-#define __NR_vmsplice (__NR_Linux + 307)
-#define __NR_move_pages (__NR_Linux + 308)
-#define __NR_set_robust_list (__NR_Linux + 309)
-#define __NR_get_robust_list (__NR_Linux + 310)
-#define __NR_kexec_load (__NR_Linux + 311)
-#define __NR_getcpu (__NR_Linux + 312)
-#define __NR_epoll_pwait (__NR_Linux + 313)
-#define __NR_ioprio_set (__NR_Linux + 314)
-#define __NR_ioprio_get (__NR_Linux + 315)
-#define __NR_utimensat (__NR_Linux + 316)
-#define __NR_signalfd (__NR_Linux + 317)
-#define __NR_timerfd (__NR_Linux + 318)
-#define __NR_eventfd (__NR_Linux + 319)
-#define __NR_fallocate (__NR_Linux + 320)
-#define __NR_timerfd_create (__NR_Linux + 321)
-#define __NR_timerfd_gettime (__NR_Linux + 322)
-#define __NR_timerfd_settime (__NR_Linux + 323)
-#define __NR_signalfd4 (__NR_Linux + 324)
-#define __NR_eventfd2 (__NR_Linux + 325)
-#define __NR_epoll_create1 (__NR_Linux + 326)
-#define __NR_dup3 (__NR_Linux + 327)
-#define __NR_pipe2 (__NR_Linux + 328)
-#define __NR_inotify_init1 (__NR_Linux + 329)
-#define __NR_preadv (__NR_Linux + 330)
-#define __NR_pwritev (__NR_Linux + 331)
-#define __NR_rt_tgsigqueueinfo (__NR_Linux + 332)
-#define __NR_perf_event_open (__NR_Linux + 333)
-#define __NR_accept4 (__NR_Linux + 334)
-#define __NR_recvmmsg (__NR_Linux + 335)
-#define __NR_fanotify_init (__NR_Linux + 336)
-#define __NR_fanotify_mark (__NR_Linux + 337)
-#define __NR_prlimit64 (__NR_Linux + 338)
-#define __NR_name_to_handle_at (__NR_Linux + 339)
-#define __NR_open_by_handle_at (__NR_Linux + 340)
-#define __NR_clock_adjtime (__NR_Linux + 341)
-#define __NR_syncfs (__NR_Linux + 342)
-#define __NR_sendmmsg (__NR_Linux + 343)
-#define __NR_setns (__NR_Linux + 344)
-#define __NR_process_vm_readv (__NR_Linux + 345)
-#define __NR_process_vm_writev (__NR_Linux + 346)
-#define __NR_kcmp (__NR_Linux + 347)
-#define __NR_finit_module (__NR_Linux + 348)
-#define __NR_sched_setattr (__NR_Linux + 349)
-#define __NR_sched_getattr (__NR_Linux + 350)
-#define __NR_renameat2 (__NR_Linux + 351)
-#define __NR_seccomp (__NR_Linux + 352)
-#define __NR_getrandom (__NR_Linux + 353)
-#define __NR_memfd_create (__NR_Linux + 354)
-#define __NR_bpf (__NR_Linux + 355)
-#define __NR_execveat (__NR_Linux + 356)
-#define __NR_userfaultfd (__NR_Linux + 357)
-#define __NR_membarrier (__NR_Linux + 358)
-#define __NR_mlock2 (__NR_Linux + 359)
-#define __NR_copy_file_range (__NR_Linux + 360)
-#define __NR_preadv2 (__NR_Linux + 361)
-#define __NR_pwritev2 (__NR_Linux + 362)
-#define __NR_pkey_mprotect (__NR_Linux + 363)
-#define __NR_pkey_alloc (__NR_Linux + 364)
-#define __NR_pkey_free (__NR_Linux + 365)
-#define __NR_statx (__NR_Linux + 366)
-#define __NR_rseq (__NR_Linux + 367)
-#define __NR_io_pgetevents (__NR_Linux + 368)
-#define __NR_semget (__NR_Linux + 393)
-#define __NR_semctl (__NR_Linux + 394)
-#define __NR_shmget (__NR_Linux + 395)
-#define __NR_shmctl (__NR_Linux + 396)
-#define __NR_shmat (__NR_Linux + 397)
-#define __NR_shmdt (__NR_Linux + 398)
-#define __NR_msgget (__NR_Linux + 399)
-#define __NR_msgsnd (__NR_Linux + 400)
-#define __NR_msgrcv (__NR_Linux + 401)
-#define __NR_msgctl (__NR_Linux + 402)
-#define __NR_clock_gettime64 (__NR_Linux + 403)
-#define __NR_clock_settime64 (__NR_Linux + 404)
-#define __NR_clock_adjtime64 (__NR_Linux + 405)
-#define __NR_clock_getres_time64 (__NR_Linux + 406)
-#define __NR_clock_nanosleep_time64 (__NR_Linux + 407)
-#define __NR_timer_gettime64 (__NR_Linux + 408)
-#define __NR_timer_settime64 (__NR_Linux + 409)
-#define __NR_timerfd_gettime64 (__NR_Linux + 410)
-#define __NR_timerfd_settime64 (__NR_Linux + 411)
-#define __NR_utimensat_time64 (__NR_Linux + 412)
-#define __NR_pselect6_time64 (__NR_Linux + 413)
-#define __NR_ppoll_time64 (__NR_Linux + 414)
-#define __NR_io_pgetevents_time64 (__NR_Linux + 416)
-#define __NR_recvmmsg_time64 (__NR_Linux + 417)
-#define __NR_mq_timedsend_time64 (__NR_Linux + 418)
-#define __NR_mq_timedreceive_time64 (__NR_Linux + 419)
-#define __NR_semtimedop_time64 (__NR_Linux + 420)
-#define __NR_rt_sigtimedwait_time64 (__NR_Linux + 421)
-#define __NR_futex_time64 (__NR_Linux + 422)
-#define __NR_sched_rr_get_interval_time64 (__NR_Linux + 423)
-#define __NR_pidfd_send_signal (__NR_Linux + 424)
-#define __NR_io_uring_setup (__NR_Linux + 425)
-#define __NR_io_uring_enter (__NR_Linux + 426)
-#define __NR_io_uring_register (__NR_Linux + 427)
-#define __NR_open_tree (__NR_Linux + 428)
-#define __NR_move_mount (__NR_Linux + 429)
-#define __NR_fsopen (__NR_Linux + 430)
-#define __NR_fsconfig (__NR_Linux + 431)
-#define __NR_fsmount (__NR_Linux + 432)
-#define __NR_fspick (__NR_Linux + 433)
-#define __NR_pidfd_open (__NR_Linux + 434)
-#define __NR_clone3 (__NR_Linux + 435)
-#define __NR_close_range (__NR_Linux + 436)
-#define __NR_openat2 (__NR_Linux + 437)
-#define __NR_pidfd_getfd (__NR_Linux + 438)
-#define __NR_faccessat2 (__NR_Linux + 439)
-#define __NR_process_madvise (__NR_Linux + 440)
-#define __NR_epoll_pwait2 (__NR_Linux + 441)
-#define __NR_mount_setattr (__NR_Linux + 442)
-#define __NR_landlock_create_ruleset (__NR_Linux + 444)
-#define __NR_landlock_add_rule (__NR_Linux + 445)
-#define __NR_landlock_restrict_self (__NR_Linux + 446)
+#define __NR_syscall	(__NR_Linux + 0)
+#define __NR_exit	(__NR_Linux + 1)
+#define __NR_fork	(__NR_Linux + 2)
+#define __NR_read	(__NR_Linux + 3)
+#define __NR_write	(__NR_Linux + 4)
+#define __NR_open	(__NR_Linux + 5)
+#define __NR_close	(__NR_Linux + 6)
+#define __NR_waitpid	(__NR_Linux + 7)
+#define __NR_creat	(__NR_Linux + 8)
+#define __NR_link	(__NR_Linux + 9)
+#define __NR_unlink	(__NR_Linux + 10)
+#define __NR_execve	(__NR_Linux + 11)
+#define __NR_chdir	(__NR_Linux + 12)
+#define __NR_time	(__NR_Linux + 13)
+#define __NR_mknod	(__NR_Linux + 14)
+#define __NR_chmod	(__NR_Linux + 15)
+#define __NR_lchown	(__NR_Linux + 16)
+#define __NR_break	(__NR_Linux + 17)
+#define __NR_unused18	(__NR_Linux + 18)
+#define __NR_lseek	(__NR_Linux + 19)
+#define __NR_getpid	(__NR_Linux + 20)
+#define __NR_mount	(__NR_Linux + 21)
+#define __NR_umount	(__NR_Linux + 22)
+#define __NR_setuid	(__NR_Linux + 23)
+#define __NR_getuid	(__NR_Linux + 24)
+#define __NR_stime	(__NR_Linux + 25)
+#define __NR_ptrace	(__NR_Linux + 26)
+#define __NR_alarm	(__NR_Linux + 27)
+#define __NR_unused28	(__NR_Linux + 28)
+#define __NR_pause	(__NR_Linux + 29)
+#define __NR_utime	(__NR_Linux + 30)
+#define __NR_stty	(__NR_Linux + 31)
+#define __NR_gtty	(__NR_Linux + 32)
+#define __NR_access	(__NR_Linux + 33)
+#define __NR_nice	(__NR_Linux + 34)
+#define __NR_ftime	(__NR_Linux + 35)
+#define __NR_sync	(__NR_Linux + 36)
+#define __NR_kill	(__NR_Linux + 37)
+#define __NR_rename	(__NR_Linux + 38)
+#define __NR_mkdir	(__NR_Linux + 39)
+#define __NR_rmdir	(__NR_Linux + 40)
+#define __NR_dup	(__NR_Linux + 41)
+#define __NR_pipe	(__NR_Linux + 42)
+#define __NR_times	(__NR_Linux + 43)
+#define __NR_prof	(__NR_Linux + 44)
+#define __NR_brk	(__NR_Linux + 45)
+#define __NR_setgid	(__NR_Linux + 46)
+#define __NR_getgid	(__NR_Linux + 47)
+#define __NR_signal	(__NR_Linux + 48)
+#define __NR_geteuid	(__NR_Linux + 49)
+#define __NR_getegid	(__NR_Linux + 50)
+#define __NR_acct	(__NR_Linux + 51)
+#define __NR_umount2	(__NR_Linux + 52)
+#define __NR_lock	(__NR_Linux + 53)
+#define __NR_ioctl	(__NR_Linux + 54)
+#define __NR_fcntl	(__NR_Linux + 55)
+#define __NR_mpx	(__NR_Linux + 56)
+#define __NR_setpgid	(__NR_Linux + 57)
+#define __NR_ulimit	(__NR_Linux + 58)
+#define __NR_unused59	(__NR_Linux + 59)
+#define __NR_umask	(__NR_Linux + 60)
+#define __NR_chroot	(__NR_Linux + 61)
+#define __NR_ustat	(__NR_Linux + 62)
+#define __NR_dup2	(__NR_Linux + 63)
+#define __NR_getppid	(__NR_Linux + 64)
+#define __NR_getpgrp	(__NR_Linux + 65)
+#define __NR_setsid	(__NR_Linux + 66)
+#define __NR_sigaction	(__NR_Linux + 67)
+#define __NR_sgetmask	(__NR_Linux + 68)
+#define __NR_ssetmask	(__NR_Linux + 69)
+#define __NR_setreuid	(__NR_Linux + 70)
+#define __NR_setregid	(__NR_Linux + 71)
+#define __NR_sigsuspend	(__NR_Linux + 72)
+#define __NR_sigpending	(__NR_Linux + 73)
+#define __NR_sethostname	(__NR_Linux + 74)
+#define __NR_setrlimit	(__NR_Linux + 75)
+#define __NR_getrlimit	(__NR_Linux + 76)
+#define __NR_getrusage	(__NR_Linux + 77)
+#define __NR_gettimeofday	(__NR_Linux + 78)
+#define __NR_settimeofday	(__NR_Linux + 79)
+#define __NR_getgroups	(__NR_Linux + 80)
+#define __NR_setgroups	(__NR_Linux + 81)
+#define __NR_reserved82	(__NR_Linux + 82)
+#define __NR_symlink	(__NR_Linux + 83)
+#define __NR_unused84	(__NR_Linux + 84)
+#define __NR_readlink	(__NR_Linux + 85)
+#define __NR_uselib	(__NR_Linux + 86)
+#define __NR_swapon	(__NR_Linux + 87)
+#define __NR_reboot	(__NR_Linux + 88)
+#define __NR_readdir	(__NR_Linux + 89)
+#define __NR_mmap	(__NR_Linux + 90)
+#define __NR_munmap	(__NR_Linux + 91)
+#define __NR_truncate	(__NR_Linux + 92)
+#define __NR_ftruncate	(__NR_Linux + 93)
+#define __NR_fchmod	(__NR_Linux + 94)
+#define __NR_fchown	(__NR_Linux + 95)
+#define __NR_getpriority	(__NR_Linux + 96)
+#define __NR_setpriority	(__NR_Linux + 97)
+#define __NR_profil	(__NR_Linux + 98)
+#define __NR_statfs	(__NR_Linux + 99)
+#define __NR_fstatfs	(__NR_Linux + 100)
+#define __NR_ioperm	(__NR_Linux + 101)
+#define __NR_socketcall	(__NR_Linux + 102)
+#define __NR_syslog	(__NR_Linux + 103)
+#define __NR_setitimer	(__NR_Linux + 104)
+#define __NR_getitimer	(__NR_Linux + 105)
+#define __NR_stat	(__NR_Linux + 106)
+#define __NR_lstat	(__NR_Linux + 107)
+#define __NR_fstat	(__NR_Linux + 108)
+#define __NR_unused109	(__NR_Linux + 109)
+#define __NR_iopl	(__NR_Linux + 110)
+#define __NR_vhangup	(__NR_Linux + 111)
+#define __NR_idle	(__NR_Linux + 112)
+#define __NR_vm86	(__NR_Linux + 113)
+#define __NR_wait4	(__NR_Linux + 114)
+#define __NR_swapoff	(__NR_Linux + 115)
+#define __NR_sysinfo	(__NR_Linux + 116)
+#define __NR_ipc	(__NR_Linux + 117)
+#define __NR_fsync	(__NR_Linux + 118)
+#define __NR_sigreturn	(__NR_Linux + 119)
+#define __NR_clone	(__NR_Linux + 120)
+#define __NR_setdomainname	(__NR_Linux + 121)
+#define __NR_uname	(__NR_Linux + 122)
+#define __NR_modify_ldt	(__NR_Linux + 123)
+#define __NR_adjtimex	(__NR_Linux + 124)
+#define __NR_mprotect	(__NR_Linux + 125)
+#define __NR_sigprocmask	(__NR_Linux + 126)
+#define __NR_create_module	(__NR_Linux + 127)
+#define __NR_init_module	(__NR_Linux + 128)
+#define __NR_delete_module	(__NR_Linux + 129)
+#define __NR_get_kernel_syms	(__NR_Linux + 130)
+#define __NR_quotactl	(__NR_Linux + 131)
+#define __NR_getpgid	(__NR_Linux + 132)
+#define __NR_fchdir	(__NR_Linux + 133)
+#define __NR_bdflush	(__NR_Linux + 134)
+#define __NR_sysfs	(__NR_Linux + 135)
+#define __NR_personality	(__NR_Linux + 136)
+#define __NR_afs_syscall	(__NR_Linux + 137)
+#define __NR_setfsuid	(__NR_Linux + 138)
+#define __NR_setfsgid	(__NR_Linux + 139)
+#define __NR__llseek	(__NR_Linux + 140)
+#define __NR_getdents	(__NR_Linux + 141)
+#define __NR__newselect	(__NR_Linux + 142)
+#define __NR_flock	(__NR_Linux + 143)
+#define __NR_msync	(__NR_Linux + 144)
+#define __NR_readv	(__NR_Linux + 145)
+#define __NR_writev	(__NR_Linux + 146)
+#define __NR_cacheflush	(__NR_Linux + 147)
+#define __NR_cachectl	(__NR_Linux + 148)
+#define __NR_sysmips	(__NR_Linux + 149)
+#define __NR_unused150	(__NR_Linux + 150)
+#define __NR_getsid	(__NR_Linux + 151)
+#define __NR_fdatasync	(__NR_Linux + 152)
+#define __NR__sysctl	(__NR_Linux + 153)
+#define __NR_mlock	(__NR_Linux + 154)
+#define __NR_munlock	(__NR_Linux + 155)
+#define __NR_mlockall	(__NR_Linux + 156)
+#define __NR_munlockall	(__NR_Linux + 157)
+#define __NR_sched_setparam	(__NR_Linux + 158)
+#define __NR_sched_getparam	(__NR_Linux + 159)
+#define __NR_sched_setscheduler	(__NR_Linux + 160)
+#define __NR_sched_getscheduler	(__NR_Linux + 161)
+#define __NR_sched_yield	(__NR_Linux + 162)
+#define __NR_sched_get_priority_max	(__NR_Linux + 163)
+#define __NR_sched_get_priority_min	(__NR_Linux + 164)
+#define __NR_sched_rr_get_interval	(__NR_Linux + 165)
+#define __NR_nanosleep	(__NR_Linux + 166)
+#define __NR_mremap	(__NR_Linux + 167)
+#define __NR_accept	(__NR_Linux + 168)
+#define __NR_bind	(__NR_Linux + 169)
+#define __NR_connect	(__NR_Linux + 170)
+#define __NR_getpeername	(__NR_Linux + 171)
+#define __NR_getsockname	(__NR_Linux + 172)
+#define __NR_getsockopt	(__NR_Linux + 173)
+#define __NR_listen	(__NR_Linux + 174)
+#define __NR_recv	(__NR_Linux + 175)
+#define __NR_recvfrom	(__NR_Linux + 176)
+#define __NR_recvmsg	(__NR_Linux + 177)
+#define __NR_send	(__NR_Linux + 178)
+#define __NR_sendmsg	(__NR_Linux + 179)
+#define __NR_sendto	(__NR_Linux + 180)
+#define __NR_setsockopt	(__NR_Linux + 181)
+#define __NR_shutdown	(__NR_Linux + 182)
+#define __NR_socket	(__NR_Linux + 183)
+#define __NR_socketpair	(__NR_Linux + 184)
+#define __NR_setresuid	(__NR_Linux + 185)
+#define __NR_getresuid	(__NR_Linux + 186)
+#define __NR_query_module	(__NR_Linux + 187)
+#define __NR_poll	(__NR_Linux + 188)
+#define __NR_nfsservctl	(__NR_Linux + 189)
+#define __NR_setresgid	(__NR_Linux + 190)
+#define __NR_getresgid	(__NR_Linux + 191)
+#define __NR_prctl	(__NR_Linux + 192)
+#define __NR_rt_sigreturn	(__NR_Linux + 193)
+#define __NR_rt_sigaction	(__NR_Linux + 194)
+#define __NR_rt_sigprocmask	(__NR_Linux + 195)
+#define __NR_rt_sigpending	(__NR_Linux + 196)
+#define __NR_rt_sigtimedwait	(__NR_Linux + 197)
+#define __NR_rt_sigqueueinfo	(__NR_Linux + 198)
+#define __NR_rt_sigsuspend	(__NR_Linux + 199)
+#define __NR_pread64	(__NR_Linux + 200)
+#define __NR_pwrite64	(__NR_Linux + 201)
+#define __NR_chown	(__NR_Linux + 202)
+#define __NR_getcwd	(__NR_Linux + 203)
+#define __NR_capget	(__NR_Linux + 204)
+#define __NR_capset	(__NR_Linux + 205)
+#define __NR_sigaltstack	(__NR_Linux + 206)
+#define __NR_sendfile	(__NR_Linux + 207)
+#define __NR_getpmsg	(__NR_Linux + 208)
+#define __NR_putpmsg	(__NR_Linux + 209)
+#define __NR_mmap2	(__NR_Linux + 210)
+#define __NR_truncate64	(__NR_Linux + 211)
+#define __NR_ftruncate64	(__NR_Linux + 212)
+#define __NR_stat64	(__NR_Linux + 213)
+#define __NR_lstat64	(__NR_Linux + 214)
+#define __NR_fstat64	(__NR_Linux + 215)
+#define __NR_pivot_root	(__NR_Linux + 216)
+#define __NR_mincore	(__NR_Linux + 217)
+#define __NR_madvise	(__NR_Linux + 218)
+#define __NR_getdents64	(__NR_Linux + 219)
+#define __NR_fcntl64	(__NR_Linux + 220)
+#define __NR_reserved221	(__NR_Linux + 221)
+#define __NR_gettid	(__NR_Linux + 222)
+#define __NR_readahead	(__NR_Linux + 223)
+#define __NR_setxattr	(__NR_Linux + 224)
+#define __NR_lsetxattr	(__NR_Linux + 225)
+#define __NR_fsetxattr	(__NR_Linux + 226)
+#define __NR_getxattr	(__NR_Linux + 227)
+#define __NR_lgetxattr	(__NR_Linux + 228)
+#define __NR_fgetxattr	(__NR_Linux + 229)
+#define __NR_listxattr	(__NR_Linux + 230)
+#define __NR_llistxattr	(__NR_Linux + 231)
+#define __NR_flistxattr	(__NR_Linux + 232)
+#define __NR_removexattr	(__NR_Linux + 233)
+#define __NR_lremovexattr	(__NR_Linux + 234)
+#define __NR_fremovexattr	(__NR_Linux + 235)
+#define __NR_tkill	(__NR_Linux + 236)
+#define __NR_sendfile64	(__NR_Linux + 237)
+#define __NR_futex	(__NR_Linux + 238)
+#define __NR_sched_setaffinity	(__NR_Linux + 239)
+#define __NR_sched_getaffinity	(__NR_Linux + 240)
+#define __NR_io_setup	(__NR_Linux + 241)
+#define __NR_io_destroy	(__NR_Linux + 242)
+#define __NR_io_getevents	(__NR_Linux + 243)
+#define __NR_io_submit	(__NR_Linux + 244)
+#define __NR_io_cancel	(__NR_Linux + 245)
+#define __NR_exit_group	(__NR_Linux + 246)
+#define __NR_lookup_dcookie	(__NR_Linux + 247)
+#define __NR_epoll_create	(__NR_Linux + 248)
+#define __NR_epoll_ctl	(__NR_Linux + 249)
+#define __NR_epoll_wait	(__NR_Linux + 250)
+#define __NR_remap_file_pages	(__NR_Linux + 251)
+#define __NR_set_tid_address	(__NR_Linux + 252)
+#define __NR_restart_syscall	(__NR_Linux + 253)
+#define __NR_fadvise64	(__NR_Linux + 254)
+#define __NR_statfs64	(__NR_Linux + 255)
+#define __NR_fstatfs64	(__NR_Linux + 256)
+#define __NR_timer_create	(__NR_Linux + 257)
+#define __NR_timer_settime	(__NR_Linux + 258)
+#define __NR_timer_gettime	(__NR_Linux + 259)
+#define __NR_timer_getoverrun	(__NR_Linux + 260)
+#define __NR_timer_delete	(__NR_Linux + 261)
+#define __NR_clock_settime	(__NR_Linux + 262)
+#define __NR_clock_gettime	(__NR_Linux + 263)
+#define __NR_clock_getres	(__NR_Linux + 264)
+#define __NR_clock_nanosleep	(__NR_Linux + 265)
+#define __NR_tgkill	(__NR_Linux + 266)
+#define __NR_utimes	(__NR_Linux + 267)
+#define __NR_mbind	(__NR_Linux + 268)
+#define __NR_get_mempolicy	(__NR_Linux + 269)
+#define __NR_set_mempolicy	(__NR_Linux + 270)
+#define __NR_mq_open	(__NR_Linux + 271)
+#define __NR_mq_unlink	(__NR_Linux + 272)
+#define __NR_mq_timedsend	(__NR_Linux + 273)
+#define __NR_mq_timedreceive	(__NR_Linux + 274)
+#define __NR_mq_notify	(__NR_Linux + 275)
+#define __NR_mq_getsetattr	(__NR_Linux + 276)
+#define __NR_vserver	(__NR_Linux + 277)
+#define __NR_waitid	(__NR_Linux + 278)
+#define __NR_add_key	(__NR_Linux + 280)
+#define __NR_request_key	(__NR_Linux + 281)
+#define __NR_keyctl	(__NR_Linux + 282)
+#define __NR_set_thread_area	(__NR_Linux + 283)
+#define __NR_inotify_init	(__NR_Linux + 284)
+#define __NR_inotify_add_watch	(__NR_Linux + 285)
+#define __NR_inotify_rm_watch	(__NR_Linux + 286)
+#define __NR_migrate_pages	(__NR_Linux + 287)
+#define __NR_openat	(__NR_Linux + 288)
+#define __NR_mkdirat	(__NR_Linux + 289)
+#define __NR_mknodat	(__NR_Linux + 290)
+#define __NR_fchownat	(__NR_Linux + 291)
+#define __NR_futimesat	(__NR_Linux + 292)
+#define __NR_fstatat64	(__NR_Linux + 293)
+#define __NR_unlinkat	(__NR_Linux + 294)
+#define __NR_renameat	(__NR_Linux + 295)
+#define __NR_linkat	(__NR_Linux + 296)
+#define __NR_symlinkat	(__NR_Linux + 297)
+#define __NR_readlinkat	(__NR_Linux + 298)
+#define __NR_fchmodat	(__NR_Linux + 299)
+#define __NR_faccessat	(__NR_Linux + 300)
+#define __NR_pselect6	(__NR_Linux + 301)
+#define __NR_ppoll	(__NR_Linux + 302)
+#define __NR_unshare	(__NR_Linux + 303)
+#define __NR_splice	(__NR_Linux + 304)
+#define __NR_sync_file_range	(__NR_Linux + 305)
+#define __NR_tee	(__NR_Linux + 306)
+#define __NR_vmsplice	(__NR_Linux + 307)
+#define __NR_move_pages	(__NR_Linux + 308)
+#define __NR_set_robust_list	(__NR_Linux + 309)
+#define __NR_get_robust_list	(__NR_Linux + 310)
+#define __NR_kexec_load	(__NR_Linux + 311)
+#define __NR_getcpu	(__NR_Linux + 312)
+#define __NR_epoll_pwait	(__NR_Linux + 313)
+#define __NR_ioprio_set	(__NR_Linux + 314)
+#define __NR_ioprio_get	(__NR_Linux + 315)
+#define __NR_utimensat	(__NR_Linux + 316)
+#define __NR_signalfd	(__NR_Linux + 317)
+#define __NR_timerfd	(__NR_Linux + 318)
+#define __NR_eventfd	(__NR_Linux + 319)
+#define __NR_fallocate	(__NR_Linux + 320)
+#define __NR_timerfd_create	(__NR_Linux + 321)
+#define __NR_timerfd_gettime	(__NR_Linux + 322)
+#define __NR_timerfd_settime	(__NR_Linux + 323)
+#define __NR_signalfd4	(__NR_Linux + 324)
+#define __NR_eventfd2	(__NR_Linux + 325)
+#define __NR_epoll_create1	(__NR_Linux + 326)
+#define __NR_dup3	(__NR_Linux + 327)
+#define __NR_pipe2	(__NR_Linux + 328)
+#define __NR_inotify_init1	(__NR_Linux + 329)
+#define __NR_preadv	(__NR_Linux + 330)
+#define __NR_pwritev	(__NR_Linux + 331)
+#define __NR_rt_tgsigqueueinfo	(__NR_Linux + 332)
+#define __NR_perf_event_open	(__NR_Linux + 333)
+#define __NR_accept4	(__NR_Linux + 334)
+#define __NR_recvmmsg	(__NR_Linux + 335)
+#define __NR_fanotify_init	(__NR_Linux + 336)
+#define __NR_fanotify_mark	(__NR_Linux + 337)
+#define __NR_prlimit64	(__NR_Linux + 338)
+#define __NR_name_to_handle_at	(__NR_Linux + 339)
+#define __NR_open_by_handle_at	(__NR_Linux + 340)
+#define __NR_clock_adjtime	(__NR_Linux + 341)
+#define __NR_syncfs	(__NR_Linux + 342)
+#define __NR_sendmmsg	(__NR_Linux + 343)
+#define __NR_setns	(__NR_Linux + 344)
+#define __NR_process_vm_readv	(__NR_Linux + 345)
+#define __NR_process_vm_writev	(__NR_Linux + 346)
+#define __NR_kcmp	(__NR_Linux + 347)
+#define __NR_finit_module	(__NR_Linux + 348)
+#define __NR_sched_setattr	(__NR_Linux + 349)
+#define __NR_sched_getattr	(__NR_Linux + 350)
+#define __NR_renameat2	(__NR_Linux + 351)
+#define __NR_seccomp	(__NR_Linux + 352)
+#define __NR_getrandom	(__NR_Linux + 353)
+#define __NR_memfd_create	(__NR_Linux + 354)
+#define __NR_bpf	(__NR_Linux + 355)
+#define __NR_execveat	(__NR_Linux + 356)
+#define __NR_userfaultfd	(__NR_Linux + 357)
+#define __NR_membarrier	(__NR_Linux + 358)
+#define __NR_mlock2	(__NR_Linux + 359)
+#define __NR_copy_file_range	(__NR_Linux + 360)
+#define __NR_preadv2	(__NR_Linux + 361)
+#define __NR_pwritev2	(__NR_Linux + 362)
+#define __NR_pkey_mprotect	(__NR_Linux + 363)
+#define __NR_pkey_alloc	(__NR_Linux + 364)
+#define __NR_pkey_free	(__NR_Linux + 365)
+#define __NR_statx	(__NR_Linux + 366)
+#define __NR_rseq	(__NR_Linux + 367)
+#define __NR_io_pgetevents	(__NR_Linux + 368)
+#define __NR_semget	(__NR_Linux + 393)
+#define __NR_semctl	(__NR_Linux + 394)
+#define __NR_shmget	(__NR_Linux + 395)
+#define __NR_shmctl	(__NR_Linux + 396)
+#define __NR_shmat	(__NR_Linux + 397)
+#define __NR_shmdt	(__NR_Linux + 398)
+#define __NR_msgget	(__NR_Linux + 399)
+#define __NR_msgsnd	(__NR_Linux + 400)
+#define __NR_msgrcv	(__NR_Linux + 401)
+#define __NR_msgctl	(__NR_Linux + 402)
+#define __NR_clock_gettime64	(__NR_Linux + 403)
+#define __NR_clock_settime64	(__NR_Linux + 404)
+#define __NR_clock_adjtime64	(__NR_Linux + 405)
+#define __NR_clock_getres_time64	(__NR_Linux + 406)
+#define __NR_clock_nanosleep_time64	(__NR_Linux + 407)
+#define __NR_timer_gettime64	(__NR_Linux + 408)
+#define __NR_timer_settime64	(__NR_Linux + 409)
+#define __NR_timerfd_gettime64	(__NR_Linux + 410)
+#define __NR_timerfd_settime64	(__NR_Linux + 411)
+#define __NR_utimensat_time64	(__NR_Linux + 412)
+#define __NR_pselect6_time64	(__NR_Linux + 413)
+#define __NR_ppoll_time64	(__NR_Linux + 414)
+#define __NR_io_pgetevents_time64	(__NR_Linux + 416)
+#define __NR_recvmmsg_time64	(__NR_Linux + 417)
+#define __NR_mq_timedsend_time64	(__NR_Linux + 418)
+#define __NR_mq_timedreceive_time64	(__NR_Linux + 419)
+#define __NR_semtimedop_time64	(__NR_Linux + 420)
+#define __NR_rt_sigtimedwait_time64	(__NR_Linux + 421)
+#define __NR_futex_time64	(__NR_Linux + 422)
+#define __NR_sched_rr_get_interval_time64	(__NR_Linux + 423)
+#define __NR_pidfd_send_signal	(__NR_Linux + 424)
+#define __NR_io_uring_setup	(__NR_Linux + 425)
+#define __NR_io_uring_enter	(__NR_Linux + 426)
+#define __NR_io_uring_register	(__NR_Linux + 427)
+#define __NR_open_tree	(__NR_Linux + 428)
+#define __NR_move_mount	(__NR_Linux + 429)
+#define __NR_fsopen	(__NR_Linux + 430)
+#define __NR_fsconfig	(__NR_Linux + 431)
+#define __NR_fsmount	(__NR_Linux + 432)
+#define __NR_fspick	(__NR_Linux + 433)
+#define __NR_pidfd_open	(__NR_Linux + 434)
+#define __NR_clone3	(__NR_Linux + 435)
+#define __NR_close_range	(__NR_Linux + 436)
+#define __NR_openat2	(__NR_Linux + 437)
+#define __NR_pidfd_getfd	(__NR_Linux + 438)
+#define __NR_faccessat2	(__NR_Linux + 439)
+#define __NR_process_madvise	(__NR_Linux + 440)
+#define __NR_epoll_pwait2	(__NR_Linux + 441)
 
-#endif /* _ASM_UNISTD_O32_H */
+
+#endif /* _ASM_MIPS_UNISTD_O32_H */
diff --git a/linux-headers/asm-powerpc/kvm.h b/linux-headers/asm-powerpc/kvm.h
index 9f18fa090f..c3af3f324c 100644
--- a/linux-headers/asm-powerpc/kvm.h
+++ b/linux-headers/asm-powerpc/kvm.h
@@ -644,8 +644,6 @@ struct kvm_ppc_cpu_char {
 #define KVM_REG_PPC_MMCR3	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xc1)
 #define KVM_REG_PPC_SIER2	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xc2)
 #define KVM_REG_PPC_SIER3	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xc3)
-#define KVM_REG_PPC_DAWR1	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xc4)
-#define KVM_REG_PPC_DAWRX1	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xc5)
 
 /* Transactional Memory checkpointed state:
  * This is all GPRs, all VSX regs and a subset of SPRs
diff --git a/linux-headers/asm-powerpc/unistd_32.h b/linux-headers/asm-powerpc/unistd_32.h
index 9155778c19..4624c90043 100644
--- a/linux-headers/asm-powerpc/unistd_32.h
+++ b/linux-headers/asm-powerpc/unistd_32.h
@@ -1,433 +1,429 @@
-#ifndef _ASM_UNISTD_32_H
-#define _ASM_UNISTD_32_H
+#ifndef _ASM_POWERPC_UNISTD_32_H
+#define _ASM_POWERPC_UNISTD_32_H
 
-#define __NR_restart_syscall 0
-#define __NR_exit 1
-#define __NR_fork 2
-#define __NR_read 3
-#define __NR_write 4
-#define __NR_open 5
-#define __NR_close 6
-#define __NR_waitpid 7
-#define __NR_creat 8
-#define __NR_link 9
-#define __NR_unlink 10
-#define __NR_execve 11
-#define __NR_chdir 12
-#define __NR_time 13
-#define __NR_mknod 14
-#define __NR_chmod 15
-#define __NR_lchown 16
-#define __NR_break 17
-#define __NR_oldstat 18
-#define __NR_lseek 19
-#define __NR_getpid 20
-#define __NR_mount 21
-#define __NR_umount 22
-#define __NR_setuid 23
-#define __NR_getuid 24
-#define __NR_stime 25
-#define __NR_ptrace 26
-#define __NR_alarm 27
-#define __NR_oldfstat 28
-#define __NR_pause 29
-#define __NR_utime 30
-#define __NR_stty 31
-#define __NR_gtty 32
-#define __NR_access 33
-#define __NR_nice 34
-#define __NR_ftime 35
-#define __NR_sync 36
-#define __NR_kill 37
-#define __NR_rename 38
-#define __NR_mkdir 39
-#define __NR_rmdir 40
-#define __NR_dup 41
-#define __NR_pipe 42
-#define __NR_times 43
-#define __NR_prof 44
-#define __NR_brk 45
-#define __NR_setgid 46
-#define __NR_getgid 47
-#define __NR_signal 48
-#define __NR_geteuid 49
-#define __NR_getegid 50
-#define __NR_acct 51
-#define __NR_umount2 52
-#define __NR_lock 53
-#define __NR_ioctl 54
-#define __NR_fcntl 55
-#define __NR_mpx 56
-#define __NR_setpgid 57
-#define __NR_ulimit 58
-#define __NR_oldolduname 59
-#define __NR_umask 60
-#define __NR_chroot 61
-#define __NR_ustat 62
-#define __NR_dup2 63
-#define __NR_getppid 64
-#define __NR_getpgrp 65
-#define __NR_setsid 66
-#define __NR_sigaction 67
-#define __NR_sgetmask 68
-#define __NR_ssetmask 69
-#define __NR_setreuid 70
-#define __NR_setregid 71
-#define __NR_sigsuspend 72
-#define __NR_sigpending 73
-#define __NR_sethostname 74
-#define __NR_setrlimit 75
-#define __NR_getrlimit 76
-#define __NR_getrusage 77
-#define __NR_gettimeofday 78
-#define __NR_settimeofday 79
-#define __NR_getgroups 80
-#define __NR_setgroups 81
-#define __NR_select 82
-#define __NR_symlink 83
-#define __NR_oldlstat 84
-#define __NR_readlink 85
-#define __NR_uselib 86
-#define __NR_swapon 87
-#define __NR_reboot 88
-#define __NR_readdir 89
-#define __NR_mmap 90
-#define __NR_munmap 91
-#define __NR_truncate 92
-#define __NR_ftruncate 93
-#define __NR_fchmod 94
-#define __NR_fchown 95
-#define __NR_getpriority 96
-#define __NR_setpriority 97
-#define __NR_profil 98
-#define __NR_statfs 99
-#define __NR_fstatfs 100
-#define __NR_ioperm 101
-#define __NR_socketcall 102
-#define __NR_syslog 103
-#define __NR_setitimer 104
-#define __NR_getitimer 105
-#define __NR_stat 106
-#define __NR_lstat 107
-#define __NR_fstat 108
-#define __NR_olduname 109
-#define __NR_iopl 110
-#define __NR_vhangup 111
-#define __NR_idle 112
-#define __NR_vm86 113
-#define __NR_wait4 114
-#define __NR_swapoff 115
-#define __NR_sysinfo 116
-#define __NR_ipc 117
-#define __NR_fsync 118
-#define __NR_sigreturn 119
-#define __NR_clone 120
-#define __NR_setdomainname 121
-#define __NR_uname 122
-#define __NR_modify_ldt 123
-#define __NR_adjtimex 124
-#define __NR_mprotect 125
-#define __NR_sigprocmask 126
-#define __NR_create_module 127
-#define __NR_init_module 128
-#define __NR_delete_module 129
-#define __NR_get_kernel_syms 130
-#define __NR_quotactl 131
-#define __NR_getpgid 132
-#define __NR_fchdir 133
-#define __NR_bdflush 134
-#define __NR_sysfs 135
-#define __NR_personality 136
-#define __NR_afs_syscall 137
-#define __NR_setfsuid 138
-#define __NR_setfsgid 139
-#define __NR__llseek 140
-#define __NR_getdents 141
-#define __NR__newselect 142
-#define __NR_flock 143
-#define __NR_msync 144
-#define __NR_readv 145
-#define __NR_writev 146
-#define __NR_getsid 147
-#define __NR_fdatasync 148
-#define __NR__sysctl 149
-#define __NR_mlock 150
-#define __NR_munlock 151
-#define __NR_mlockall 152
-#define __NR_munlockall 153
-#define __NR_sched_setparam 154
-#define __NR_sched_getparam 155
-#define __NR_sched_setscheduler 156
-#define __NR_sched_getscheduler 157
-#define __NR_sched_yield 158
-#define __NR_sched_get_priority_max 159
-#define __NR_sched_get_priority_min 160
-#define __NR_sched_rr_get_interval 161
-#define __NR_nanosleep 162
-#define __NR_mremap 163
-#define __NR_setresuid 164
-#define __NR_getresuid 165
-#define __NR_query_module 166
-#define __NR_poll 167
-#define __NR_nfsservctl 168
-#define __NR_setresgid 169
-#define __NR_getresgid 170
-#define __NR_prctl 171
-#define __NR_rt_sigreturn 172
-#define __NR_rt_sigaction 173
-#define __NR_rt_sigprocmask 174
-#define __NR_rt_sigpending 175
-#define __NR_rt_sigtimedwait 176
-#define __NR_rt_sigqueueinfo 177
-#define __NR_rt_sigsuspend 178
-#define __NR_pread64 179
-#define __NR_pwrite64 180
-#define __NR_chown 181
-#define __NR_getcwd 182
-#define __NR_capget 183
-#define __NR_capset 184
-#define __NR_sigaltstack 185
-#define __NR_sendfile 186
-#define __NR_getpmsg 187
-#define __NR_putpmsg 188
-#define __NR_vfork 189
-#define __NR_ugetrlimit 190
-#define __NR_readahead 191
-#define __NR_mmap2 192
-#define __NR_truncate64 193
-#define __NR_ftruncate64 194
-#define __NR_stat64 195
-#define __NR_lstat64 196
-#define __NR_fstat64 197
-#define __NR_pciconfig_read 198
-#define __NR_pciconfig_write 199
-#define __NR_pciconfig_iobase 200
-#define __NR_multiplexer 201
-#define __NR_getdents64 202
-#define __NR_pivot_root 203
-#define __NR_fcntl64 204
-#define __NR_madvise 205
-#define __NR_mincore 206
-#define __NR_gettid 207
-#define __NR_tkill 208
-#define __NR_setxattr 209
-#define __NR_lsetxattr 210
-#define __NR_fsetxattr 211
-#define __NR_getxattr 212
-#define __NR_lgetxattr 213
-#define __NR_fgetxattr 214
-#define __NR_listxattr 215
-#define __NR_llistxattr 216
-#define __NR_flistxattr 217
-#define __NR_removexattr 218
-#define __NR_lremovexattr 219
-#define __NR_fremovexattr 220
-#define __NR_futex 221
-#define __NR_sched_setaffinity 222
-#define __NR_sched_getaffinity 223
-#define __NR_tuxcall 225
-#define __NR_sendfile64 226
-#define __NR_io_setup 227
-#define __NR_io_destroy 228
-#define __NR_io_getevents 229
-#define __NR_io_submit 230
-#define __NR_io_cancel 231
-#define __NR_set_tid_address 232
-#define __NR_fadvise64 233
-#define __NR_exit_group 234
-#define __NR_lookup_dcookie 235
-#define __NR_epoll_create 236
-#define __NR_epoll_ctl 237
-#define __NR_epoll_wait 238
-#define __NR_remap_file_pages 239
-#define __NR_timer_create 240
-#define __NR_timer_settime 241
-#define __NR_timer_gettime 242
-#define __NR_timer_getoverrun 243
-#define __NR_timer_delete 244
-#define __NR_clock_settime 245
-#define __NR_clock_gettime 246
-#define __NR_clock_getres 247
-#define __NR_clock_nanosleep 248
-#define __NR_swapcontext 249
-#define __NR_tgkill 250
-#define __NR_utimes 251
-#define __NR_statfs64 252
-#define __NR_fstatfs64 253
-#define __NR_fadvise64_64 254
-#define __NR_rtas 255
-#define __NR_sys_debug_setcontext 256
-#define __NR_migrate_pages 258
-#define __NR_mbind 259
-#define __NR_get_mempolicy 260
-#define __NR_set_mempolicy 261
-#define __NR_mq_open 262
-#define __NR_mq_unlink 263
-#define __NR_mq_timedsend 264
-#define __NR_mq_timedreceive 265
-#define __NR_mq_notify 266
-#define __NR_mq_getsetattr 267
-#define __NR_kexec_load 268
-#define __NR_add_key 269
-#define __NR_request_key 270
-#define __NR_keyctl 271
-#define __NR_waitid 272
-#define __NR_ioprio_set 273
-#define __NR_ioprio_get 274
-#define __NR_inotify_init 275
-#define __NR_inotify_add_watch 276
-#define __NR_inotify_rm_watch 277
-#define __NR_spu_run 278
-#define __NR_spu_create 279
-#define __NR_pselect6 280
-#define __NR_ppoll 281
-#define __NR_unshare 282
-#define __NR_splice 283
-#define __NR_tee 284
-#define __NR_vmsplice 285
-#define __NR_openat 286
-#define __NR_mkdirat 287
-#define __NR_mknodat 288
-#define __NR_fchownat 289
-#define __NR_futimesat 290
-#define __NR_fstatat64 291
-#define __NR_unlinkat 292
-#define __NR_renameat 293
-#define __NR_linkat 294
-#define __NR_symlinkat 295
-#define __NR_readlinkat 296
-#define __NR_fchmodat 297
-#define __NR_faccessat 298
-#define __NR_get_robust_list 299
-#define __NR_set_robust_list 300
-#define __NR_move_pages 301
-#define __NR_getcpu 302
-#define __NR_epoll_pwait 303
-#define __NR_utimensat 304
-#define __NR_signalfd 305
-#define __NR_timerfd_create 306
-#define __NR_eventfd 307
-#define __NR_sync_file_range2 308
-#define __NR_fallocate 309
-#define __NR_subpage_prot 310
-#define __NR_timerfd_settime 311
-#define __NR_timerfd_gettime 312
-#define __NR_signalfd4 313
-#define __NR_eventfd2 314
-#define __NR_epoll_create1 315
-#define __NR_dup3 316
-#define __NR_pipe2 317
-#define __NR_inotify_init1 318
-#define __NR_perf_event_open 319
-#define __NR_preadv 320
-#define __NR_pwritev 321
-#define __NR_rt_tgsigqueueinfo 322
-#define __NR_fanotify_init 323
-#define __NR_fanotify_mark 324
-#define __NR_prlimit64 325
-#define __NR_socket 326
-#define __NR_bind 327
-#define __NR_connect 328
-#define __NR_listen 329
-#define __NR_accept 330
-#define __NR_getsockname 331
-#define __NR_getpeername 332
-#define __NR_socketpair 333
-#define __NR_send 334
-#define __NR_sendto 335
-#define __NR_recv 336
-#define __NR_recvfrom 337
-#define __NR_shutdown 338
-#define __NR_setsockopt 339
-#define __NR_getsockopt 340
-#define __NR_sendmsg 341
-#define __NR_recvmsg 342
-#define __NR_recvmmsg 343
-#define __NR_accept4 344
-#define __NR_name_to_handle_at 345
-#define __NR_open_by_handle_at 346
-#define __NR_clock_adjtime 347
-#define __NR_syncfs 348
-#define __NR_sendmmsg 349
-#define __NR_setns 350
-#define __NR_process_vm_readv 351
-#define __NR_process_vm_writev 352
-#define __NR_finit_module 353
-#define __NR_kcmp 354
-#define __NR_sched_setattr 355
-#define __NR_sched_getattr 356
-#define __NR_renameat2 357
-#define __NR_seccomp 358
-#define __NR_getrandom 359
-#define __NR_memfd_create 360
-#define __NR_bpf 361
-#define __NR_execveat 362
-#define __NR_switch_endian 363
-#define __NR_userfaultfd 364
-#define __NR_membarrier 365
-#define __NR_mlock2 378
-#define __NR_copy_file_range 379
-#define __NR_preadv2 380
-#define __NR_pwritev2 381
-#define __NR_kexec_file_load 382
-#define __NR_statx 383
-#define __NR_pkey_alloc 384
-#define __NR_pkey_free 385
-#define __NR_pkey_mprotect 386
-#define __NR_rseq 387
-#define __NR_io_pgetevents 388
-#define __NR_semget 393
-#define __NR_semctl 394
-#define __NR_shmget 395
-#define __NR_shmctl 396
-#define __NR_shmat 397
-#define __NR_shmdt 398
-#define __NR_msgget 399
-#define __NR_msgsnd 400
-#define __NR_msgrcv 401
-#define __NR_msgctl 402
-#define __NR_clock_gettime64 403
-#define __NR_clock_settime64 404
-#define __NR_clock_adjtime64 405
-#define __NR_clock_getres_time64 406
-#define __NR_clock_nanosleep_time64 407
-#define __NR_timer_gettime64 408
-#define __NR_timer_settime64 409
-#define __NR_timerfd_gettime64 410
-#define __NR_timerfd_settime64 411
-#define __NR_utimensat_time64 412
-#define __NR_pselect6_time64 413
-#define __NR_ppoll_time64 414
-#define __NR_io_pgetevents_time64 416
-#define __NR_recvmmsg_time64 417
-#define __NR_mq_timedsend_time64 418
-#define __NR_mq_timedreceive_time64 419
-#define __NR_semtimedop_time64 420
-#define __NR_rt_sigtimedwait_time64 421
-#define __NR_futex_time64 422
-#define __NR_sched_rr_get_interval_time64 423
-#define __NR_pidfd_send_signal 424
-#define __NR_io_uring_setup 425
-#define __NR_io_uring_enter 426
-#define __NR_io_uring_register 427
-#define __NR_open_tree 428
-#define __NR_move_mount 429
-#define __NR_fsopen 430
-#define __NR_fsconfig 431
-#define __NR_fsmount 432
-#define __NR_fspick 433
-#define __NR_pidfd_open 434
-#define __NR_clone3 435
-#define __NR_close_range 436
-#define __NR_openat2 437
-#define __NR_pidfd_getfd 438
-#define __NR_faccessat2 439
-#define __NR_process_madvise 440
-#define __NR_epoll_pwait2 441
-#define __NR_mount_setattr 442
-#define __NR_landlock_create_ruleset 444
-#define __NR_landlock_add_rule 445
-#define __NR_landlock_restrict_self 446
+#define __NR_restart_syscall	0
+#define __NR_exit	1
+#define __NR_fork	2
+#define __NR_read	3
+#define __NR_write	4
+#define __NR_open	5
+#define __NR_close	6
+#define __NR_waitpid	7
+#define __NR_creat	8
+#define __NR_link	9
+#define __NR_unlink	10
+#define __NR_execve	11
+#define __NR_chdir	12
+#define __NR_time	13
+#define __NR_mknod	14
+#define __NR_chmod	15
+#define __NR_lchown	16
+#define __NR_break	17
+#define __NR_oldstat	18
+#define __NR_lseek	19
+#define __NR_getpid	20
+#define __NR_mount	21
+#define __NR_umount	22
+#define __NR_setuid	23
+#define __NR_getuid	24
+#define __NR_stime	25
+#define __NR_ptrace	26
+#define __NR_alarm	27
+#define __NR_oldfstat	28
+#define __NR_pause	29
+#define __NR_utime	30
+#define __NR_stty	31
+#define __NR_gtty	32
+#define __NR_access	33
+#define __NR_nice	34
+#define __NR_ftime	35
+#define __NR_sync	36
+#define __NR_kill	37
+#define __NR_rename	38
+#define __NR_mkdir	39
+#define __NR_rmdir	40
+#define __NR_dup	41
+#define __NR_pipe	42
+#define __NR_times	43
+#define __NR_prof	44
+#define __NR_brk	45
+#define __NR_setgid	46
+#define __NR_getgid	47
+#define __NR_signal	48
+#define __NR_geteuid	49
+#define __NR_getegid	50
+#define __NR_acct	51
+#define __NR_umount2	52
+#define __NR_lock	53
+#define __NR_ioctl	54
+#define __NR_fcntl	55
+#define __NR_mpx	56
+#define __NR_setpgid	57
+#define __NR_ulimit	58
+#define __NR_oldolduname	59
+#define __NR_umask	60
+#define __NR_chroot	61
+#define __NR_ustat	62
+#define __NR_dup2	63
+#define __NR_getppid	64
+#define __NR_getpgrp	65
+#define __NR_setsid	66
+#define __NR_sigaction	67
+#define __NR_sgetmask	68
+#define __NR_ssetmask	69
+#define __NR_setreuid	70
+#define __NR_setregid	71
+#define __NR_sigsuspend	72
+#define __NR_sigpending	73
+#define __NR_sethostname	74
+#define __NR_setrlimit	75
+#define __NR_getrlimit	76
+#define __NR_getrusage	77
+#define __NR_gettimeofday	78
+#define __NR_settimeofday	79
+#define __NR_getgroups	80
+#define __NR_setgroups	81
+#define __NR_select	82
+#define __NR_symlink	83
+#define __NR_oldlstat	84
+#define __NR_readlink	85
+#define __NR_uselib	86
+#define __NR_swapon	87
+#define __NR_reboot	88
+#define __NR_readdir	89
+#define __NR_mmap	90
+#define __NR_munmap	91
+#define __NR_truncate	92
+#define __NR_ftruncate	93
+#define __NR_fchmod	94
+#define __NR_fchown	95
+#define __NR_getpriority	96
+#define __NR_setpriority	97
+#define __NR_profil	98
+#define __NR_statfs	99
+#define __NR_fstatfs	100
+#define __NR_ioperm	101
+#define __NR_socketcall	102
+#define __NR_syslog	103
+#define __NR_setitimer	104
+#define __NR_getitimer	105
+#define __NR_stat	106
+#define __NR_lstat	107
+#define __NR_fstat	108
+#define __NR_olduname	109
+#define __NR_iopl	110
+#define __NR_vhangup	111
+#define __NR_idle	112
+#define __NR_vm86	113
+#define __NR_wait4	114
+#define __NR_swapoff	115
+#define __NR_sysinfo	116
+#define __NR_ipc	117
+#define __NR_fsync	118
+#define __NR_sigreturn	119
+#define __NR_clone	120
+#define __NR_setdomainname	121
+#define __NR_uname	122
+#define __NR_modify_ldt	123
+#define __NR_adjtimex	124
+#define __NR_mprotect	125
+#define __NR_sigprocmask	126
+#define __NR_create_module	127
+#define __NR_init_module	128
+#define __NR_delete_module	129
+#define __NR_get_kernel_syms	130
+#define __NR_quotactl	131
+#define __NR_getpgid	132
+#define __NR_fchdir	133
+#define __NR_bdflush	134
+#define __NR_sysfs	135
+#define __NR_personality	136
+#define __NR_afs_syscall	137
+#define __NR_setfsuid	138
+#define __NR_setfsgid	139
+#define __NR__llseek	140
+#define __NR_getdents	141
+#define __NR__newselect	142
+#define __NR_flock	143
+#define __NR_msync	144
+#define __NR_readv	145
+#define __NR_writev	146
+#define __NR_getsid	147
+#define __NR_fdatasync	148
+#define __NR__sysctl	149
+#define __NR_mlock	150
+#define __NR_munlock	151
+#define __NR_mlockall	152
+#define __NR_munlockall	153
+#define __NR_sched_setparam	154
+#define __NR_sched_getparam	155
+#define __NR_sched_setscheduler	156
+#define __NR_sched_getscheduler	157
+#define __NR_sched_yield	158
+#define __NR_sched_get_priority_max	159
+#define __NR_sched_get_priority_min	160
+#define __NR_sched_rr_get_interval	161
+#define __NR_nanosleep	162
+#define __NR_mremap	163
+#define __NR_setresuid	164
+#define __NR_getresuid	165
+#define __NR_query_module	166
+#define __NR_poll	167
+#define __NR_nfsservctl	168
+#define __NR_setresgid	169
+#define __NR_getresgid	170
+#define __NR_prctl	171
+#define __NR_rt_sigreturn	172
+#define __NR_rt_sigaction	173
+#define __NR_rt_sigprocmask	174
+#define __NR_rt_sigpending	175
+#define __NR_rt_sigtimedwait	176
+#define __NR_rt_sigqueueinfo	177
+#define __NR_rt_sigsuspend	178
+#define __NR_pread64	179
+#define __NR_pwrite64	180
+#define __NR_chown	181
+#define __NR_getcwd	182
+#define __NR_capget	183
+#define __NR_capset	184
+#define __NR_sigaltstack	185
+#define __NR_sendfile	186
+#define __NR_getpmsg	187
+#define __NR_putpmsg	188
+#define __NR_vfork	189
+#define __NR_ugetrlimit	190
+#define __NR_readahead	191
+#define __NR_mmap2	192
+#define __NR_truncate64	193
+#define __NR_ftruncate64	194
+#define __NR_stat64	195
+#define __NR_lstat64	196
+#define __NR_fstat64	197
+#define __NR_pciconfig_read	198
+#define __NR_pciconfig_write	199
+#define __NR_pciconfig_iobase	200
+#define __NR_multiplexer	201
+#define __NR_getdents64	202
+#define __NR_pivot_root	203
+#define __NR_fcntl64	204
+#define __NR_madvise	205
+#define __NR_mincore	206
+#define __NR_gettid	207
+#define __NR_tkill	208
+#define __NR_setxattr	209
+#define __NR_lsetxattr	210
+#define __NR_fsetxattr	211
+#define __NR_getxattr	212
+#define __NR_lgetxattr	213
+#define __NR_fgetxattr	214
+#define __NR_listxattr	215
+#define __NR_llistxattr	216
+#define __NR_flistxattr	217
+#define __NR_removexattr	218
+#define __NR_lremovexattr	219
+#define __NR_fremovexattr	220
+#define __NR_futex	221
+#define __NR_sched_setaffinity	222
+#define __NR_sched_getaffinity	223
+#define __NR_tuxcall	225
+#define __NR_sendfile64	226
+#define __NR_io_setup	227
+#define __NR_io_destroy	228
+#define __NR_io_getevents	229
+#define __NR_io_submit	230
+#define __NR_io_cancel	231
+#define __NR_set_tid_address	232
+#define __NR_fadvise64	233
+#define __NR_exit_group	234
+#define __NR_lookup_dcookie	235
+#define __NR_epoll_create	236
+#define __NR_epoll_ctl	237
+#define __NR_epoll_wait	238
+#define __NR_remap_file_pages	239
+#define __NR_timer_create	240
+#define __NR_timer_settime	241
+#define __NR_timer_gettime	242
+#define __NR_timer_getoverrun	243
+#define __NR_timer_delete	244
+#define __NR_clock_settime	245
+#define __NR_clock_gettime	246
+#define __NR_clock_getres	247
+#define __NR_clock_nanosleep	248
+#define __NR_swapcontext	249
+#define __NR_tgkill	250
+#define __NR_utimes	251
+#define __NR_statfs64	252
+#define __NR_fstatfs64	253
+#define __NR_fadvise64_64	254
+#define __NR_rtas	255
+#define __NR_sys_debug_setcontext	256
+#define __NR_migrate_pages	258
+#define __NR_mbind	259
+#define __NR_get_mempolicy	260
+#define __NR_set_mempolicy	261
+#define __NR_mq_open	262
+#define __NR_mq_unlink	263
+#define __NR_mq_timedsend	264
+#define __NR_mq_timedreceive	265
+#define __NR_mq_notify	266
+#define __NR_mq_getsetattr	267
+#define __NR_kexec_load	268
+#define __NR_add_key	269
+#define __NR_request_key	270
+#define __NR_keyctl	271
+#define __NR_waitid	272
+#define __NR_ioprio_set	273
+#define __NR_ioprio_get	274
+#define __NR_inotify_init	275
+#define __NR_inotify_add_watch	276
+#define __NR_inotify_rm_watch	277
+#define __NR_spu_run	278
+#define __NR_spu_create	279
+#define __NR_pselect6	280
+#define __NR_ppoll	281
+#define __NR_unshare	282
+#define __NR_splice	283
+#define __NR_tee	284
+#define __NR_vmsplice	285
+#define __NR_openat	286
+#define __NR_mkdirat	287
+#define __NR_mknodat	288
+#define __NR_fchownat	289
+#define __NR_futimesat	290
+#define __NR_fstatat64	291
+#define __NR_unlinkat	292
+#define __NR_renameat	293
+#define __NR_linkat	294
+#define __NR_symlinkat	295
+#define __NR_readlinkat	296
+#define __NR_fchmodat	297
+#define __NR_faccessat	298
+#define __NR_get_robust_list	299
+#define __NR_set_robust_list	300
+#define __NR_move_pages	301
+#define __NR_getcpu	302
+#define __NR_epoll_pwait	303
+#define __NR_utimensat	304
+#define __NR_signalfd	305
+#define __NR_timerfd_create	306
+#define __NR_eventfd	307
+#define __NR_sync_file_range2	308
+#define __NR_fallocate	309
+#define __NR_subpage_prot	310
+#define __NR_timerfd_settime	311
+#define __NR_timerfd_gettime	312
+#define __NR_signalfd4	313
+#define __NR_eventfd2	314
+#define __NR_epoll_create1	315
+#define __NR_dup3	316
+#define __NR_pipe2	317
+#define __NR_inotify_init1	318
+#define __NR_perf_event_open	319
+#define __NR_preadv	320
+#define __NR_pwritev	321
+#define __NR_rt_tgsigqueueinfo	322
+#define __NR_fanotify_init	323
+#define __NR_fanotify_mark	324
+#define __NR_prlimit64	325
+#define __NR_socket	326
+#define __NR_bind	327
+#define __NR_connect	328
+#define __NR_listen	329
+#define __NR_accept	330
+#define __NR_getsockname	331
+#define __NR_getpeername	332
+#define __NR_socketpair	333
+#define __NR_send	334
+#define __NR_sendto	335
+#define __NR_recv	336
+#define __NR_recvfrom	337
+#define __NR_shutdown	338
+#define __NR_setsockopt	339
+#define __NR_getsockopt	340
+#define __NR_sendmsg	341
+#define __NR_recvmsg	342
+#define __NR_recvmmsg	343
+#define __NR_accept4	344
+#define __NR_name_to_handle_at	345
+#define __NR_open_by_handle_at	346
+#define __NR_clock_adjtime	347
+#define __NR_syncfs	348
+#define __NR_sendmmsg	349
+#define __NR_setns	350
+#define __NR_process_vm_readv	351
+#define __NR_process_vm_writev	352
+#define __NR_finit_module	353
+#define __NR_kcmp	354
+#define __NR_sched_setattr	355
+#define __NR_sched_getattr	356
+#define __NR_renameat2	357
+#define __NR_seccomp	358
+#define __NR_getrandom	359
+#define __NR_memfd_create	360
+#define __NR_bpf	361
+#define __NR_execveat	362
+#define __NR_switch_endian	363
+#define __NR_userfaultfd	364
+#define __NR_membarrier	365
+#define __NR_mlock2	378
+#define __NR_copy_file_range	379
+#define __NR_preadv2	380
+#define __NR_pwritev2	381
+#define __NR_kexec_file_load	382
+#define __NR_statx	383
+#define __NR_pkey_alloc	384
+#define __NR_pkey_free	385
+#define __NR_pkey_mprotect	386
+#define __NR_rseq	387
+#define __NR_io_pgetevents	388
+#define __NR_semget	393
+#define __NR_semctl	394
+#define __NR_shmget	395
+#define __NR_shmctl	396
+#define __NR_shmat	397
+#define __NR_shmdt	398
+#define __NR_msgget	399
+#define __NR_msgsnd	400
+#define __NR_msgrcv	401
+#define __NR_msgctl	402
+#define __NR_clock_gettime64	403
+#define __NR_clock_settime64	404
+#define __NR_clock_adjtime64	405
+#define __NR_clock_getres_time64	406
+#define __NR_clock_nanosleep_time64	407
+#define __NR_timer_gettime64	408
+#define __NR_timer_settime64	409
+#define __NR_timerfd_gettime64	410
+#define __NR_timerfd_settime64	411
+#define __NR_utimensat_time64	412
+#define __NR_pselect6_time64	413
+#define __NR_ppoll_time64	414
+#define __NR_io_pgetevents_time64	416
+#define __NR_recvmmsg_time64	417
+#define __NR_mq_timedsend_time64	418
+#define __NR_mq_timedreceive_time64	419
+#define __NR_semtimedop_time64	420
+#define __NR_rt_sigtimedwait_time64	421
+#define __NR_futex_time64	422
+#define __NR_sched_rr_get_interval_time64	423
+#define __NR_pidfd_send_signal	424
+#define __NR_io_uring_setup	425
+#define __NR_io_uring_enter	426
+#define __NR_io_uring_register	427
+#define __NR_open_tree	428
+#define __NR_move_mount	429
+#define __NR_fsopen	430
+#define __NR_fsconfig	431
+#define __NR_fsmount	432
+#define __NR_fspick	433
+#define __NR_pidfd_open	434
+#define __NR_clone3	435
+#define __NR_close_range	436
+#define __NR_openat2	437
+#define __NR_pidfd_getfd	438
+#define __NR_faccessat2	439
+#define __NR_process_madvise	440
+#define __NR_epoll_pwait2	441
 
 
-#endif /* _ASM_UNISTD_32_H */
+#endif /* _ASM_POWERPC_UNISTD_32_H */
diff --git a/linux-headers/asm-powerpc/unistd_64.h b/linux-headers/asm-powerpc/unistd_64.h
index 3cefa88932..7e851b30bb 100644
--- a/linux-headers/asm-powerpc/unistd_64.h
+++ b/linux-headers/asm-powerpc/unistd_64.h
@@ -1,405 +1,401 @@
-#ifndef _ASM_UNISTD_64_H
-#define _ASM_UNISTD_64_H
+#ifndef _ASM_POWERPC_UNISTD_64_H
+#define _ASM_POWERPC_UNISTD_64_H
 
-#define __NR_restart_syscall 0
-#define __NR_exit 1
-#define __NR_fork 2
-#define __NR_read 3
-#define __NR_write 4
-#define __NR_open 5
-#define __NR_close 6
-#define __NR_waitpid 7
-#define __NR_creat 8
-#define __NR_link 9
-#define __NR_unlink 10
-#define __NR_execve 11
-#define __NR_chdir 12
-#define __NR_time 13
-#define __NR_mknod 14
-#define __NR_chmod 15
-#define __NR_lchown 16
-#define __NR_break 17
-#define __NR_oldstat 18
-#define __NR_lseek 19
-#define __NR_getpid 20
-#define __NR_mount 21
-#define __NR_umount 22
-#define __NR_setuid 23
-#define __NR_getuid 24
-#define __NR_stime 25
-#define __NR_ptrace 26
-#define __NR_alarm 27
-#define __NR_oldfstat 28
-#define __NR_pause 29
-#define __NR_utime 30
-#define __NR_stty 31
-#define __NR_gtty 32
-#define __NR_access 33
-#define __NR_nice 34
-#define __NR_ftime 35
-#define __NR_sync 36
-#define __NR_kill 37
-#define __NR_rename 38
-#define __NR_mkdir 39
-#define __NR_rmdir 40
-#define __NR_dup 41
-#define __NR_pipe 42
-#define __NR_times 43
-#define __NR_prof 44
-#define __NR_brk 45
-#define __NR_setgid 46
-#define __NR_getgid 47
-#define __NR_signal 48
-#define __NR_geteuid 49
-#define __NR_getegid 50
-#define __NR_acct 51
-#define __NR_umount2 52
-#define __NR_lock 53
-#define __NR_ioctl 54
-#define __NR_fcntl 55
-#define __NR_mpx 56
-#define __NR_setpgid 57
-#define __NR_ulimit 58
-#define __NR_oldolduname 59
-#define __NR_umask 60
-#define __NR_chroot 61
-#define __NR_ustat 62
-#define __NR_dup2 63
-#define __NR_getppid 64
-#define __NR_getpgrp 65
-#define __NR_setsid 66
-#define __NR_sigaction 67
-#define __NR_sgetmask 68
-#define __NR_ssetmask 69
-#define __NR_setreuid 70
-#define __NR_setregid 71
-#define __NR_sigsuspend 72
-#define __NR_sigpending 73
-#define __NR_sethostname 74
-#define __NR_setrlimit 75
-#define __NR_getrlimit 76
-#define __NR_getrusage 77
-#define __NR_gettimeofday 78
-#define __NR_settimeofday 79
-#define __NR_getgroups 80
-#define __NR_setgroups 81
-#define __NR_select 82
-#define __NR_symlink 83
-#define __NR_oldlstat 84
-#define __NR_readlink 85
-#define __NR_uselib 86
-#define __NR_swapon 87
-#define __NR_reboot 88
-#define __NR_readdir 89
-#define __NR_mmap 90
-#define __NR_munmap 91
-#define __NR_truncate 92
-#define __NR_ftruncate 93
-#define __NR_fchmod 94
-#define __NR_fchown 95
-#define __NR_getpriority 96
-#define __NR_setpriority 97
-#define __NR_profil 98
-#define __NR_statfs 99
-#define __NR_fstatfs 100
-#define __NR_ioperm 101
-#define __NR_socketcall 102
-#define __NR_syslog 103
-#define __NR_setitimer 104
-#define __NR_getitimer 105
-#define __NR_stat 106
-#define __NR_lstat 107
-#define __NR_fstat 108
-#define __NR_olduname 109
-#define __NR_iopl 110
-#define __NR_vhangup 111
-#define __NR_idle 112
-#define __NR_vm86 113
-#define __NR_wait4 114
-#define __NR_swapoff 115
-#define __NR_sysinfo 116
-#define __NR_ipc 117
-#define __NR_fsync 118
-#define __NR_sigreturn 119
-#define __NR_clone 120
-#define __NR_setdomainname 121
-#define __NR_uname 122
-#define __NR_modify_ldt 123
-#define __NR_adjtimex 124
-#define __NR_mprotect 125
-#define __NR_sigprocmask 126
-#define __NR_create_module 127
-#define __NR_init_module 128
-#define __NR_delete_module 129
-#define __NR_get_kernel_syms 130
-#define __NR_quotactl 131
-#define __NR_getpgid 132
-#define __NR_fchdir 133
-#define __NR_bdflush 134
-#define __NR_sysfs 135
-#define __NR_personality 136
-#define __NR_afs_syscall 137
-#define __NR_setfsuid 138
-#define __NR_setfsgid 139
-#define __NR__llseek 140
-#define __NR_getdents 141
-#define __NR__newselect 142
-#define __NR_flock 143
-#define __NR_msync 144
-#define __NR_readv 145
-#define __NR_writev 146
-#define __NR_getsid 147
-#define __NR_fdatasync 148
-#define __NR__sysctl 149
-#define __NR_mlock 150
-#define __NR_munlock 151
-#define __NR_mlockall 152
-#define __NR_munlockall 153
-#define __NR_sched_setparam 154
-#define __NR_sched_getparam 155
-#define __NR_sched_setscheduler 156
-#define __NR_sched_getscheduler 157
-#define __NR_sched_yield 158
-#define __NR_sched_get_priority_max 159
-#define __NR_sched_get_priority_min 160
-#define __NR_sched_rr_get_interval 161
-#define __NR_nanosleep 162
-#define __NR_mremap 163
-#define __NR_setresuid 164
-#define __NR_getresuid 165
-#define __NR_query_module 166
-#define __NR_poll 167
-#define __NR_nfsservctl 168
-#define __NR_setresgid 169
-#define __NR_getresgid 170
-#define __NR_prctl 171
-#define __NR_rt_sigreturn 172
-#define __NR_rt_sigaction 173
-#define __NR_rt_sigprocmask 174
-#define __NR_rt_sigpending 175
-#define __NR_rt_sigtimedwait 176
-#define __NR_rt_sigqueueinfo 177
-#define __NR_rt_sigsuspend 178
-#define __NR_pread64 179
-#define __NR_pwrite64 180
-#define __NR_chown 181
-#define __NR_getcwd 182
-#define __NR_capget 183
-#define __NR_capset 184
-#define __NR_sigaltstack 185
-#define __NR_sendfile 186
-#define __NR_getpmsg 187
-#define __NR_putpmsg 188
-#define __NR_vfork 189
-#define __NR_ugetrlimit 190
-#define __NR_readahead 191
-#define __NR_pciconfig_read 198
-#define __NR_pciconfig_write 199
-#define __NR_pciconfig_iobase 200
-#define __NR_multiplexer 201
-#define __NR_getdents64 202
-#define __NR_pivot_root 203
-#define __NR_madvise 205
-#define __NR_mincore 206
-#define __NR_gettid 207
-#define __NR_tkill 208
-#define __NR_setxattr 209
-#define __NR_lsetxattr 210
-#define __NR_fsetxattr 211
-#define __NR_getxattr 212
-#define __NR_lgetxattr 213
-#define __NR_fgetxattr 214
-#define __NR_listxattr 215
-#define __NR_llistxattr 216
-#define __NR_flistxattr 217
-#define __NR_removexattr 218
-#define __NR_lremovexattr 219
-#define __NR_fremovexattr 220
-#define __NR_futex 221
-#define __NR_sched_setaffinity 222
-#define __NR_sched_getaffinity 223
-#define __NR_tuxcall 225
-#define __NR_io_setup 227
-#define __NR_io_destroy 228
-#define __NR_io_getevents 229
-#define __NR_io_submit 230
-#define __NR_io_cancel 231
-#define __NR_set_tid_address 232
-#define __NR_fadvise64 233
-#define __NR_exit_group 234
-#define __NR_lookup_dcookie 235
-#define __NR_epoll_create 236
-#define __NR_epoll_ctl 237
-#define __NR_epoll_wait 238
-#define __NR_remap_file_pages 239
-#define __NR_timer_create 240
-#define __NR_timer_settime 241
-#define __NR_timer_gettime 242
-#define __NR_timer_getoverrun 243
-#define __NR_timer_delete 244
-#define __NR_clock_settime 245
-#define __NR_clock_gettime 246
-#define __NR_clock_getres 247
-#define __NR_clock_nanosleep 248
-#define __NR_swapcontext 249
-#define __NR_tgkill 250
-#define __NR_utimes 251
-#define __NR_statfs64 252
-#define __NR_fstatfs64 253
-#define __NR_rtas 255
-#define __NR_sys_debug_setcontext 256
-#define __NR_migrate_pages 258
-#define __NR_mbind 259
-#define __NR_get_mempolicy 260
-#define __NR_set_mempolicy 261
-#define __NR_mq_open 262
-#define __NR_mq_unlink 263
-#define __NR_mq_timedsend 264
-#define __NR_mq_timedreceive 265
-#define __NR_mq_notify 266
-#define __NR_mq_getsetattr 267
-#define __NR_kexec_load 268
-#define __NR_add_key 269
-#define __NR_request_key 270
-#define __NR_keyctl 271
-#define __NR_waitid 272
-#define __NR_ioprio_set 273
-#define __NR_ioprio_get 274
-#define __NR_inotify_init 275
-#define __NR_inotify_add_watch 276
-#define __NR_inotify_rm_watch 277
-#define __NR_spu_run 278
-#define __NR_spu_create 279
-#define __NR_pselect6 280
-#define __NR_ppoll 281
-#define __NR_unshare 282
-#define __NR_splice 283
-#define __NR_tee 284
-#define __NR_vmsplice 285
-#define __NR_openat 286
-#define __NR_mkdirat 287
-#define __NR_mknodat 288
-#define __NR_fchownat 289
-#define __NR_futimesat 290
-#define __NR_newfstatat 291
-#define __NR_unlinkat 292
-#define __NR_renameat 293
-#define __NR_linkat 294
-#define __NR_symlinkat 295
-#define __NR_readlinkat 296
-#define __NR_fchmodat 297
-#define __NR_faccessat 298
-#define __NR_get_robust_list 299
-#define __NR_set_robust_list 300
-#define __NR_move_pages 301
-#define __NR_getcpu 302
-#define __NR_epoll_pwait 303
-#define __NR_utimensat 304
-#define __NR_signalfd 305
-#define __NR_timerfd_create 306
-#define __NR_eventfd 307
-#define __NR_sync_file_range2 308
-#define __NR_fallocate 309
-#define __NR_subpage_prot 310
-#define __NR_timerfd_settime 311
-#define __NR_timerfd_gettime 312
-#define __NR_signalfd4 313
-#define __NR_eventfd2 314
-#define __NR_epoll_create1 315
-#define __NR_dup3 316
-#define __NR_pipe2 317
-#define __NR_inotify_init1 318
-#define __NR_perf_event_open 319
-#define __NR_preadv 320
-#define __NR_pwritev 321
-#define __NR_rt_tgsigqueueinfo 322
-#define __NR_fanotify_init 323
-#define __NR_fanotify_mark 324
-#define __NR_prlimit64 325
-#define __NR_socket 326
-#define __NR_bind 327
-#define __NR_connect 328
-#define __NR_listen 329
-#define __NR_accept 330
-#define __NR_getsockname 331
-#define __NR_getpeername 332
-#define __NR_socketpair 333
-#define __NR_send 334
-#define __NR_sendto 335
-#define __NR_recv 336
-#define __NR_recvfrom 337
-#define __NR_shutdown 338
-#define __NR_setsockopt 339
-#define __NR_getsockopt 340
-#define __NR_sendmsg 341
-#define __NR_recvmsg 342
-#define __NR_recvmmsg 343
-#define __NR_accept4 344
-#define __NR_name_to_handle_at 345
-#define __NR_open_by_handle_at 346
-#define __NR_clock_adjtime 347
-#define __NR_syncfs 348
-#define __NR_sendmmsg 349
-#define __NR_setns 350
-#define __NR_process_vm_readv 351
-#define __NR_process_vm_writev 352
-#define __NR_finit_module 353
-#define __NR_kcmp 354
-#define __NR_sched_setattr 355
-#define __NR_sched_getattr 356
-#define __NR_renameat2 357
-#define __NR_seccomp 358
-#define __NR_getrandom 359
-#define __NR_memfd_create 360
-#define __NR_bpf 361
-#define __NR_execveat 362
-#define __NR_switch_endian 363
-#define __NR_userfaultfd 364
-#define __NR_membarrier 365
-#define __NR_mlock2 378
-#define __NR_copy_file_range 379
-#define __NR_preadv2 380
-#define __NR_pwritev2 381
-#define __NR_kexec_file_load 382
-#define __NR_statx 383
-#define __NR_pkey_alloc 384
-#define __NR_pkey_free 385
-#define __NR_pkey_mprotect 386
-#define __NR_rseq 387
-#define __NR_io_pgetevents 388
-#define __NR_semtimedop 392
-#define __NR_semget 393
-#define __NR_semctl 394
-#define __NR_shmget 395
-#define __NR_shmctl 396
-#define __NR_shmat 397
-#define __NR_shmdt 398
-#define __NR_msgget 399
-#define __NR_msgsnd 400
-#define __NR_msgrcv 401
-#define __NR_msgctl 402
-#define __NR_pidfd_send_signal 424
-#define __NR_io_uring_setup 425
-#define __NR_io_uring_enter 426
-#define __NR_io_uring_register 427
-#define __NR_open_tree 428
-#define __NR_move_mount 429
-#define __NR_fsopen 430
-#define __NR_fsconfig 431
-#define __NR_fsmount 432
-#define __NR_fspick 433
-#define __NR_pidfd_open 434
-#define __NR_clone3 435
-#define __NR_close_range 436
-#define __NR_openat2 437
-#define __NR_pidfd_getfd 438
-#define __NR_faccessat2 439
-#define __NR_process_madvise 440
-#define __NR_epoll_pwait2 441
-#define __NR_mount_setattr 442
-#define __NR_landlock_create_ruleset 444
-#define __NR_landlock_add_rule 445
-#define __NR_landlock_restrict_self 446
+#define __NR_restart_syscall	0
+#define __NR_exit	1
+#define __NR_fork	2
+#define __NR_read	3
+#define __NR_write	4
+#define __NR_open	5
+#define __NR_close	6
+#define __NR_waitpid	7
+#define __NR_creat	8
+#define __NR_link	9
+#define __NR_unlink	10
+#define __NR_execve	11
+#define __NR_chdir	12
+#define __NR_time	13
+#define __NR_mknod	14
+#define __NR_chmod	15
+#define __NR_lchown	16
+#define __NR_break	17
+#define __NR_oldstat	18
+#define __NR_lseek	19
+#define __NR_getpid	20
+#define __NR_mount	21
+#define __NR_umount	22
+#define __NR_setuid	23
+#define __NR_getuid	24
+#define __NR_stime	25
+#define __NR_ptrace	26
+#define __NR_alarm	27
+#define __NR_oldfstat	28
+#define __NR_pause	29
+#define __NR_utime	30
+#define __NR_stty	31
+#define __NR_gtty	32
+#define __NR_access	33
+#define __NR_nice	34
+#define __NR_ftime	35
+#define __NR_sync	36
+#define __NR_kill	37
+#define __NR_rename	38
+#define __NR_mkdir	39
+#define __NR_rmdir	40
+#define __NR_dup	41
+#define __NR_pipe	42
+#define __NR_times	43
+#define __NR_prof	44
+#define __NR_brk	45
+#define __NR_setgid	46
+#define __NR_getgid	47
+#define __NR_signal	48
+#define __NR_geteuid	49
+#define __NR_getegid	50
+#define __NR_acct	51
+#define __NR_umount2	52
+#define __NR_lock	53
+#define __NR_ioctl	54
+#define __NR_fcntl	55
+#define __NR_mpx	56
+#define __NR_setpgid	57
+#define __NR_ulimit	58
+#define __NR_oldolduname	59
+#define __NR_umask	60
+#define __NR_chroot	61
+#define __NR_ustat	62
+#define __NR_dup2	63
+#define __NR_getppid	64
+#define __NR_getpgrp	65
+#define __NR_setsid	66
+#define __NR_sigaction	67
+#define __NR_sgetmask	68
+#define __NR_ssetmask	69
+#define __NR_setreuid	70
+#define __NR_setregid	71
+#define __NR_sigsuspend	72
+#define __NR_sigpending	73
+#define __NR_sethostname	74
+#define __NR_setrlimit	75
+#define __NR_getrlimit	76
+#define __NR_getrusage	77
+#define __NR_gettimeofday	78
+#define __NR_settimeofday	79
+#define __NR_getgroups	80
+#define __NR_setgroups	81
+#define __NR_select	82
+#define __NR_symlink	83
+#define __NR_oldlstat	84
+#define __NR_readlink	85
+#define __NR_uselib	86
+#define __NR_swapon	87
+#define __NR_reboot	88
+#define __NR_readdir	89
+#define __NR_mmap	90
+#define __NR_munmap	91
+#define __NR_truncate	92
+#define __NR_ftruncate	93
+#define __NR_fchmod	94
+#define __NR_fchown	95
+#define __NR_getpriority	96
+#define __NR_setpriority	97
+#define __NR_profil	98
+#define __NR_statfs	99
+#define __NR_fstatfs	100
+#define __NR_ioperm	101
+#define __NR_socketcall	102
+#define __NR_syslog	103
+#define __NR_setitimer	104
+#define __NR_getitimer	105
+#define __NR_stat	106
+#define __NR_lstat	107
+#define __NR_fstat	108
+#define __NR_olduname	109
+#define __NR_iopl	110
+#define __NR_vhangup	111
+#define __NR_idle	112
+#define __NR_vm86	113
+#define __NR_wait4	114
+#define __NR_swapoff	115
+#define __NR_sysinfo	116
+#define __NR_ipc	117
+#define __NR_fsync	118
+#define __NR_sigreturn	119
+#define __NR_clone	120
+#define __NR_setdomainname	121
+#define __NR_uname	122
+#define __NR_modify_ldt	123
+#define __NR_adjtimex	124
+#define __NR_mprotect	125
+#define __NR_sigprocmask	126
+#define __NR_create_module	127
+#define __NR_init_module	128
+#define __NR_delete_module	129
+#define __NR_get_kernel_syms	130
+#define __NR_quotactl	131
+#define __NR_getpgid	132
+#define __NR_fchdir	133
+#define __NR_bdflush	134
+#define __NR_sysfs	135
+#define __NR_personality	136
+#define __NR_afs_syscall	137
+#define __NR_setfsuid	138
+#define __NR_setfsgid	139
+#define __NR__llseek	140
+#define __NR_getdents	141
+#define __NR__newselect	142
+#define __NR_flock	143
+#define __NR_msync	144
+#define __NR_readv	145
+#define __NR_writev	146
+#define __NR_getsid	147
+#define __NR_fdatasync	148
+#define __NR__sysctl	149
+#define __NR_mlock	150
+#define __NR_munlock	151
+#define __NR_mlockall	152
+#define __NR_munlockall	153
+#define __NR_sched_setparam	154
+#define __NR_sched_getparam	155
+#define __NR_sched_setscheduler	156
+#define __NR_sched_getscheduler	157
+#define __NR_sched_yield	158
+#define __NR_sched_get_priority_max	159
+#define __NR_sched_get_priority_min	160
+#define __NR_sched_rr_get_interval	161
+#define __NR_nanosleep	162
+#define __NR_mremap	163
+#define __NR_setresuid	164
+#define __NR_getresuid	165
+#define __NR_query_module	166
+#define __NR_poll	167
+#define __NR_nfsservctl	168
+#define __NR_setresgid	169
+#define __NR_getresgid	170
+#define __NR_prctl	171
+#define __NR_rt_sigreturn	172
+#define __NR_rt_sigaction	173
+#define __NR_rt_sigprocmask	174
+#define __NR_rt_sigpending	175
+#define __NR_rt_sigtimedwait	176
+#define __NR_rt_sigqueueinfo	177
+#define __NR_rt_sigsuspend	178
+#define __NR_pread64	179
+#define __NR_pwrite64	180
+#define __NR_chown	181
+#define __NR_getcwd	182
+#define __NR_capget	183
+#define __NR_capset	184
+#define __NR_sigaltstack	185
+#define __NR_sendfile	186
+#define __NR_getpmsg	187
+#define __NR_putpmsg	188
+#define __NR_vfork	189
+#define __NR_ugetrlimit	190
+#define __NR_readahead	191
+#define __NR_pciconfig_read	198
+#define __NR_pciconfig_write	199
+#define __NR_pciconfig_iobase	200
+#define __NR_multiplexer	201
+#define __NR_getdents64	202
+#define __NR_pivot_root	203
+#define __NR_madvise	205
+#define __NR_mincore	206
+#define __NR_gettid	207
+#define __NR_tkill	208
+#define __NR_setxattr	209
+#define __NR_lsetxattr	210
+#define __NR_fsetxattr	211
+#define __NR_getxattr	212
+#define __NR_lgetxattr	213
+#define __NR_fgetxattr	214
+#define __NR_listxattr	215
+#define __NR_llistxattr	216
+#define __NR_flistxattr	217
+#define __NR_removexattr	218
+#define __NR_lremovexattr	219
+#define __NR_fremovexattr	220
+#define __NR_futex	221
+#define __NR_sched_setaffinity	222
+#define __NR_sched_getaffinity	223
+#define __NR_tuxcall	225
+#define __NR_io_setup	227
+#define __NR_io_destroy	228
+#define __NR_io_getevents	229
+#define __NR_io_submit	230
+#define __NR_io_cancel	231
+#define __NR_set_tid_address	232
+#define __NR_fadvise64	233
+#define __NR_exit_group	234
+#define __NR_lookup_dcookie	235
+#define __NR_epoll_create	236
+#define __NR_epoll_ctl	237
+#define __NR_epoll_wait	238
+#define __NR_remap_file_pages	239
+#define __NR_timer_create	240
+#define __NR_timer_settime	241
+#define __NR_timer_gettime	242
+#define __NR_timer_getoverrun	243
+#define __NR_timer_delete	244
+#define __NR_clock_settime	245
+#define __NR_clock_gettime	246
+#define __NR_clock_getres	247
+#define __NR_clock_nanosleep	248
+#define __NR_swapcontext	249
+#define __NR_tgkill	250
+#define __NR_utimes	251
+#define __NR_statfs64	252
+#define __NR_fstatfs64	253
+#define __NR_rtas	255
+#define __NR_sys_debug_setcontext	256
+#define __NR_migrate_pages	258
+#define __NR_mbind	259
+#define __NR_get_mempolicy	260
+#define __NR_set_mempolicy	261
+#define __NR_mq_open	262
+#define __NR_mq_unlink	263
+#define __NR_mq_timedsend	264
+#define __NR_mq_timedreceive	265
+#define __NR_mq_notify	266
+#define __NR_mq_getsetattr	267
+#define __NR_kexec_load	268
+#define __NR_add_key	269
+#define __NR_request_key	270
+#define __NR_keyctl	271
+#define __NR_waitid	272
+#define __NR_ioprio_set	273
+#define __NR_ioprio_get	274
+#define __NR_inotify_init	275
+#define __NR_inotify_add_watch	276
+#define __NR_inotify_rm_watch	277
+#define __NR_spu_run	278
+#define __NR_spu_create	279
+#define __NR_pselect6	280
+#define __NR_ppoll	281
+#define __NR_unshare	282
+#define __NR_splice	283
+#define __NR_tee	284
+#define __NR_vmsplice	285
+#define __NR_openat	286
+#define __NR_mkdirat	287
+#define __NR_mknodat	288
+#define __NR_fchownat	289
+#define __NR_futimesat	290
+#define __NR_newfstatat	291
+#define __NR_unlinkat	292
+#define __NR_renameat	293
+#define __NR_linkat	294
+#define __NR_symlinkat	295
+#define __NR_readlinkat	296
+#define __NR_fchmodat	297
+#define __NR_faccessat	298
+#define __NR_get_robust_list	299
+#define __NR_set_robust_list	300
+#define __NR_move_pages	301
+#define __NR_getcpu	302
+#define __NR_epoll_pwait	303
+#define __NR_utimensat	304
+#define __NR_signalfd	305
+#define __NR_timerfd_create	306
+#define __NR_eventfd	307
+#define __NR_sync_file_range2	308
+#define __NR_fallocate	309
+#define __NR_subpage_prot	310
+#define __NR_timerfd_settime	311
+#define __NR_timerfd_gettime	312
+#define __NR_signalfd4	313
+#define __NR_eventfd2	314
+#define __NR_epoll_create1	315
+#define __NR_dup3	316
+#define __NR_pipe2	317
+#define __NR_inotify_init1	318
+#define __NR_perf_event_open	319
+#define __NR_preadv	320
+#define __NR_pwritev	321
+#define __NR_rt_tgsigqueueinfo	322
+#define __NR_fanotify_init	323
+#define __NR_fanotify_mark	324
+#define __NR_prlimit64	325
+#define __NR_socket	326
+#define __NR_bind	327
+#define __NR_connect	328
+#define __NR_listen	329
+#define __NR_accept	330
+#define __NR_getsockname	331
+#define __NR_getpeername	332
+#define __NR_socketpair	333
+#define __NR_send	334
+#define __NR_sendto	335
+#define __NR_recv	336
+#define __NR_recvfrom	337
+#define __NR_shutdown	338
+#define __NR_setsockopt	339
+#define __NR_getsockopt	340
+#define __NR_sendmsg	341
+#define __NR_recvmsg	342
+#define __NR_recvmmsg	343
+#define __NR_accept4	344
+#define __NR_name_to_handle_at	345
+#define __NR_open_by_handle_at	346
+#define __NR_clock_adjtime	347
+#define __NR_syncfs	348
+#define __NR_sendmmsg	349
+#define __NR_setns	350
+#define __NR_process_vm_readv	351
+#define __NR_process_vm_writev	352
+#define __NR_finit_module	353
+#define __NR_kcmp	354
+#define __NR_sched_setattr	355
+#define __NR_sched_getattr	356
+#define __NR_renameat2	357
+#define __NR_seccomp	358
+#define __NR_getrandom	359
+#define __NR_memfd_create	360
+#define __NR_bpf	361
+#define __NR_execveat	362
+#define __NR_switch_endian	363
+#define __NR_userfaultfd	364
+#define __NR_membarrier	365
+#define __NR_mlock2	378
+#define __NR_copy_file_range	379
+#define __NR_preadv2	380
+#define __NR_pwritev2	381
+#define __NR_kexec_file_load	382
+#define __NR_statx	383
+#define __NR_pkey_alloc	384
+#define __NR_pkey_free	385
+#define __NR_pkey_mprotect	386
+#define __NR_rseq	387
+#define __NR_io_pgetevents	388
+#define __NR_semtimedop	392
+#define __NR_semget	393
+#define __NR_semctl	394
+#define __NR_shmget	395
+#define __NR_shmctl	396
+#define __NR_shmat	397
+#define __NR_shmdt	398
+#define __NR_msgget	399
+#define __NR_msgsnd	400
+#define __NR_msgrcv	401
+#define __NR_msgctl	402
+#define __NR_pidfd_send_signal	424
+#define __NR_io_uring_setup	425
+#define __NR_io_uring_enter	426
+#define __NR_io_uring_register	427
+#define __NR_open_tree	428
+#define __NR_move_mount	429
+#define __NR_fsopen	430
+#define __NR_fsconfig	431
+#define __NR_fsmount	432
+#define __NR_fspick	433
+#define __NR_pidfd_open	434
+#define __NR_clone3	435
+#define __NR_close_range	436
+#define __NR_openat2	437
+#define __NR_pidfd_getfd	438
+#define __NR_faccessat2	439
+#define __NR_process_madvise	440
+#define __NR_epoll_pwait2	441
 
 
-#endif /* _ASM_UNISTD_64_H */
+#endif /* _ASM_POWERPC_UNISTD_64_H */
diff --git a/linux-headers/asm-s390/unistd_32.h b/linux-headers/asm-s390/unistd_32.h
index e8cd34334f..c94d2c3a22 100644
--- a/linux-headers/asm-s390/unistd_32.h
+++ b/linux-headers/asm-s390/unistd_32.h
@@ -414,9 +414,5 @@
 #define __NR_faccessat2 439
 #define __NR_process_madvise 440
 #define __NR_epoll_pwait2 441
-#define __NR_mount_setattr 442
-#define __NR_landlock_create_ruleset 444
-#define __NR_landlock_add_rule 445
-#define __NR_landlock_restrict_self 446
 
 #endif /* _ASM_S390_UNISTD_32_H */
diff --git a/linux-headers/asm-s390/unistd_64.h b/linux-headers/asm-s390/unistd_64.h
index 86830e1e83..984a06b7eb 100644
--- a/linux-headers/asm-s390/unistd_64.h
+++ b/linux-headers/asm-s390/unistd_64.h
@@ -362,9 +362,5 @@
 #define __NR_faccessat2 439
 #define __NR_process_madvise 440
 #define __NR_epoll_pwait2 441
-#define __NR_mount_setattr 442
-#define __NR_landlock_create_ruleset 444
-#define __NR_landlock_add_rule 445
-#define __NR_landlock_restrict_self 446
 
 #endif /* _ASM_S390_UNISTD_64_H */
diff --git a/linux-headers/asm-x86/kvm.h b/linux-headers/asm-x86/kvm.h
index 0662f644aa..8e76d3701d 100644
--- a/linux-headers/asm-x86/kvm.h
+++ b/linux-headers/asm-x86/kvm.h
@@ -112,7 +112,6 @@ struct kvm_ioapic_state {
 #define KVM_NR_IRQCHIPS          3
 
 #define KVM_RUN_X86_SMM		 (1 << 0)
-#define KVM_RUN_X86_BUS_LOCK     (1 << 1)
 
 /* for KVM_GET_REGS and KVM_SET_REGS */
 struct kvm_regs {
@@ -437,8 +436,6 @@ struct kvm_vmx_nested_state_hdr {
 		__u16 flags;
 	} smm;
 
-	__u16 pad;
-
 	__u32 flags;
 	__u64 preemption_timer_deadline;
 };
diff --git a/linux-headers/asm-x86/unistd_32.h b/linux-headers/asm-x86/unistd_32.h
index 8f6ac8c19f..18fb99dfa2 100644
--- a/linux-headers/asm-x86/unistd_32.h
+++ b/linux-headers/asm-x86/unistd_32.h
@@ -432,10 +432,6 @@
 #define __NR_faccessat2 439
 #define __NR_process_madvise 440
 #define __NR_epoll_pwait2 441
-#define __NR_mount_setattr 442
-#define __NR_landlock_create_ruleset 444
-#define __NR_landlock_add_rule 445
-#define __NR_landlock_restrict_self 446
 
 
 #endif /* _ASM_X86_UNISTD_32_H */
diff --git a/linux-headers/asm-x86/unistd_64.h b/linux-headers/asm-x86/unistd_64.h
index bb187a9268..bde959328d 100644
--- a/linux-headers/asm-x86/unistd_64.h
+++ b/linux-headers/asm-x86/unistd_64.h
@@ -354,10 +354,6 @@
 #define __NR_faccessat2 439
 #define __NR_process_madvise 440
 #define __NR_epoll_pwait2 441
-#define __NR_mount_setattr 442
-#define __NR_landlock_create_ruleset 444
-#define __NR_landlock_add_rule 445
-#define __NR_landlock_restrict_self 446
 
 
 #endif /* _ASM_X86_UNISTD_64_H */
diff --git a/linux-headers/asm-x86/unistd_x32.h b/linux-headers/asm-x86/unistd_x32.h
index 4edd0103ac..4ff6b17d3b 100644
--- a/linux-headers/asm-x86/unistd_x32.h
+++ b/linux-headers/asm-x86/unistd_x32.h
@@ -307,10 +307,6 @@
 #define __NR_faccessat2 (__X32_SYSCALL_BIT + 439)
 #define __NR_process_madvise (__X32_SYSCALL_BIT + 440)
 #define __NR_epoll_pwait2 (__X32_SYSCALL_BIT + 441)
-#define __NR_mount_setattr (__X32_SYSCALL_BIT + 442)
-#define __NR_landlock_create_ruleset (__X32_SYSCALL_BIT + 444)
-#define __NR_landlock_add_rule (__X32_SYSCALL_BIT + 445)
-#define __NR_landlock_restrict_self (__X32_SYSCALL_BIT + 446)
 #define __NR_rt_sigaction (__X32_SYSCALL_BIT + 512)
 #define __NR_rt_sigreturn (__X32_SYSCALL_BIT + 513)
 #define __NR_ioctl (__X32_SYSCALL_BIT + 514)
diff --git a/linux-headers/linux/kvm.h b/linux-headers/linux/kvm.h
index 20d6a263bb..897f831374 100644
--- a/linux-headers/linux/kvm.h
+++ b/linux-headers/linux/kvm.h
@@ -8,7 +8,6 @@
  * Note: you must update KVM_API_VERSION if you change this interface.
  */
 
-#include <linux/const.h>
 #include <linux/types.h>
 
 #include <linux/ioctl.h>
@@ -217,20 +216,6 @@ struct kvm_hyperv_exit {
 	} u;
 };
 
-struct kvm_xen_exit {
-#define KVM_EXIT_XEN_HCALL          1
-	__u32 type;
-	union {
-		struct {
-			__u32 longmode;
-			__u32 cpl;
-			__u64 input;
-			__u64 result;
-			__u64 params[6];
-		} hcall;
-	} u;
-};
-
 #define KVM_S390_GET_SKEYS_NONE   1
 #define KVM_S390_SKEYS_MAX        1048576
 
@@ -266,9 +251,6 @@ struct kvm_xen_exit {
 #define KVM_EXIT_X86_RDMSR        29
 #define KVM_EXIT_X86_WRMSR        30
 #define KVM_EXIT_DIRTY_RING_FULL  31
-#define KVM_EXIT_AP_RESET_HOLD    32
-#define KVM_EXIT_X86_BUS_LOCK     33
-#define KVM_EXIT_XEN              34
 
 /* For KVM_EXIT_INTERNAL_ERROR */
 /* Emulate instruction failed. */
@@ -445,8 +427,6 @@ struct kvm_run {
 			__u32 index; /* kernel -> user */
 			__u64 data; /* kernel <-> user */
 		} msr;
-		/* KVM_EXIT_XEN */
-		struct kvm_xen_exit xen;
 		/* Fix the size of the union. */
 		char padding[256];
 	};
@@ -593,7 +573,6 @@ struct kvm_vapic_addr {
 #define KVM_MP_STATE_CHECK_STOP        6
 #define KVM_MP_STATE_OPERATING         7
 #define KVM_MP_STATE_LOAD              8
-#define KVM_MP_STATE_AP_RESET_HOLD     9
 
 struct kvm_mp_state {
 	__u32 mp_state;
@@ -1077,12 +1056,6 @@ struct kvm_ppc_resize_hpt {
 #define KVM_CAP_ENFORCE_PV_FEATURE_CPUID 190
 #define KVM_CAP_SYS_HYPERV_CPUID 191
 #define KVM_CAP_DIRTY_LOG_RING 192
-#define KVM_CAP_X86_BUS_LOCK_EXIT 193
-#define KVM_CAP_PPC_DAWR1 194
-#define KVM_CAP_SET_GUEST_DEBUG2 195
-#define KVM_CAP_SGX_ATTRIBUTE 196
-#define KVM_CAP_VM_COPY_ENC_CONTEXT_FROM 197
-#define KVM_CAP_PTP_KVM 198
 
 #ifdef KVM_CAP_IRQ_ROUTING
 
@@ -1156,11 +1129,6 @@ struct kvm_x86_mce {
 #endif
 
 #ifdef KVM_CAP_XEN_HVM
-#define KVM_XEN_HVM_CONFIG_HYPERCALL_MSR	(1 << 0)
-#define KVM_XEN_HVM_CONFIG_INTERCEPT_HCALL	(1 << 1)
-#define KVM_XEN_HVM_CONFIG_SHARED_INFO		(1 << 2)
-#define KVM_XEN_HVM_CONFIG_RUNSTATE		(1 << 3)
-
 struct kvm_xen_hvm_config {
 	__u32 flags;
 	__u32 msr;
@@ -1595,57 +1563,6 @@ struct kvm_pv_cmd {
 /* Available with KVM_CAP_DIRTY_LOG_RING */
 #define KVM_RESET_DIRTY_RINGS		_IO(KVMIO, 0xc7)
 
-/* Per-VM Xen attributes */
-#define KVM_XEN_HVM_GET_ATTR	_IOWR(KVMIO, 0xc8, struct kvm_xen_hvm_attr)
-#define KVM_XEN_HVM_SET_ATTR	_IOW(KVMIO,  0xc9, struct kvm_xen_hvm_attr)
-
-struct kvm_xen_hvm_attr {
-	__u16 type;
-	__u16 pad[3];
-	union {
-		__u8 long_mode;
-		__u8 vector;
-		struct {
-			__u64 gfn;
-		} shared_info;
-		__u64 pad[8];
-	} u;
-};
-
-/* Available with KVM_CAP_XEN_HVM / KVM_XEN_HVM_CONFIG_SHARED_INFO */
-#define KVM_XEN_ATTR_TYPE_LONG_MODE		0x0
-#define KVM_XEN_ATTR_TYPE_SHARED_INFO		0x1
-#define KVM_XEN_ATTR_TYPE_UPCALL_VECTOR		0x2
-
-/* Per-vCPU Xen attributes */
-#define KVM_XEN_VCPU_GET_ATTR	_IOWR(KVMIO, 0xca, struct kvm_xen_vcpu_attr)
-#define KVM_XEN_VCPU_SET_ATTR	_IOW(KVMIO,  0xcb, struct kvm_xen_vcpu_attr)
-
-struct kvm_xen_vcpu_attr {
-	__u16 type;
-	__u16 pad[3];
-	union {
-		__u64 gpa;
-		__u64 pad[8];
-		struct {
-			__u64 state;
-			__u64 state_entry_time;
-			__u64 time_running;
-			__u64 time_runnable;
-			__u64 time_blocked;
-			__u64 time_offline;
-		} runstate;
-	} u;
-};
-
-/* Available with KVM_CAP_XEN_HVM / KVM_XEN_HVM_CONFIG_SHARED_INFO */
-#define KVM_XEN_VCPU_ATTR_TYPE_VCPU_INFO	0x0
-#define KVM_XEN_VCPU_ATTR_TYPE_VCPU_TIME_INFO	0x1
-#define KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADDR	0x2
-#define KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_CURRENT	0x3
-#define KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_DATA	0x4
-#define KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADJUST	0x5
-
 /* Secure Encrypted Virtualization command */
 enum sev_cmd_id {
 	/* Guest initialization commands */
@@ -1676,8 +1593,6 @@ enum sev_cmd_id {
 	KVM_SEV_CERT_EXPORT,
 	/* Attestation report */
 	KVM_SEV_GET_ATTESTATION_REPORT,
-	/* Guest Migration Extension */
-	KVM_SEV_SEND_CANCEL,
 
 	KVM_SEV_NR_MAX,
 };
@@ -1736,45 +1651,6 @@ struct kvm_sev_attestation_report {
 	__u32 len;
 };
 
-struct kvm_sev_send_start {
-	__u32 policy;
-	__u64 pdh_cert_uaddr;
-	__u32 pdh_cert_len;
-	__u64 plat_certs_uaddr;
-	__u32 plat_certs_len;
-	__u64 amd_certs_uaddr;
-	__u32 amd_certs_len;
-	__u64 session_uaddr;
-	__u32 session_len;
-};
-
-struct kvm_sev_send_update_data {
-	__u64 hdr_uaddr;
-	__u32 hdr_len;
-	__u64 guest_uaddr;
-	__u32 guest_len;
-	__u64 trans_uaddr;
-	__u32 trans_len;
-};
-
-struct kvm_sev_receive_start {
-	__u32 handle;
-	__u32 policy;
-	__u64 pdh_uaddr;
-	__u32 pdh_len;
-	__u64 session_uaddr;
-	__u32 session_len;
-};
-
-struct kvm_sev_receive_update_data {
-	__u64 hdr_uaddr;
-	__u32 hdr_len;
-	__u64 guest_uaddr;
-	__u32 guest_len;
-	__u64 trans_uaddr;
-	__u32 trans_len;
-};
-
 #define KVM_DEV_ASSIGN_ENABLE_IOMMU	(1 << 0)
 #define KVM_DEV_ASSIGN_PCI_2_3		(1 << 1)
 #define KVM_DEV_ASSIGN_MASK_INTX	(1 << 2)
@@ -1880,8 +1756,8 @@ struct kvm_hyperv_eventfd {
  * conversion after harvesting an entry.  Also, it must not skip any
  * dirty bits, so that dirty bits are always harvested in sequence.
  */
-#define KVM_DIRTY_GFN_F_DIRTY           _BITUL(0)
-#define KVM_DIRTY_GFN_F_RESET           _BITUL(1)
+#define KVM_DIRTY_GFN_F_DIRTY           BIT(0)
+#define KVM_DIRTY_GFN_F_RESET           BIT(1)
 #define KVM_DIRTY_GFN_F_MASK            0x3
 
 /*
@@ -1896,7 +1772,4 @@ struct kvm_dirty_gfn {
 	__u64 offset;
 };
 
-#define KVM_BUS_LOCK_DETECTION_OFF             (1 << 0)
-#define KVM_BUS_LOCK_DETECTION_EXIT            (1 << 1)
-
 #endif /* __LINUX_KVM_H */
diff --git a/linux-headers/linux/userfaultfd.h b/linux-headers/linux/userfaultfd.h
index b9ac97b70f..1ba9a9feeb 100644
--- a/linux-headers/linux/userfaultfd.h
+++ b/linux-headers/linux/userfaultfd.h
@@ -19,19 +19,15 @@
  * means the userland is reading).
  */
 #define UFFD_API ((__u64)0xAA)
-#define UFFD_API_REGISTER_MODES (UFFDIO_REGISTER_MODE_MISSING |	\
-				 UFFDIO_REGISTER_MODE_WP |	\
-				 UFFDIO_REGISTER_MODE_MINOR)
 #define UFFD_API_FEATURES (UFFD_FEATURE_PAGEFAULT_FLAG_WP |	\
 			   UFFD_FEATURE_EVENT_FORK |		\
 			   UFFD_FEATURE_EVENT_REMAP |		\
-			   UFFD_FEATURE_EVENT_REMOVE |		\
+			   UFFD_FEATURE_EVENT_REMOVE |	\
 			   UFFD_FEATURE_EVENT_UNMAP |		\
 			   UFFD_FEATURE_MISSING_HUGETLBFS |	\
 			   UFFD_FEATURE_MISSING_SHMEM |		\
 			   UFFD_FEATURE_SIGBUS |		\
-			   UFFD_FEATURE_THREAD_ID |		\
-			   UFFD_FEATURE_MINOR_HUGETLBFS)
+			   UFFD_FEATURE_THREAD_ID)
 #define UFFD_API_IOCTLS				\
 	((__u64)1 << _UFFDIO_REGISTER |		\
 	 (__u64)1 << _UFFDIO_UNREGISTER |	\
@@ -40,12 +36,10 @@
 	((__u64)1 << _UFFDIO_WAKE |		\
 	 (__u64)1 << _UFFDIO_COPY |		\
 	 (__u64)1 << _UFFDIO_ZEROPAGE |		\
-	 (__u64)1 << _UFFDIO_WRITEPROTECT |	\
-	 (__u64)1 << _UFFDIO_CONTINUE)
+	 (__u64)1 << _UFFDIO_WRITEPROTECT)
 #define UFFD_API_RANGE_IOCTLS_BASIC		\
 	((__u64)1 << _UFFDIO_WAKE |		\
-	 (__u64)1 << _UFFDIO_COPY |		\
-	 (__u64)1 << _UFFDIO_CONTINUE)
+	 (__u64)1 << _UFFDIO_COPY)
 
 /*
  * Valid ioctl command number range with this API is from 0x00 to
@@ -61,7 +55,6 @@
 #define _UFFDIO_COPY			(0x03)
 #define _UFFDIO_ZEROPAGE		(0x04)
 #define _UFFDIO_WRITEPROTECT		(0x06)
-#define _UFFDIO_CONTINUE		(0x07)
 #define _UFFDIO_API			(0x3F)
 
 /* userfaultfd ioctl ids */
@@ -80,8 +73,6 @@
 				      struct uffdio_zeropage)
 #define UFFDIO_WRITEPROTECT	_IOWR(UFFDIO, _UFFDIO_WRITEPROTECT, \
 				      struct uffdio_writeprotect)
-#define UFFDIO_CONTINUE		_IOR(UFFDIO, _UFFDIO_CONTINUE,	\
-				     struct uffdio_continue)
 
 /* read() structure */
 struct uffd_msg {
@@ -136,7 +127,6 @@ struct uffd_msg {
 /* flags for UFFD_EVENT_PAGEFAULT */
 #define UFFD_PAGEFAULT_FLAG_WRITE	(1<<0)	/* If this was a write fault */
 #define UFFD_PAGEFAULT_FLAG_WP		(1<<1)	/* If reason is VM_UFFD_WP */
-#define UFFD_PAGEFAULT_FLAG_MINOR	(1<<2)	/* If reason is VM_UFFD_MINOR */
 
 struct uffdio_api {
 	/* userland asks for an API number and the features to enable */
@@ -181,10 +171,6 @@ struct uffdio_api {
 	 *
 	 * UFFD_FEATURE_THREAD_ID pid of the page faulted task_struct will
 	 * be returned, if feature is not requested 0 will be returned.
-	 *
-	 * UFFD_FEATURE_MINOR_HUGETLBFS indicates that minor faults
-	 * can be intercepted (via REGISTER_MODE_MINOR) for
-	 * hugetlbfs-backed pages.
 	 */
 #define UFFD_FEATURE_PAGEFAULT_FLAG_WP		(1<<0)
 #define UFFD_FEATURE_EVENT_FORK			(1<<1)
@@ -195,7 +181,6 @@ struct uffdio_api {
 #define UFFD_FEATURE_EVENT_UNMAP		(1<<6)
 #define UFFD_FEATURE_SIGBUS			(1<<7)
 #define UFFD_FEATURE_THREAD_ID			(1<<8)
-#define UFFD_FEATURE_MINOR_HUGETLBFS		(1<<9)
 	__u64 features;
 
 	__u64 ioctls;
@@ -210,7 +195,6 @@ struct uffdio_register {
 	struct uffdio_range range;
 #define UFFDIO_REGISTER_MODE_MISSING	((__u64)1<<0)
 #define UFFDIO_REGISTER_MODE_WP		((__u64)1<<1)
-#define UFFDIO_REGISTER_MODE_MINOR	((__u64)1<<2)
 	__u64 mode;
 
 	/*
@@ -273,18 +257,6 @@ struct uffdio_writeprotect {
 	__u64 mode;
 };
 
-struct uffdio_continue {
-	struct uffdio_range range;
-#define UFFDIO_CONTINUE_MODE_DONTWAKE		((__u64)1<<0)
-	__u64 mode;
-
-	/*
-	 * Fields below here are written by the ioctl and must be at the end:
-	 * the copy_from_user will not read past here.
-	 */
-	__s64 mapped;
-};
-
 /*
  * Flags for the userfaultfd(2) system call itself.
  */
diff --git a/linux-headers/linux/vfio.h b/linux-headers/linux/vfio.h
index e680594f27..609099e455 100644
--- a/linux-headers/linux/vfio.h
+++ b/linux-headers/linux/vfio.h
@@ -46,12 +46,6 @@
  */
 #define VFIO_NOIOMMU_IOMMU		8
 
-/* Supports VFIO_DMA_UNMAP_FLAG_ALL */
-#define VFIO_UNMAP_ALL			9
-
-/* Supports the vaddr flag for DMA map and unmap */
-#define VFIO_UPDATE_VADDR		10
-
 /*
  * The IOCTL interface is designed for extensibility by embedding the
  * structure length (argsz) and flags into structures passed between
@@ -335,8 +329,6 @@ struct vfio_region_info_cap_type {
 /* 10de vendor PCI sub-types */
 /*
  * NVIDIA GPU NVlink2 RAM is coherent RAM mapped onto the host address space.
- *
- * Deprecated, region no longer provided
  */
 #define VFIO_REGION_SUBTYPE_NVIDIA_NVLINK2_RAM	(1)
 
@@ -344,8 +336,6 @@ struct vfio_region_info_cap_type {
 /*
  * IBM NPU NVlink2 ATSD (Address Translation Shootdown) register of NPU
  * to do TLB invalidation on a GPU.
- *
- * Deprecated, region no longer provided
  */
 #define VFIO_REGION_SUBTYPE_IBM_NVLINK2_ATSD	(1)
 
@@ -645,8 +635,6 @@ struct vfio_device_migration_info {
  * Capability with compressed real address (aka SSA - small system address)
  * where GPU RAM is mapped on a system bus. Used by a GPU for DMA routing
  * and by the userspace to associate a NVLink bridge with a GPU.
- *
- * Deprecated, capability no longer provided
  */
 #define VFIO_REGION_INFO_CAP_NVLINK2_SSATGT	4
 
@@ -661,8 +649,6 @@ struct vfio_region_info_cap_nvlink2_ssatgt {
  * property in the device tree. The value is fixed in the hardware
  * and failing to provide the correct value results in the link
  * not working with no indication from the driver why.
- *
- * Deprecated, capability no longer provided
  */
 #define VFIO_REGION_INFO_CAP_NVLINK2_LNKSPD	5
 
@@ -1088,22 +1074,12 @@ struct vfio_iommu_type1_info_dma_avail {
  *
  * Map process virtual addresses to IO virtual addresses using the
  * provided struct vfio_dma_map. Caller sets argsz. READ &/ WRITE required.
- *
- * If flags & VFIO_DMA_MAP_FLAG_VADDR, update the base vaddr for iova, and
- * unblock translation of host virtual addresses in the iova range.  The vaddr
- * must have previously been invalidated with VFIO_DMA_UNMAP_FLAG_VADDR.  To
- * maintain memory consistency within the user application, the updated vaddr
- * must address the same memory object as originally mapped.  Failure to do so
- * will result in user memory corruption and/or device misbehavior.  iova and
- * size must match those in the original MAP_DMA call.  Protection is not
- * changed, and the READ & WRITE flags must be 0.
  */
 struct vfio_iommu_type1_dma_map {
 	__u32	argsz;
 	__u32	flags;
 #define VFIO_DMA_MAP_FLAG_READ (1 << 0)		/* readable from device */
 #define VFIO_DMA_MAP_FLAG_WRITE (1 << 1)	/* writable from device */
-#define VFIO_DMA_MAP_FLAG_VADDR (1 << 2)
 	__u64	vaddr;				/* Process virtual address */
 	__u64	iova;				/* IO virtual address */
 	__u64	size;				/* Size of mapping (bytes) */
@@ -1126,7 +1102,6 @@ struct vfio_bitmap {
  * field.  No guarantee is made to the user that arbitrary unmaps of iova
  * or size different from those used in the original mapping call will
  * succeed.
- *
  * VFIO_DMA_UNMAP_FLAG_GET_DIRTY_BITMAP should be set to get the dirty bitmap
  * before unmapping IO virtual addresses. When this flag is set, the user must
  * provide a struct vfio_bitmap in data[]. User must provide zero-allocated
@@ -1136,21 +1111,11 @@ struct vfio_bitmap {
  * indicates that the page at that offset from iova is dirty. A Bitmap of the
  * pages in the range of unmapped size is returned in the user-provided
  * vfio_bitmap.data.
- *
- * If flags & VFIO_DMA_UNMAP_FLAG_ALL, unmap all addresses.  iova and size
- * must be 0.  This cannot be combined with the get-dirty-bitmap flag.
- *
- * If flags & VFIO_DMA_UNMAP_FLAG_VADDR, do not unmap, but invalidate host
- * virtual addresses in the iova range.  Tasks that attempt to translate an
- * iova's vaddr will block.  DMA to already-mapped pages continues.  This
- * cannot be combined with the get-dirty-bitmap flag.
  */
 struct vfio_iommu_type1_dma_unmap {
 	__u32	argsz;
 	__u32	flags;
 #define VFIO_DMA_UNMAP_FLAG_GET_DIRTY_BITMAP (1 << 0)
-#define VFIO_DMA_UNMAP_FLAG_ALL		     (1 << 1)
-#define VFIO_DMA_UNMAP_FLAG_VADDR	     (1 << 2)
 	__u64	iova;				/* IO virtual address */
 	__u64	size;				/* Size of mapping (bytes) */
 	__u8    data[];
diff --git a/migration/ram.c b/migration/ram.c
index 60ea913c54..723af67c2e 100644
--- a/migration/ram.c
+++ b/migration/ram.c
@@ -3343,8 +3343,7 @@ int colo_init_ram_cache(void)
     WITH_RCU_READ_LOCK_GUARD() {
         RAMBLOCK_FOREACH_NOT_IGNORED(block) {
             block->colo_cache = qemu_anon_ram_alloc(block->used_length,
-                                                    NULL,
-                                                    false);
+                                                    NULL, false, false);
             if (!block->colo_cache) {
                 error_report("%s: Can't alloc memory for COLO cache of block %s,"
                              "size 0x" RAM_ADDR_FMT, __func__, block->idstr,
diff --git a/qapi/machine.json b/qapi/machine.json
index 58a9c86b36..e4d0f9b24f 100644
--- a/qapi/machine.json
+++ b/qapi/machine.json
@@ -790,11 +790,19 @@
 #
 # @size: memory backend size
 #
-# @merge: enables or disables memory merge support
+# @merge: whether memory merge support is enabled
 #
-# @dump: includes memory backend's memory in a core dump or not
+# @dump: whether memory backend's memory is included in a core dump
 #
-# @prealloc: enables or disables memory preallocation
+# @prealloc: whether memory was preallocated
+#
+# @share: whether memory is private to QEMU or shared (since 6.1)
+#
+# @reserve: whether swap space (or huge pages) was reserved if applicable.
+#           This corresponds to the user configuration and not the actual
+#           behavior implemented in the OS to perform the reservation.
+#           For example, Linux will never reserve swap space for shared
+#           file mappings. (since 6.1)
 #
 # @host-nodes: host nodes for its memory policy
 #
@@ -809,6 +817,8 @@
     'merge':      'bool',
     'dump':       'bool',
     'prealloc':   'bool',
+    'share':      'bool',
+    '*reserve':    'bool',
     'host-nodes': ['uint16'],
     'policy':     'HostMemPolicy' }}
 
diff --git a/qapi/qom.json b/qapi/qom.json
index f7ef30f940..652be317b8 100644
--- a/qapi/qom.json
+++ b/qapi/qom.json
@@ -545,6 +545,9 @@
 # @share: if false, the memory is private to QEMU; if true, it is shared
 #         (default: false)
 #
+# @reserve: if true, reserve swap space (or huge pages) if applicable
+#           (default: true) (since 6.1)
+#
 # @size: size of the memory region in bytes
 #
 # @x-use-canonical-path-for-ramblock-id: if true, the canoncial path is used
@@ -556,6 +559,12 @@
 #                                        false generally, but true for machine
 #                                        types <= 4.0)
 #
+# Note: prealloc=true and reserve=false cannot be set at the same time. With
+#       reserve=true, the behavior depends on the operating system: for example,
+#       Linux will not reserve swap space for shared file mappings --
+#       "not applicable". In contrast, reserve=false will bail out if it cannot
+#       be configured accordingly.
+#
 # Since: 2.1
 ##
 { 'struct': 'MemoryBackendProperties',
@@ -566,6 +575,7 @@
             '*prealloc': 'bool',
             '*prealloc-threads': 'uint32',
             '*share': 'bool',
+            '*reserve': 'bool',
             'size': 'size',
             '*x-use-canonical-path-for-ramblock-id': 'bool' } }
 
diff --git a/scripts/coccinelle/memory-region-housekeeping.cocci b/scripts/coccinelle/memory-region-housekeeping.cocci
index c768d8140a..29651ebde9 100644
--- a/scripts/coccinelle/memory-region-housekeeping.cocci
+++ b/scripts/coccinelle/memory-region-housekeeping.cocci
@@ -127,8 +127,8 @@ static void device_fn(DeviceState *dev, ...)
 - memory_region_init_rom(E1, NULL, E2, E3, E4);
 + memory_region_init_rom(E1, obj, E2, E3, E4);
 |
-- memory_region_init_ram_shared_nomigrate(E1, NULL, E2, E3, E4, E5);
-+ memory_region_init_ram_shared_nomigrate(E1, obj, E2, E3, E4, E5);
+- memory_region_init_ram_flags_nomigrate(E1, NULL, E2, E3, E4, E5);
++ memory_region_init_ram_flags_nomigrate(E1, obj, E2, E3, E4, E5);
 )
   ...+>
 }
@@ -152,8 +152,8 @@ static void device_fn(DeviceState *dev, ...)
 - memory_region_init_rom(E1, NULL, E2, E3, E4);
 + memory_region_init_rom(E1, OBJECT(dev), E2, E3, E4);
 |
-- memory_region_init_ram_shared_nomigrate(E1, NULL, E2, E3, E4, E5);
-+ memory_region_init_ram_shared_nomigrate(E1, OBJECT(dev), E2, E3, E4, E5);
+- memory_region_init_ram_flags_nomigrate(E1, NULL, E2, E3, E4, E5);
++ memory_region_init_ram_flags_nomigrate(E1, OBJECT(dev), E2, E3, E4, E5);
 )
   ...+>
 }
diff --git a/softmmu/memory.c b/softmmu/memory.c
index c19b0be6b1..f0161515e9 100644
--- a/softmmu/memory.c
+++ b/softmmu/memory.c
@@ -1531,22 +1531,22 @@ void memory_region_init_ram_nomigrate(MemoryRegion *mr,
                                       uint64_t size,
                                       Error **errp)
 {
-    memory_region_init_ram_shared_nomigrate(mr, owner, name, size, false, errp);
+    memory_region_init_ram_flags_nomigrate(mr, owner, name, size, 0, errp);
 }
 
-void memory_region_init_ram_shared_nomigrate(MemoryRegion *mr,
-                                             Object *owner,
-                                             const char *name,
-                                             uint64_t size,
-                                             bool share,
-                                             Error **errp)
+void memory_region_init_ram_flags_nomigrate(MemoryRegion *mr,
+                                            Object *owner,
+                                            const char *name,
+                                            uint64_t size,
+                                            uint32_t ram_flags,
+                                            Error **errp)
 {
     Error *err = NULL;
     memory_region_init(mr, owner, name, size);
     mr->ram = true;
     mr->terminates = true;
     mr->destructor = memory_region_destructor_ram;
-    mr->ram_block = qemu_ram_alloc(size, share, mr, &err);
+    mr->ram_block = qemu_ram_alloc(size, ram_flags, mr, &err);
     if (err) {
         mr->size = int128_zero();
         object_unparent(OBJECT(mr));
@@ -1609,7 +1609,7 @@ void memory_region_init_ram_from_fd(MemoryRegion *mr,
                                     Object *owner,
                                     const char *name,
                                     uint64_t size,
-                                    bool share,
+                                    uint32_t ram_flags,
                                     int fd,
                                     ram_addr_t offset,
                                     Error **errp)
@@ -1619,9 +1619,8 @@ void memory_region_init_ram_from_fd(MemoryRegion *mr,
     mr->ram = true;
     mr->terminates = true;
     mr->destructor = memory_region_destructor_ram;
-    mr->ram_block = qemu_ram_alloc_from_fd(size, mr,
-                                           share ? RAM_SHARED : 0,
-                                           fd, offset, false, &err);
+    mr->ram_block = qemu_ram_alloc_from_fd(size, mr, ram_flags, fd, offset,
+                                           false, &err);
     if (err) {
         mr->size = int128_zero();
         object_unparent(OBJECT(mr));
@@ -1683,7 +1682,7 @@ void memory_region_init_rom_nomigrate(MemoryRegion *mr,
                                       uint64_t size,
                                       Error **errp)
 {
-    memory_region_init_ram_shared_nomigrate(mr, owner, name, size, false, errp);
+    memory_region_init_ram_flags_nomigrate(mr, owner, name, size, 0, errp);
     mr->readonly = true;
 }
 
@@ -1703,7 +1702,7 @@ void memory_region_init_rom_device_nomigrate(MemoryRegion *mr,
     mr->terminates = true;
     mr->rom_device = true;
     mr->destructor = memory_region_destructor_ram;
-    mr->ram_block = qemu_ram_alloc(size, false,  mr, &err);
+    mr->ram_block = qemu_ram_alloc(size, 0, mr, &err);
     if (err) {
         mr->size = int128_zero();
         object_unparent(OBJECT(mr));
diff --git a/softmmu/physmem.c b/softmmu/physmem.c
index 1c8717684a..9b171c9dbe 100644
--- a/softmmu/physmem.c
+++ b/softmmu/physmem.c
@@ -1540,6 +1540,7 @@ static void *file_ram_alloc(RAMBlock *block,
                             off_t offset,
                             Error **errp)
 {
+    uint32_t qemu_map_flags;
     void *area;
 
     block->page_size = qemu_fd_getpagesize(fd);
@@ -1587,9 +1588,11 @@ static void *file_ram_alloc(RAMBlock *block,
         perror("ftruncate");
     }
 
-    area = qemu_ram_mmap(fd, memory, block->mr->align, readonly,
-                         block->flags & RAM_SHARED, block->flags & RAM_PMEM,
-                         offset);
+    qemu_map_flags = readonly ? QEMU_MAP_READONLY : 0;
+    qemu_map_flags |= (block->flags & RAM_SHARED) ? QEMU_MAP_SHARED : 0;
+    qemu_map_flags |= (block->flags & RAM_PMEM) ? QEMU_MAP_SYNC : 0;
+    qemu_map_flags |= (block->flags & RAM_NORESERVE) ? QEMU_MAP_NORESERVE : 0;
+    area = qemu_ram_mmap(fd, memory, block->mr->align, qemu_map_flags, offset);
     if (area == MAP_FAILED) {
         error_setg_errno(errp, errno,
                          "unable to map backing store for guest RAM");
@@ -1714,6 +1717,11 @@ bool qemu_ram_is_shared(RAMBlock *rb)
     return rb->flags & RAM_SHARED;
 }
 
+bool qemu_ram_is_noreserve(RAMBlock *rb)
+{
+    return rb->flags & RAM_NORESERVE;
+}
+
 /* Note: Only set at the start of postcopy */
 bool qemu_ram_is_uf_zeroable(RAMBlock *rb)
 {
@@ -1946,8 +1954,10 @@ static void dirty_memory_extend(ram_addr_t old_ram_size,
     }
 }
 
-static void ram_block_add(RAMBlock *new_block, Error **errp, bool shared)
+static void ram_block_add(RAMBlock *new_block, Error **errp)
 {
+    const bool noreserve = qemu_ram_is_noreserve(new_block);
+    const bool shared = qemu_ram_is_shared(new_block);
     RAMBlock *block;
     RAMBlock *last_block = NULL;
     ram_addr_t old_ram_size, new_ram_size;
@@ -1970,7 +1980,7 @@ static void ram_block_add(RAMBlock *new_block, Error **errp, bool shared)
         } else {
             new_block->host = qemu_anon_ram_alloc(new_block->max_length,
                                                   &new_block->mr->align,
-                                                  shared);
+                                                  shared, noreserve);
             if (!new_block->host) {
                 error_setg_errno(errp, errno,
                                  "cannot set up guest memory '%s'",
@@ -2042,7 +2052,7 @@ RAMBlock *qemu_ram_alloc_from_fd(ram_addr_t size, MemoryRegion *mr,
     int64_t file_size, file_align;
 
     /* Just support these ram flags by now. */
-    assert((ram_flags & ~(RAM_SHARED | RAM_PMEM)) == 0);
+    assert((ram_flags & ~(RAM_SHARED | RAM_PMEM | RAM_NORESERVE)) == 0);
 
     if (xen_enabled()) {
         error_setg(errp, "-mem-path not supported with Xen");
@@ -2084,7 +2094,7 @@ RAMBlock *qemu_ram_alloc_from_fd(ram_addr_t size, MemoryRegion *mr,
         return NULL;
     }
 
-    ram_block_add(new_block, &local_err, ram_flags & RAM_SHARED);
+    ram_block_add(new_block, &local_err);
     if (local_err) {
         g_free(new_block);
         error_propagate(errp, local_err);
@@ -2127,12 +2137,17 @@ RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
                                   void (*resized)(const char*,
                                                   uint64_t length,
                                                   void *host),
-                                  void *host, bool resizeable, bool share,
+                                  void *host, uint32_t ram_flags,
                                   MemoryRegion *mr, Error **errp)
 {
     RAMBlock *new_block;
     Error *local_err = NULL;
 
+    assert((ram_flags & ~(RAM_SHARED | RAM_RESIZEABLE | RAM_PREALLOC)) == 0);
+    assert((ram_flags & ~(RAM_SHARED | RAM_RESIZEABLE | RAM_PREALLOC |
+                          RAM_NORESERVE)) == 0);
+    assert(!host ^ (ram_flags & RAM_PREALLOC));
+
     size = HOST_PAGE_ALIGN(size);
     max_size = HOST_PAGE_ALIGN(max_size);
     new_block = g_malloc0(sizeof(*new_block));
@@ -2144,13 +2159,8 @@ RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
     new_block->fd = -1;
     new_block->page_size = qemu_real_host_page_size;
     new_block->host = host;
-    if (host) {
-        new_block->flags |= RAM_PREALLOC;
-    }
-    if (resizeable) {
-        new_block->flags |= RAM_RESIZEABLE;
-    }
-    ram_block_add(new_block, &local_err, share);
+    new_block->flags = ram_flags;
+    ram_block_add(new_block, &local_err);
     if (local_err) {
         g_free(new_block);
         error_propagate(errp, local_err);
@@ -2162,15 +2172,15 @@ RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
 RAMBlock *qemu_ram_alloc_from_ptr(ram_addr_t size, void *host,
                                    MemoryRegion *mr, Error **errp)
 {
-    return qemu_ram_alloc_internal(size, size, NULL, host, false,
-                                   false, mr, errp);
+    return qemu_ram_alloc_internal(size, size, NULL, host, RAM_PREALLOC, mr,
+                                   errp);
 }
 
-RAMBlock *qemu_ram_alloc(ram_addr_t size, bool share,
+RAMBlock *qemu_ram_alloc(ram_addr_t size, uint32_t ram_flags,
                          MemoryRegion *mr, Error **errp)
 {
-    return qemu_ram_alloc_internal(size, size, NULL, NULL, false,
-                                   share, mr, errp);
+    assert((ram_flags & ~(RAM_SHARED | RAM_NORESERVE)) == 0);
+    return qemu_ram_alloc_internal(size, size, NULL, NULL, ram_flags, mr, errp);
 }
 
 RAMBlock *qemu_ram_alloc_resizeable(ram_addr_t size, ram_addr_t maxsz,
@@ -2179,8 +2189,8 @@ RAMBlock *qemu_ram_alloc_resizeable(ram_addr_t size, ram_addr_t maxsz,
                                                      void *host),
                                      MemoryRegion *mr, Error **errp)
 {
-    return qemu_ram_alloc_internal(size, maxsz, resized, NULL, true,
-                                   false, mr, errp);
+    return qemu_ram_alloc_internal(size, maxsz, resized, NULL,
+                                   RAM_RESIZEABLE, mr, errp);
 }
 
 static void reclaim_ramblock(RAMBlock *block)
@@ -2239,13 +2249,14 @@ void qemu_ram_remap(ram_addr_t addr, ram_addr_t length)
                 abort();
             } else {
                 flags = MAP_FIXED;
+                flags |= block->flags & RAM_SHARED ?
+                         MAP_SHARED : MAP_PRIVATE;
+                flags |= block->flags & RAM_NORESERVE ? MAP_NORESERVE : 0;
                 if (block->fd >= 0) {
-                    flags |= (block->flags & RAM_SHARED ?
-                              MAP_SHARED : MAP_PRIVATE);
                     area = mmap(vaddr, length, PROT_READ | PROT_WRITE,
                                 flags, block->fd, offset);
                 } else {
-                    flags |= MAP_PRIVATE | MAP_ANONYMOUS;
+                    flags |= MAP_ANONYMOUS;
                     area = mmap(vaddr, length, PROT_READ | PROT_WRITE,
                                 flags, -1, 0);
                 }
@@ -3523,6 +3534,7 @@ int ram_block_discard_range(RAMBlock *rb, uint64_t start, size_t length)
         /* The logic here is messy;
          *    madvise DONTNEED fails for hugepages
          *    fallocate works on hugepages and shmem
+         *    shared anonymous memory requires madvise REMOVE
          */
         need_madvise = (rb->page_size == qemu_host_page_size);
         need_fallocate = rb->fd != -1;
@@ -3556,7 +3568,11 @@ int ram_block_discard_range(RAMBlock *rb, uint64_t start, size_t length)
              * fallocate'd away).
              */
 #if defined(CONFIG_MADVISE)
-            ret =  madvise(host_startaddr, length, MADV_DONTNEED);
+            if (qemu_ram_is_shared(rb) && rb->fd < 0) {
+                ret = madvise(host_startaddr, length, QEMU_MADV_REMOVE);
+            } else {
+                ret = madvise(host_startaddr, length, QEMU_MADV_DONTNEED);
+            }
             if (ret) {
                 ret = -errno;
                 error_report("ram_block_discard_range: Failed to discard range "
diff --git a/softmmu/runstate.c b/softmmu/runstate.c
index 15640572c0..10d9b7365a 100644
--- a/softmmu/runstate.c
+++ b/softmmu/runstate.c
@@ -747,7 +747,7 @@ static void qemu_run_exit_notifiers(void)
 
 void qemu_init_subsystems(void)
 {
-    Error *err;
+    Error *err = NULL;
 
     os_set_line_buffering();
 
diff --git a/softmmu/vl.c b/softmmu/vl.c
index 326c1e9080..feb4d201f3 100644
--- a/softmmu/vl.c
+++ b/softmmu/vl.c
@@ -2522,7 +2522,7 @@ static void qemu_process_help_options(void)
 
 static void qemu_maybe_daemonize(const char *pid_file)
 {
-    Error *err;
+    Error *err = NULL;
 
     os_daemonize();
     rcu_disable_atfork();
diff --git a/target/i386/cpu.h b/target/i386/cpu.h
index ac3abea97c..1e11071d81 100644
--- a/target/i386/cpu.h
+++ b/target/i386/cpu.h
@@ -224,6 +224,8 @@ typedef enum X86Seg {
 #define CR0_NE_MASK  (1U << 5)
 #define CR0_WP_MASK  (1U << 16)
 #define CR0_AM_MASK  (1U << 18)
+#define CR0_NW_MASK  (1U << 29)
+#define CR0_CD_MASK  (1U << 30)
 #define CR0_PG_MASK  (1U << 31)
 
 #define CR4_VME_MASK  (1U << 0)
@@ -2149,9 +2151,13 @@ static inline void
 cpu_svm_check_intercept_param(CPUX86State *env1, uint32_t type,
                               uint64_t param, uintptr_t retaddr)
 { /* no-op */ }
+static inline bool
+cpu_svm_has_intercept(CPUX86State *env, uint32_t type)
+{ return false; }
 #else
 void cpu_svm_check_intercept_param(CPUX86State *env1, uint32_t type,
                                    uint64_t param, uintptr_t retaddr);
+bool cpu_svm_has_intercept(CPUX86State *env, uint32_t type);
 #endif
 
 /* apic.c */
diff --git a/target/i386/svm.h b/target/i386/svm.h
index 87965e5bc2..5098733053 100644
--- a/target/i386/svm.h
+++ b/target/i386/svm.h
@@ -135,6 +135,8 @@
 #define SVM_NPTEXIT_GPA     (1ULL << 32)
 #define SVM_NPTEXIT_GPT     (1ULL << 33)
 
+#define SVM_CR0_RESERVED_MASK 0xffffffff00000000U
+
 struct QEMU_PACKED vmcb_control_area {
 	uint16_t intercept_cr_read;
 	uint16_t intercept_cr_write;
diff --git a/target/i386/tcg/sysemu/misc_helper.c b/target/i386/tcg/sysemu/misc_helper.c
index 0cef2f1a4c..db0d8a9d79 100644
--- a/target/i386/tcg/sysemu/misc_helper.c
+++ b/target/i386/tcg/sysemu/misc_helper.c
@@ -84,6 +84,15 @@ void helper_write_crN(CPUX86State *env, int reg, target_ulong t0)
 {
     switch (reg) {
     case 0:
+        /*
+        * If we reach this point, the CR0 write intercept is disabled.
+        * But we could still exit if the hypervisor has requested the selective
+        * intercept for bits other than TS and MP
+        */
+        if (cpu_svm_has_intercept(env, SVM_EXIT_CR0_SEL_WRITE) &&
+            ((env->cr[0] ^ t0) & ~(CR0_TS_MASK | CR0_MP_MASK))) {
+            cpu_vmexit(env, SVM_EXIT_CR0_SEL_WRITE, 0, GETPC());
+        }
         cpu_x86_update_cr0(env, t0);
         break;
     case 3:
diff --git a/target/i386/tcg/sysemu/svm_helper.c b/target/i386/tcg/sysemu/svm_helper.c
index 9d671297cf..1c2dbc1862 100644
--- a/target/i386/tcg/sysemu/svm_helper.c
+++ b/target/i386/tcg/sysemu/svm_helper.c
@@ -72,6 +72,8 @@ void helper_vmrun(CPUX86State *env, int aflag, int next_eip_addend)
     uint64_t nested_ctl;
     uint32_t event_inj;
     uint32_t int_ctl;
+    uint32_t asid;
+    uint64_t new_cr0;
 
     cpu_svm_check_intercept_param(env, SVM_EXIT_VMRUN, 0, GETPC());
 
@@ -154,9 +156,18 @@ void helper_vmrun(CPUX86State *env, int aflag, int next_eip_addend)
 
     nested_ctl = x86_ldq_phys(cs, env->vm_vmcb + offsetof(struct vmcb,
                                                           control.nested_ctl));
+    asid = x86_ldq_phys(cs, env->vm_vmcb + offsetof(struct vmcb,
+                                                          control.asid));
 
     env->nested_pg_mode = 0;
 
+    if (!cpu_svm_has_intercept(env, SVM_EXIT_VMRUN)) {
+        cpu_vmexit(env, SVM_EXIT_ERR, 0, GETPC());
+    }
+    if (asid == 0) {
+        cpu_vmexit(env, SVM_EXIT_ERR, 0, GETPC());
+    }
+
     if (nested_ctl & SVM_NPT_ENABLED) {
         env->nested_cr3 = x86_ldq_phys(cs,
                                 env->vm_vmcb + offsetof(struct vmcb,
@@ -182,13 +193,18 @@ void helper_vmrun(CPUX86State *env, int aflag, int next_eip_addend)
     env->idt.limit = x86_ldl_phys(cs, env->vm_vmcb + offsetof(struct vmcb,
                                                       save.idtr.limit));
 
+    new_cr0 = x86_ldq_phys(cs, env->vm_vmcb + offsetof(struct vmcb, save.cr0));
+    if (new_cr0 & SVM_CR0_RESERVED_MASK) {
+        cpu_vmexit(env, SVM_EXIT_ERR, 0, GETPC());
+    }
+    if ((new_cr0 & CR0_NW_MASK) && !(new_cr0 & CR0_CD_MASK)) {
+        cpu_vmexit(env, SVM_EXIT_ERR, 0, GETPC());
+    }
     /* clear exit_info_2 so we behave like the real hardware */
     x86_stq_phys(cs,
              env->vm_vmcb + offsetof(struct vmcb, control.exit_info_2), 0);
 
-    cpu_x86_update_cr0(env, x86_ldq_phys(cs,
-                                     env->vm_vmcb + offsetof(struct vmcb,
-                                                             save.cr0)));
+    cpu_x86_update_cr0(env, new_cr0);
     cpu_x86_update_cr4(env, x86_ldq_phys(cs,
                                      env->vm_vmcb + offsetof(struct vmcb,
                                                              save.cr4)));
@@ -412,80 +428,91 @@ void helper_clgi(CPUX86State *env)
     env->hflags2 &= ~HF2_GIF_MASK;
 }
 
-void cpu_svm_check_intercept_param(CPUX86State *env, uint32_t type,
-                                   uint64_t param, uintptr_t retaddr)
+bool cpu_svm_has_intercept(CPUX86State *env, uint32_t type)
 {
-    CPUState *cs = env_cpu(env);
-
-    if (likely(!(env->hflags & HF_GUEST_MASK))) {
-        return;
-    }
     switch (type) {
     case SVM_EXIT_READ_CR0 ... SVM_EXIT_READ_CR0 + 8:
         if (env->intercept_cr_read & (1 << (type - SVM_EXIT_READ_CR0))) {
-            cpu_vmexit(env, type, param, retaddr);
+            return true;
         }
         break;
     case SVM_EXIT_WRITE_CR0 ... SVM_EXIT_WRITE_CR0 + 8:
         if (env->intercept_cr_write & (1 << (type - SVM_EXIT_WRITE_CR0))) {
-            cpu_vmexit(env, type, param, retaddr);
+            return true;
         }
         break;
     case SVM_EXIT_READ_DR0 ... SVM_EXIT_READ_DR0 + 7:
         if (env->intercept_dr_read & (1 << (type - SVM_EXIT_READ_DR0))) {
-            cpu_vmexit(env, type, param, retaddr);
+            return true;
         }
         break;
     case SVM_EXIT_WRITE_DR0 ... SVM_EXIT_WRITE_DR0 + 7:
         if (env->intercept_dr_write & (1 << (type - SVM_EXIT_WRITE_DR0))) {
-            cpu_vmexit(env, type, param, retaddr);
+            return true;
         }
         break;
     case SVM_EXIT_EXCP_BASE ... SVM_EXIT_EXCP_BASE + 31:
         if (env->intercept_exceptions & (1 << (type - SVM_EXIT_EXCP_BASE))) {
-            cpu_vmexit(env, type, param, retaddr);
-        }
-        break;
-    case SVM_EXIT_MSR:
-        if (env->intercept & (1ULL << (SVM_EXIT_MSR - SVM_EXIT_INTR))) {
-            /* FIXME: this should be read in at vmrun (faster this way?) */
-            uint64_t addr = x86_ldq_phys(cs, env->vm_vmcb +
-                                     offsetof(struct vmcb,
-                                              control.msrpm_base_pa));
-            uint32_t t0, t1;
-
-            switch ((uint32_t)env->regs[R_ECX]) {
-            case 0 ... 0x1fff:
-                t0 = (env->regs[R_ECX] * 2) % 8;
-                t1 = (env->regs[R_ECX] * 2) / 8;
-                break;
-            case 0xc0000000 ... 0xc0001fff:
-                t0 = (8192 + env->regs[R_ECX] - 0xc0000000) * 2;
-                t1 = (t0 / 8);
-                t0 %= 8;
-                break;
-            case 0xc0010000 ... 0xc0011fff:
-                t0 = (16384 + env->regs[R_ECX] - 0xc0010000) * 2;
-                t1 = (t0 / 8);
-                t0 %= 8;
-                break;
-            default:
-                cpu_vmexit(env, type, param, retaddr);
-                t0 = 0;
-                t1 = 0;
-                break;
-            }
-            if (x86_ldub_phys(cs, addr + t1) & ((1 << param) << t0)) {
-                cpu_vmexit(env, type, param, retaddr);
-            }
+            return true;
         }
         break;
     default:
         if (env->intercept & (1ULL << (type - SVM_EXIT_INTR))) {
-            cpu_vmexit(env, type, param, retaddr);
+            return true;
         }
         break;
     }
+    return false;
+}
+
+void cpu_svm_check_intercept_param(CPUX86State *env, uint32_t type,
+                                   uint64_t param, uintptr_t retaddr)
+{
+    CPUState *cs = env_cpu(env);
+
+    if (likely(!(env->hflags & HF_GUEST_MASK))) {
+        return;
+    }
+
+    if (!cpu_svm_has_intercept(env, type)) {
+        return;
+    }
+
+    if (type == SVM_EXIT_MSR) {
+        /* FIXME: this should be read in at vmrun (faster this way?) */
+        uint64_t addr = x86_ldq_phys(cs, env->vm_vmcb +
+                                    offsetof(struct vmcb,
+                                            control.msrpm_base_pa));
+        uint32_t t0, t1;
+
+        switch ((uint32_t)env->regs[R_ECX]) {
+        case 0 ... 0x1fff:
+            t0 = (env->regs[R_ECX] * 2) % 8;
+            t1 = (env->regs[R_ECX] * 2) / 8;
+            break;
+        case 0xc0000000 ... 0xc0001fff:
+            t0 = (8192 + env->regs[R_ECX] - 0xc0000000) * 2;
+            t1 = (t0 / 8);
+            t0 %= 8;
+            break;
+        case 0xc0010000 ... 0xc0011fff:
+            t0 = (16384 + env->regs[R_ECX] - 0xc0010000) * 2;
+            t1 = (t0 / 8);
+            t0 %= 8;
+            break;
+        default:
+            cpu_vmexit(env, type, param, retaddr);
+            t0 = 0;
+            t1 = 0;
+            break;
+        }
+        if (x86_ldub_phys(cs, addr + t1) & ((1 << param) << t0)) {
+            cpu_vmexit(env, type, param, retaddr);
+        }
+        return;
+    }
+
+    cpu_vmexit(env, type, param, retaddr);
 }
 
 void helper_svm_check_intercept(CPUX86State *env, uint32_t type)
diff --git a/ui/vnc-auth-sasl.c b/ui/vnc-auth-sasl.c
index df7dc08e9f..47fdae5b21 100644
--- a/ui/vnc-auth-sasl.c
+++ b/ui/vnc-auth-sasl.c
@@ -28,10 +28,30 @@
 #include "vnc.h"
 #include "trace.h"
 
+/*
+ * Apple has deprecated sasl.h functions in OS X 10.11.  Therefore,
+ * files that use SASL API need to disable -Wdeprecated-declarations.
+ */
+#ifdef CONFIG_DARWIN
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+#endif
+
 /* Max amount of data we send/recv for SASL steps to prevent DOS */
 #define SASL_DATA_MAX_LEN (1024 * 1024)
 
 
+bool vnc_sasl_server_init(Error **errp)
+{
+    int saslErr = sasl_server_init(NULL, "qemu");
+
+    if (saslErr != SASL_OK) {
+        error_setg(errp, "Failed to initialize SASL auth: %s",
+                   sasl_errstring(saslErr, NULL, NULL));
+        return false;
+    }
+    return true;
+}
+
 void vnc_sasl_client_cleanup(VncState *vs)
 {
     if (vs->sasl.conn) {
diff --git a/ui/vnc-auth-sasl.h b/ui/vnc-auth-sasl.h
index 1bfb86c6f5..367b8672cc 100644
--- a/ui/vnc-auth-sasl.h
+++ b/ui/vnc-auth-sasl.h
@@ -63,6 +63,7 @@ struct VncDisplaySASL {
     char *authzid;
 };
 
+bool vnc_sasl_server_init(Error **errp);
 void vnc_sasl_client_cleanup(VncState *vs);
 
 size_t vnc_client_read_sasl(VncState *vs);
diff --git a/ui/vnc.c b/ui/vnc.c
index b3d4d7b9a5..f0a1550d58 100644
--- a/ui/vnc.c
+++ b/ui/vnc.c
@@ -4154,14 +4154,8 @@ void vnc_display_open(const char *id, Error **errp)
     trace_vnc_auth_init(vd, 1, vd->ws_auth, vd->ws_subauth);
 
 #ifdef CONFIG_VNC_SASL
-    if (sasl) {
-        int saslErr = sasl_server_init(NULL, "qemu");
-
-        if (saslErr != SASL_OK) {
-            error_setg(errp, "Failed to initialize SASL auth: %s",
-                       sasl_errstring(saslErr, NULL, NULL));
-            goto fail;
-        }
+    if (sasl && !vnc_sasl_server_init(errp)) {
+        goto fail;
     }
 #endif
     vd->lock_key_sync = lock_key_sync;
diff --git a/util/mmap-alloc.c b/util/mmap-alloc.c
index e6fa8b598b..838e286ce5 100644
--- a/util/mmap-alloc.c
+++ b/util/mmap-alloc.c
@@ -20,6 +20,8 @@
 #include "qemu/osdep.h"
 #include "qemu/mmap-alloc.h"
 #include "qemu/host-utils.h"
+#include "qemu/cutils.h"
+#include "qemu/error-report.h"
 
 #define HUGETLBFS_MAGIC       0x958458f6
 
@@ -82,32 +84,81 @@ size_t qemu_mempath_getpagesize(const char *mem_path)
     return qemu_real_host_page_size;
 }
 
-void *qemu_ram_mmap(int fd,
-                    size_t size,
-                    size_t align,
-                    bool readonly,
-                    bool shared,
-                    bool is_pmem,
-                    off_t map_offset)
+#define OVERCOMMIT_MEMORY_PATH "/proc/sys/vm/overcommit_memory"
+static bool map_noreserve_effective(int fd, uint32_t qemu_map_flags)
 {
-    int prot;
-    int flags;
-    int map_sync_flags = 0;
-    int guardfd;
-    size_t offset;
-    size_t pagesize;
-    size_t total;
-    void *guardptr;
-    void *ptr;
+#if defined(__linux__)
+    const bool readonly = qemu_map_flags & QEMU_MAP_READONLY;
+    const bool shared = qemu_map_flags & QEMU_MAP_SHARED;
+    gchar *content = NULL;
+    const char *endptr;
+    unsigned int tmp;
 
     /*
-     * Note: this always allocates at least one extra page of virtual address
-     * space, even if size is already aligned.
+     * hugeltb accounting is different than ordinary swap reservation:
+     * a) Hugetlb pages from the pool are reserved for both private and
+     *    shared mappings. For shared mappings, all mappers have to specify
+     *    MAP_NORESERVE.
+     * b) MAP_NORESERVE is not affected by /proc/sys/vm/overcommit_memory.
      */
-    total = size + align;
+    if (qemu_fd_getpagesize(fd) != qemu_real_host_page_size) {
+        return true;
+    }
+
+    /*
+     * Accountable mappings in the kernel that can be affected by MAP_NORESEVE
+     * are private writable mappings (see mm/mmap.c:accountable_mapping() in
+     * Linux). For all shared or readonly mappings, MAP_NORESERVE is always
+     * implicitly active -- no reservation; this includes shmem. The only
+     * exception is shared anonymous memory, it is accounted like private
+     * anonymous memory.
+     */
+    if (readonly || (shared && fd >= 0)) {
+        return true;
+    }
+
+    /*
+     * MAP_NORESERVE is globally ignored for applicable !hugetlb mappings when
+     * memory overcommit is set to "never". Sparse memory regions aren't really
+     * possible in this system configuration.
+     *
+     * Bail out now instead of silently committing way more memory than
+     * currently desired by the user.
+     */
+    if (g_file_get_contents(OVERCOMMIT_MEMORY_PATH, &content, NULL, NULL) &&
+        !qemu_strtoui(content, &endptr, 0, &tmp) &&
+        (!endptr || *endptr == '\n')) {
+        if (tmp == 2) {
+            error_report("Skipping reservation of swap space is not supported:"
+                         " \"" OVERCOMMIT_MEMORY_PATH "\" is \"2\"");
+            return false;
+        }
+        return true;
+    }
+    /* this interface has been around since Linux 2.6 */
+    error_report("Skipping reservation of swap space is not supported:"
+                 " Could not read: \"" OVERCOMMIT_MEMORY_PATH "\"");
+    return false;
+#endif
+    /*
+     * E.g., FreeBSD used to define MAP_NORESERVE, never implemented it,
+     * and removed it a while ago.
+     */
+    error_report("Skipping reservation of swap space is not supported");
+    return false;
+}
+
+/*
+ * Reserve a new memory region of the requested size to be used for mapping
+ * from the given fd (if any).
+ */
+static void *mmap_reserve(size_t size, int fd)
+{
+    int flags = MAP_PRIVATE;
 
 #if defined(__powerpc64__) && defined(__linux__)
-    /* On ppc64 mappings in the same segment (aka slice) must share the same
+    /*
+     * On ppc64 mappings in the same segment (aka slice) must share the same
      * page size. Since we will be re-allocating part of this segment
      * from the supplied fd, we should make sure to use the same page size, to
      * this end we mmap the supplied fd.  In this case, set MAP_NORESERVE to
@@ -115,52 +166,55 @@ void *qemu_ram_mmap(int fd,
      * We do this unless we are using the system page size, in which case
      * anonymous memory is OK.
      */
-    flags = MAP_PRIVATE;
-    pagesize = qemu_fd_getpagesize(fd);
-    if (fd == -1 || pagesize == qemu_real_host_page_size) {
-        guardfd = -1;
+    if (fd == -1 || qemu_fd_getpagesize(fd) == qemu_real_host_page_size) {
+        fd = -1;
         flags |= MAP_ANONYMOUS;
     } else {
-        guardfd = fd;
         flags |= MAP_NORESERVE;
     }
 #else
-    guardfd = -1;
-    pagesize = qemu_real_host_page_size;
-    flags = MAP_PRIVATE | MAP_ANONYMOUS;
+    fd = -1;
+    flags |= MAP_ANONYMOUS;
 #endif
 
-    guardptr = mmap(0, total, PROT_NONE, flags, guardfd, 0);
+    return mmap(0, size, PROT_NONE, flags, fd, 0);
+}
 
-    if (guardptr == MAP_FAILED) {
+/*
+ * Activate memory in a reserved region from the given fd (if any), to make
+ * it accessible.
+ */
+static void *mmap_activate(void *ptr, size_t size, int fd,
+                           uint32_t qemu_map_flags, off_t map_offset)
+{
+    const bool noreserve = qemu_map_flags & QEMU_MAP_NORESERVE;
+    const bool readonly = qemu_map_flags & QEMU_MAP_READONLY;
+    const bool shared = qemu_map_flags & QEMU_MAP_SHARED;
+    const bool sync = qemu_map_flags & QEMU_MAP_SYNC;
+    const int prot = PROT_READ | (readonly ? 0 : PROT_WRITE);
+    int map_sync_flags = 0;
+    int flags = MAP_FIXED;
+    void *activated_ptr;
+
+    if (noreserve && !map_noreserve_effective(fd, qemu_map_flags)) {
         return MAP_FAILED;
     }
 
-    assert(is_power_of_2(align));
-    /* Always align to host page size */
-    assert(align >= pagesize);
-
-    flags = MAP_FIXED;
     flags |= fd == -1 ? MAP_ANONYMOUS : 0;
     flags |= shared ? MAP_SHARED : MAP_PRIVATE;
-    if (shared && is_pmem) {
+    flags |= noreserve ? MAP_NORESERVE : 0;
+    if (shared && sync) {
         map_sync_flags = MAP_SYNC | MAP_SHARED_VALIDATE;
     }
 
-    offset = QEMU_ALIGN_UP((uintptr_t)guardptr, align) - (uintptr_t)guardptr;
-
-    prot = PROT_READ | (readonly ? 0 : PROT_WRITE);
-
-    ptr = mmap(guardptr + offset, size, prot,
-               flags | map_sync_flags, fd, map_offset);
-
-    if (ptr == MAP_FAILED && map_sync_flags) {
+    activated_ptr = mmap(ptr, size, prot, flags | map_sync_flags, fd,
+                         map_offset);
+    if (activated_ptr == MAP_FAILED && map_sync_flags) {
         if (errno == ENOTSUP) {
-            char *proc_link, *file_name;
-            int len;
-            proc_link = g_strdup_printf("/proc/self/fd/%d", fd);
-            file_name = g_malloc0(PATH_MAX);
-            len = readlink(proc_link, file_name, PATH_MAX - 1);
+            char *proc_link = g_strdup_printf("/proc/self/fd/%d", fd);
+            char *file_name = g_malloc0(PATH_MAX);
+            int len = readlink(proc_link, file_name, PATH_MAX - 1);
+
             if (len < 0) {
                 len = 0;
             }
@@ -173,12 +227,53 @@ void *qemu_ram_mmap(int fd,
             g_free(file_name);
         }
         /*
-         * if map failed with MAP_SHARED_VALIDATE | MAP_SYNC,
-         * we will remove these flags to handle compatibility.
+         * If mmap failed with MAP_SHARED_VALIDATE | MAP_SYNC, we will try
+         * again without these flags to handle backwards compatibility.
          */
-        ptr = mmap(guardptr + offset, size, prot, flags, fd, map_offset);
+        activated_ptr = mmap(ptr, size, prot, flags, fd, map_offset);
     }
+    return activated_ptr;
+}
 
+static inline size_t mmap_guard_pagesize(int fd)
+{
+#if defined(__powerpc64__) && defined(__linux__)
+    /* Mappings in the same segment must share the same page size */
+    return qemu_fd_getpagesize(fd);
+#else
+    return qemu_real_host_page_size;
+#endif
+}
+
+void *qemu_ram_mmap(int fd,
+                    size_t size,
+                    size_t align,
+                    uint32_t qemu_map_flags,
+                    off_t map_offset)
+{
+    const size_t guard_pagesize = mmap_guard_pagesize(fd);
+    size_t offset, total;
+    void *ptr, *guardptr;
+
+    /*
+     * Note: this always allocates at least one extra page of virtual address
+     * space, even if size is already aligned.
+     */
+    total = size + align;
+
+    guardptr = mmap_reserve(total, fd);
+    if (guardptr == MAP_FAILED) {
+        return MAP_FAILED;
+    }
+
+    assert(is_power_of_2(align));
+    /* Always align to host page size */
+    assert(align >= guard_pagesize);
+
+    offset = QEMU_ALIGN_UP((uintptr_t)guardptr, align) - (uintptr_t)guardptr;
+
+    ptr = mmap_activate(guardptr + offset, size, fd, qemu_map_flags,
+                        map_offset);
     if (ptr == MAP_FAILED) {
         munmap(guardptr, total);
         return MAP_FAILED;
@@ -193,8 +288,8 @@ void *qemu_ram_mmap(int fd,
      * a guard page guarding against potential buffer overflows.
      */
     total -= offset;
-    if (total > size + pagesize) {
-        munmap(ptr + size + pagesize, total - size - pagesize);
+    if (total > size + guard_pagesize) {
+        munmap(ptr + size + guard_pagesize, total - size - guard_pagesize);
     }
 
     return ptr;
@@ -202,15 +297,8 @@ void *qemu_ram_mmap(int fd,
 
 void qemu_ram_munmap(int fd, void *ptr, size_t size)
 {
-    size_t pagesize;
-
     if (ptr) {
         /* Unmap both the RAM block and the guard page */
-#if defined(__powerpc64__) && defined(__linux__)
-        pagesize = qemu_fd_getpagesize(fd);
-#else
-        pagesize = qemu_real_host_page_size;
-#endif
-        munmap(ptr, size + pagesize);
+        munmap(ptr, size + mmap_guard_pagesize(fd));
     }
 }
diff --git a/util/oslib-posix.c b/util/oslib-posix.c
index 7b4bec1402..e8bdb02e1d 100644
--- a/util/oslib-posix.c
+++ b/util/oslib-posix.c
@@ -227,10 +227,13 @@ void *qemu_memalign(size_t alignment, size_t size)
 }
 
 /* alloc shared memory pages */
-void *qemu_anon_ram_alloc(size_t size, uint64_t *alignment, bool shared)
+void *qemu_anon_ram_alloc(size_t size, uint64_t *alignment, bool shared,
+                          bool noreserve)
 {
+    const uint32_t qemu_map_flags = (shared ? QEMU_MAP_SHARED : 0) |
+                                    (noreserve ? QEMU_MAP_NORESERVE : 0);
     size_t align = QEMU_VMALLOC_ALIGN;
-    void *ptr = qemu_ram_mmap(-1, size, align, false, shared, false, 0);
+    void *ptr = qemu_ram_mmap(-1, size, align, qemu_map_flags, 0);
 
     if (ptr == MAP_FAILED) {
         return NULL;
diff --git a/util/oslib-win32.c b/util/oslib-win32.c
index ca99356fdf..ee3a3692d8 100644
--- a/util/oslib-win32.c
+++ b/util/oslib-win32.c
@@ -38,6 +38,7 @@
 #include "trace.h"
 #include "qemu/sockets.h"
 #include "qemu/cutils.h"
+#include "qemu/error-report.h"
 #include <malloc.h>
 
 /* this must come after including "trace.h" */
@@ -76,10 +77,20 @@ static int get_allocation_granularity(void)
     return system_info.dwAllocationGranularity;
 }
 
-void *qemu_anon_ram_alloc(size_t size, uint64_t *align, bool shared)
+void *qemu_anon_ram_alloc(size_t size, uint64_t *align, bool shared,
+                          bool noreserve)
 {
     void *ptr;
 
+    if (noreserve) {
+        /*
+         * We need a MEM_COMMIT before accessing any memory in a MEM_RESERVE
+         * area; we cannot easily mimic POSIX MAP_NORESERVE semantics.
+         */
+        error_report("Skipping reservation of swap space is not supported.");
+        return NULL;
+    }
+
     ptr = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);
     trace_qemu_anon_ram_alloc(size, ptr);
 
diff --git a/util/qemu-config.c b/util/qemu-config.c
index 374f3bc460..84ee6dc4ea 100644
--- a/util/qemu-config.c
+++ b/util/qemu-config.c
@@ -429,29 +429,14 @@ out:
 void qemu_config_do_parse(const char *group, QDict *qdict, void *opaque, Error **errp)
 {
     QemuOptsList **lists = opaque;
-    const char *id = qdict_get_try_str(qdict, "id");
     QemuOptsList *list;
-    QemuOpts *opts;
-    const QDictEntry *unrecognized;
 
     list = find_list(lists, group, errp);
     if (!list) {
         return;
     }
 
-    opts = qemu_opts_create(list, id, 1, errp);
-    if (!opts) {
-        return;
-    }
-    if (!qemu_opts_absorb_qdict(opts, qdict, errp)) {
-        qemu_opts_del(opts);
-        return;
-    }
-    unrecognized = qdict_first(qdict);
-    if (unrecognized) {
-        error_setg(errp, QERR_INVALID_PARAMETER, unrecognized->key);
-        qemu_opts_del(opts);
-    }
+    qemu_opts_from_qdict(list, qdict, errp);
 }
 
 int qemu_config_parse(FILE *fp, QemuOptsList **lists, const char *fname, Error **errp)